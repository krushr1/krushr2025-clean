var O=f=>(l,r,n)=>{let o=n.subscribe;return n.subscribe=(u,i,a)=>{let c=u;if(i){let y=a?.equalityFn||Object.is,m=u(n.getState());c=S=>{let d=u(S);if(!y(m,d)){let p=m;i(m=d,p)}},a?.fireImmediately&&i(m,m)}return o(c)},f(l,r,n)},w=O;function T(f,l){let r;try{r=f()}catch{return}return{getItem:o=>{var e;let u=a=>a===null?null:JSON.parse(a,l?.reviver),i=(e=r.getItem(o))!=null?e:null;return i instanceof Promise?i.then(u):u(i)},setItem:(o,e)=>r.setItem(o,JSON.stringify(e,l?.replacer)),removeItem:o=>r.removeItem(o)}}var _=f=>l=>{try{let r=f(l);return r instanceof Promise?r:{then(n){return _(n)(r)},catch(n){return this}}}catch(r){return{then(n){return this},catch(n){return _(n)(r)}}}},E=(f,l)=>(r,n,o)=>{let e={storage:T(()=>localStorage),partialize:t=>t,version:0,merge:(t,h)=>({...h,...t}),...l},u=!1,i=new Set,a=new Set,c=e.storage;if(!c)return f((...t)=>{console.warn(`[zustand persist middleware] Unable to update item '${e.name}', the given storage is currently unavailable.`),r(...t)},n,o);let y=()=>{let t=e.partialize({...n()});return c.setItem(e.name,{state:t,version:e.version})},m=o.setState;o.setState=(t,h)=>{m(t,h),y()};let S=f((...t)=>{r(...t),y()},n,o);o.getInitialState=()=>S;let d,p=()=>{var t,h;if(!c)return;u=!1,i.forEach(s=>{var v;return s((v=n())!=null?v:S)});let g=((h=e.onRehydrateStorage)==null?void 0:h.call(e,(t=n())!=null?t:S))||void 0;return _(c.getItem.bind(c))(e.name).then(s=>{if(s)if(typeof s.version=="number"&&s.version!==e.version){if(e.migrate){let v=e.migrate(s.state,s.version);return v instanceof Promise?v.then(b=>[!0,b]):[!0,v]}console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return[!1,s.state];return[!1,void 0]}).then(s=>{var v;let[b,I]=s;if(d=e.merge(I,(v=n())!=null?v:S),r(d,!0),b)return y()}).then(()=>{g?.(d,void 0),d=n(),u=!0,a.forEach(s=>s(d))}).catch(s=>{g?.(void 0,s)})};return o.persist={setOptions:t=>{e={...e,...t},t.storage&&(c=t.storage)},clearStorage:()=>{c?.removeItem(e.name)},getOptions:()=>e,rehydrate:()=>p(),hasHydrated:()=>u,onHydrate:t=>(i.add(t),()=>{i.delete(t)}),onFinishHydration:t=>(a.add(t),()=>{a.delete(t)})},e.skipHydration||p(),d||S},C=E;export{w as a,C as b};
