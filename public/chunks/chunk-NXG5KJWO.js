import{c as C,d as j}from"/chunks/chunk-UTGMEFH3.js";var I=C(j(),1);var O=n=>{let e,t=new Set,r=(c,y)=>{let d=typeof c=="function"?c(e):c;if(!Object.is(d,e)){let m=e;e=y??(typeof d!="object"||d===null)?d:Object.assign({},e,d),t.forEach(v=>v(e,m))}},i=()=>e,a={setState:r,getState:i,getInitialState:()=>u,subscribe:c=>(t.add(c),()=>t.delete(c))},u=e=n(r,i,a);return a},E=n=>n?O(n):O;var x=n=>n;function N(n,e=x){let t=I.default.useSyncExternalStore(n.subscribe,()=>e(n.getState()),()=>e(n.getInitialState()));return I.default.useDebugValue(t),t}var T=n=>{let e=E(n),t=r=>N(e,r);return Object.assign(t,e),t},A=n=>n?T(n):T;var R=n=>(e,t,r)=>{let i=r.subscribe;return r.subscribe=(f,a,u)=>{let c=f;if(a){let y=u?.equalityFn||Object.is,d=f(r.getState());c=m=>{let v=f(m);if(!y(d,v)){let p=d;a(d=v,p)}},u?.fireImmediately&&a(d,d)}return i(c)},n(e,t,r)},P=R;function D(n,e){let t;try{t=n()}catch{return}return{getItem:i=>{var o;let f=u=>u===null?null:JSON.parse(u,e?.reviver),a=(o=t.getItem(i))!=null?o:null;return a instanceof Promise?a.then(f):f(a)},setItem:(i,o)=>t.setItem(i,JSON.stringify(o,e?.replacer)),removeItem:i=>t.removeItem(i)}}var _=n=>e=>{try{let t=n(e);return t instanceof Promise?t:{then(r){return _(r)(t)},catch(r){return this}}}catch(t){return{then(r){return this},catch(r){return _(r)(t)}}}},k=(n,e)=>(t,r,i)=>{let o={storage:D(()=>localStorage),partialize:s=>s,version:0,merge:(s,h)=>({...h,...s}),...e},f=!1,a=new Set,u=new Set,c=o.storage;if(!c)return n((...s)=>{console.warn(`[zustand persist middleware] Unable to update item '${o.name}', the given storage is currently unavailable.`),t(...s)},r,i);let y=()=>{let s=o.partialize({...r()});return c.setItem(o.name,{state:s,version:o.version})},d=i.setState;i.setState=(s,h)=>{d(s,h),y()};let m=n((...s)=>{t(...s),y()},r,i);i.getInitialState=()=>m;let v,p=()=>{var s,h;if(!c)return;f=!1,a.forEach(l=>{var S;return l((S=r())!=null?S:m)});let g=((h=o.onRehydrateStorage)==null?void 0:h.call(o,(s=r())!=null?s:m))||void 0;return _(c.getItem.bind(c))(o.name).then(l=>{if(l)if(typeof l.version=="number"&&l.version!==o.version){if(o.migrate){let S=o.migrate(l.state,l.version);return S instanceof Promise?S.then(b=>[!0,b]):[!0,S]}console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return[!1,l.state];return[!1,void 0]}).then(l=>{var S;let[b,w]=l;if(v=o.merge(w,(S=r())!=null?S:m),t(v,!0),b)return y()}).then(()=>{g?.(v,void 0),v=r(),f=!0,u.forEach(l=>l(v))}).catch(l=>{g?.(void 0,l)})};return i.persist={setOptions:s=>{o={...o,...s},s.storage&&(c=s.storage)},clearStorage:()=>{c?.removeItem(o.name)},getOptions:()=>o,rehydrate:()=>p(),hasHydrated:()=>f,onHydrate:s=>(a.add(s),()=>{a.delete(s)}),onFinishHydration:s=>(u.add(s),()=>{u.delete(s)})},o.skipHydration||p(),v||m},H=k;export{A as a,P as b,H as c};
