{
  "version": 3,
  "sources": ["../../node_modules/@tanstack/query-core/src/subscribable.ts", "../../node_modules/@tanstack/query-core/src/utils.ts", "../../node_modules/@tanstack/query-core/src/focusManager.ts", "../../node_modules/@tanstack/query-core/src/onlineManager.ts", "../../node_modules/@tanstack/query-core/src/thenable.ts", "../../node_modules/@tanstack/query-core/src/retryer.ts", "../../node_modules/@tanstack/query-core/src/notifyManager.ts", "../../node_modules/@tanstack/query-core/src/removable.ts", "../../node_modules/@tanstack/query-core/src/query.ts", "../../node_modules/@tanstack/query-core/src/queryCache.ts", "../../node_modules/@tanstack/query-core/src/mutation.ts", "../../node_modules/@tanstack/query-core/src/mutationCache.ts", "../../node_modules/@tanstack/query-core/src/infiniteQueryBehavior.ts", "../../node_modules/@tanstack/query-core/src/queryClient.ts", "../../node_modules/@tanstack/query-core/src/queryObserver.ts", "../../node_modules/@tanstack/query-core/src/queriesObserver.ts", "../../node_modules/@tanstack/query-core/src/infiniteQueryObserver.ts", "../../node_modules/@tanstack/query-core/src/mutationObserver.ts", "../../node_modules/@tanstack/react-query/src/useQueries.ts", "../../node_modules/@tanstack/react-query/src/QueryClientProvider.tsx", "../../node_modules/@tanstack/react-query/src/IsRestoringProvider.ts", "../../node_modules/@tanstack/react-query/src/QueryErrorResetBoundary.tsx", "../../node_modules/@tanstack/react-query/src/errorBoundaryUtils.ts", "../../node_modules/@tanstack/react-query/src/suspense.ts", "../../node_modules/@tanstack/react-query/src/useBaseQuery.ts", "../../node_modules/@tanstack/react-query/src/useQuery.ts", "../../node_modules/@tanstack/react-query/src/useSuspenseQuery.ts", "../../node_modules/@tanstack/react-query/src/useSuspenseInfiniteQuery.ts", "../../node_modules/@tanstack/react-query/src/useSuspenseQueries.ts", "../../node_modules/@tanstack/react-query/src/usePrefetchQuery.tsx", "../../node_modules/@tanstack/react-query/src/usePrefetchInfiniteQuery.tsx", "../../node_modules/@tanstack/react-query/src/queryOptions.ts", "../../node_modules/@tanstack/react-query/src/infiniteQueryOptions.ts", "../../node_modules/@tanstack/react-query/src/useMutation.ts", "../../node_modules/@tanstack/react-query/src/useInfiniteQuery.ts", "../../node_modules/@trpc/server/src/unstable-core-do-not-import/rpc/codes.ts", "../../node_modules/@trpc/server/src/unstable-core-do-not-import/utils.ts", "../../node_modules/@trpc/server/src/unstable-core-do-not-import/createProxy.ts", "../../node_modules/@trpc/server/src/unstable-core-do-not-import/http/getHTTPStatusCode.ts", "../../node_modules/node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/typeof.js", "../../node_modules/node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/toPrimitive.js", "../../node_modules/node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/toPropertyKey.js", "../../node_modules/node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/defineProperty.js", "../../node_modules/node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/objectSpread2.js", "../../node_modules/@trpc/server/src/unstable-core-do-not-import/error/getErrorShape.ts", "../../node_modules/@trpc/server/src/unstable-core-do-not-import/error/formatter.ts", "../../node_modules/@trpc/server/src/unstable-core-do-not-import/error/TRPCError.ts", "../../node_modules/@trpc/server/src/unstable-core-do-not-import/transformer.ts", "../../node_modules/@trpc/server/src/unstable-core-do-not-import/router.ts", "../../node_modules/@trpc/server/src/unstable-core-do-not-import/stream/tracked.ts", "../../node_modules/@trpc/server/src/observable/observable.ts", "../../node_modules/node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/objectWithoutPropertiesLoose.js", "../../node_modules/node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/objectWithoutProperties.js", "../../node_modules/node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/typeof.js", "../../node_modules/node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/toPrimitive.js", "../../node_modules/node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/toPropertyKey.js", "../../node_modules/node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/defineProperty.js", "../../node_modules/node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/objectSpread2.js", "../../node_modules/@trpc/react-query/src/internals/getQueryKey.ts", "../../node_modules/node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/typeof.js", "../../node_modules/node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/toPrimitive.js", "../../node_modules/node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/toPropertyKey.js", "../../node_modules/node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/defineProperty.js", "../../node_modules/node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/objectSpread2.js", "../../node_modules/@trpc/server/src/observable/operators.ts", "../../node_modules/@trpc/server/src/observable/behaviorSubject.ts", "../../node_modules/@trpc/client/src/links/internals/createChain.ts", "../../node_modules/@trpc/client/src/links/splitLink.ts", "../../node_modules/@trpc/client/src/TRPCClientError.ts", "../../node_modules/@trpc/client/src/internals/transformer.ts", "../../node_modules/@trpc/client/src/getFetch.ts", "../../node_modules/@trpc/client/src/links/internals/httpUtils.ts", "../../node_modules/@trpc/client/src/links/internals/contentTypes.ts", "../../node_modules/@trpc/client/src/links/httpLink.ts", "../../node_modules/@trpc/client/src/links/loggerLink.ts", "../../node_modules/@trpc/client/src/links/wsLink/wsClient/options.ts", "../../node_modules/@trpc/client/src/links/internals/urlWithConnectionParams.ts", "../../node_modules/@trpc/client/src/links/wsLink/wsClient/utils.ts", "../../node_modules/@trpc/client/src/links/wsLink/wsClient/requestManager.ts", "../../node_modules/@trpc/client/src/links/wsLink/wsClient/wsConnection.ts", "../../node_modules/@trpc/client/src/links/wsLink/wsClient/wsClient.ts", "../../node_modules/@trpc/client/src/links/wsLink/createWsClient.ts", "../../node_modules/@trpc/client/src/links/wsLink/wsLink.ts", "../../node_modules/@trpc/client/src/internals/TRPCUntypedClient.ts", "../../node_modules/@trpc/client/src/createTRPCUntypedClient.ts", "../../node_modules/@trpc/client/src/createTRPCClient.ts", "../../node_modules/@trpc/client/src/links/httpBatchStreamLink.ts", "../../node_modules/@trpc/client/src/internals/inputWithTrackedEventId.ts", "../../node_modules/node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/asyncIterator.js", "../../node_modules/@trpc/client/src/links/httpSubscriptionLink.ts", "../../node_modules/@trpc/client/src/links/retryLink.ts", "../../node_modules/node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/usingCtx.js", "../../node_modules/node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/OverloadYield.js", "../../node_modules/node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/awaitAsyncGenerator.js", "../../node_modules/node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/wrapAsyncGenerator.js", "../../node_modules/@trpc/client/src/links/localLink.ts", "../../node_modules/@trpc/react-query/src/shared/proxy/decorationProxy.ts", "../../node_modules/@trpc/react-query/src/internals/context.tsx", "../../node_modules/@trpc/react-query/src/shared/proxy/utilsProxy.ts", "../../node_modules/@trpc/react-query/src/shared/proxy/useQueriesProxy.ts", "../../node_modules/@trpc/react-query/src/internals/getClientArgs.ts", "../../node_modules/node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/asyncIterator.js", "../../node_modules/@trpc/react-query/src/internals/trpcResult.ts", "../../node_modules/@trpc/react-query/src/utils/createUtilityFunctions.ts", "../../node_modules/@trpc/react-query/src/shared/hooks/createHooksInternal.tsx", "../../node_modules/@trpc/react-query/src/shared/queryClient.ts", "../../node_modules/@trpc/react-query/src/createTRPCReact.tsx", "../../node_modules/@trpc/react-query/src/createTRPCQueryUtils.tsx", "../../frontend/src/lib/demo-mode.ts", "../../frontend/src/lib/trpc.ts"],
  "sourcesContent": ["export class Subscribable<TListener extends Function> {\n  protected listeners = new Set<TListener>()\n\n  constructor() {\n    this.subscribe = this.subscribe.bind(this)\n  }\n\n  subscribe(listener: TListener): () => void {\n    this.listeners.add(listener)\n\n    this.onSubscribe()\n\n    return () => {\n      this.listeners.delete(listener)\n      this.onUnsubscribe()\n    }\n  }\n\n  hasListeners(): boolean {\n    return this.listeners.size > 0\n  }\n\n  protected onSubscribe(): void {\n    // Do nothing\n  }\n\n  protected onUnsubscribe(): void {\n    // Do nothing\n  }\n}\n", "import type {\n  DefaultError,\n  Enabled,\n  FetchStatus,\n  MutationKey,\n  MutationStatus,\n  QueryFunction,\n  QueryKey,\n  QueryOptions,\n  StaleTime,\n  StaleTimeFunction,\n} from './types'\nimport type { Mutation } from './mutation'\nimport type { FetchOptions, Query } from './query'\n\n// TYPES\n\nexport interface QueryFilters<TQueryKey extends QueryKey = QueryKey> {\n  /**\n   * Filter to active queries, inactive queries or all queries\n   */\n  type?: QueryTypeFilter\n  /**\n   * Match query key exactly\n   */\n  exact?: boolean\n  /**\n   * Include queries matching this predicate function\n   */\n  predicate?: (query: Query) => boolean\n  /**\n   * Include queries matching this query key\n   */\n  queryKey?: TQueryKey\n  /**\n   * Include or exclude stale queries\n   */\n  stale?: boolean\n  /**\n   * Include queries matching their fetchStatus\n   */\n  fetchStatus?: FetchStatus\n}\n\nexport interface MutationFilters<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = unknown,\n  TContext = unknown,\n> {\n  /**\n   * Match mutation key exactly\n   */\n  exact?: boolean\n  /**\n   * Include mutations matching this predicate function\n   */\n  predicate?: (\n    mutation: Mutation<TData, TError, TVariables, TContext>,\n  ) => boolean\n  /**\n   * Include mutations matching this mutation key\n   */\n  mutationKey?: MutationKey\n  /**\n   * Filter by mutation status\n   */\n  status?: MutationStatus\n}\n\nexport type Updater<TInput, TOutput> = TOutput | ((input: TInput) => TOutput)\n\nexport type QueryTypeFilter = 'all' | 'active' | 'inactive'\n\n// UTILS\n\nexport const isServer = typeof window === 'undefined' || 'Deno' in globalThis\n\nexport function noop(): void\nexport function noop(): undefined\nexport function noop() {}\n\nexport function functionalUpdate<TInput, TOutput>(\n  updater: Updater<TInput, TOutput>,\n  input: TInput,\n): TOutput {\n  return typeof updater === 'function'\n    ? (updater as (_: TInput) => TOutput)(input)\n    : updater\n}\n\nexport function isValidTimeout(value: unknown): value is number {\n  return typeof value === 'number' && value >= 0 && value !== Infinity\n}\n\nexport function timeUntilStale(updatedAt: number, staleTime?: number): number {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0)\n}\n\nexport function resolveStaleTime<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  staleTime:\n    | undefined\n    | StaleTimeFunction<TQueryFnData, TError, TData, TQueryKey>,\n  query: Query<TQueryFnData, TError, TData, TQueryKey>,\n): StaleTime | undefined {\n  return typeof staleTime === 'function' ? staleTime(query) : staleTime\n}\n\nexport function resolveEnabled<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  enabled: undefined | Enabled<TQueryFnData, TError, TData, TQueryKey>,\n  query: Query<TQueryFnData, TError, TData, TQueryKey>,\n): boolean | undefined {\n  return typeof enabled === 'function' ? enabled(query) : enabled\n}\n\nexport function matchQuery(\n  filters: QueryFilters,\n  query: Query<any, any, any, any>,\n): boolean {\n  const {\n    type = 'all',\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale,\n  } = filters\n\n  if (queryKey) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false\n    }\n  }\n\n  if (type !== 'all') {\n    const isActive = query.isActive()\n    if (type === 'active' && !isActive) {\n      return false\n    }\n    if (type === 'inactive' && isActive) {\n      return false\n    }\n  }\n\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false\n  }\n\n  if (fetchStatus && fetchStatus !== query.state.fetchStatus) {\n    return false\n  }\n\n  if (predicate && !predicate(query)) {\n    return false\n  }\n\n  return true\n}\n\nexport function matchMutation(\n  filters: MutationFilters,\n  mutation: Mutation<any, any>,\n): boolean {\n  const { exact, status, predicate, mutationKey } = filters\n  if (mutationKey) {\n    if (!mutation.options.mutationKey) {\n      return false\n    }\n    if (exact) {\n      if (hashKey(mutation.options.mutationKey) !== hashKey(mutationKey)) {\n        return false\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false\n    }\n  }\n\n  if (status && mutation.state.status !== status) {\n    return false\n  }\n\n  if (predicate && !predicate(mutation)) {\n    return false\n  }\n\n  return true\n}\n\nexport function hashQueryKeyByOptions<TQueryKey extends QueryKey = QueryKey>(\n  queryKey: TQueryKey,\n  options?: Pick<QueryOptions<any, any, any, any>, 'queryKeyHashFn'>,\n): string {\n  const hashFn = options?.queryKeyHashFn || hashKey\n  return hashFn(queryKey)\n}\n\n/**\n * Default query & mutation keys hash function.\n * Hashes the value into a stable hash.\n */\nexport function hashKey(queryKey: QueryKey | MutationKey): string {\n  return JSON.stringify(queryKey, (_, val) =>\n    isPlainObject(val)\n      ? Object.keys(val)\n          .sort()\n          .reduce((result, key) => {\n            result[key] = val[key]\n            return result\n          }, {} as any)\n      : val,\n  )\n}\n\n/**\n * Checks if key `b` partially matches with key `a`.\n */\nexport function partialMatchKey(a: QueryKey, b: QueryKey): boolean\nexport function partialMatchKey(a: any, b: any): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return Object.keys(b).every((key) => partialMatchKey(a[key], b[key]))\n  }\n\n  return false\n}\n\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\nexport function replaceEqualDeep<T>(a: unknown, b: T): T\nexport function replaceEqualDeep(a: any, b: any): any {\n  if (a === b) {\n    return a\n  }\n\n  const array = isPlainArray(a) && isPlainArray(b)\n\n  if (array || (isPlainObject(a) && isPlainObject(b))) {\n    const aItems = array ? a : Object.keys(a)\n    const aSize = aItems.length\n    const bItems = array ? b : Object.keys(b)\n    const bSize = bItems.length\n    const copy: any = array ? [] : {}\n    const aItemsSet = new Set(aItems)\n\n    let equalItems = 0\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i]\n      if (\n        ((!array && aItemsSet.has(key)) || array) &&\n        a[key] === undefined &&\n        b[key] === undefined\n      ) {\n        copy[key] = undefined\n        equalItems++\n      } else {\n        copy[key] = replaceEqualDeep(a[key], b[key])\n        if (copy[key] === a[key] && a[key] !== undefined) {\n          equalItems++\n        }\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy\n  }\n\n  return b\n}\n\n/**\n * Shallow compare objects.\n */\nexport function shallowEqualObjects<T extends Record<string, any>>(\n  a: T,\n  b: T | undefined,\n): boolean {\n  if (!b || Object.keys(a).length !== Object.keys(b).length) {\n    return false\n  }\n\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nexport function isPlainArray(value: unknown) {\n  return Array.isArray(value) && value.length === Object.keys(value).length\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\n// eslint-disable-next-line @typescript-eslint/no-wrapper-object-types\nexport function isPlainObject(o: any): o is Object {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has no constructor\n  const ctor = o.constructor\n  if (ctor === undefined) {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Handles Objects created by Object.create(<arbitrary prototype>)\n  if (Object.getPrototypeOf(o) !== Object.prototype) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any): boolean {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\nexport function sleep(timeout: number): Promise<void> {\n  return new Promise((resolve) => {\n    setTimeout(resolve, timeout)\n  })\n}\n\nexport function replaceData<\n  TData,\n  TOptions extends QueryOptions<any, any, any, any>,\n>(prevData: TData | undefined, data: TData, options: TOptions): TData {\n  if (typeof options.structuralSharing === 'function') {\n    return options.structuralSharing(prevData, data) as TData\n  } else if (options.structuralSharing !== false) {\n    if (process.env.NODE_ENV !== 'production') {\n      try {\n        return replaceEqualDeep(prevData, data)\n      } catch (error) {\n        console.error(\n          `Structural sharing requires data to be JSON serializable. To fix this, turn off structuralSharing or return JSON-serializable data from your queryFn. [${options.queryHash}]: ${error}`,\n        )\n\n        // Prevent the replaceEqualDeep from being called again down below.\n        throw error\n      }\n    }\n    // Structurally share data between prev and new data if needed\n    return replaceEqualDeep(prevData, data)\n  }\n  return data\n}\n\nexport function keepPreviousData<T>(\n  previousData: T | undefined,\n): T | undefined {\n  return previousData\n}\n\nexport function addToEnd<T>(items: Array<T>, item: T, max = 0): Array<T> {\n  const newItems = [...items, item]\n  return max && newItems.length > max ? newItems.slice(1) : newItems\n}\n\nexport function addToStart<T>(items: Array<T>, item: T, max = 0): Array<T> {\n  const newItems = [item, ...items]\n  return max && newItems.length > max ? newItems.slice(0, -1) : newItems\n}\n\nexport const skipToken = Symbol()\nexport type SkipToken = typeof skipToken\n\nexport function ensureQueryFn<\n  TQueryFnData = unknown,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: {\n    queryFn?: QueryFunction<TQueryFnData, TQueryKey> | SkipToken\n    queryHash?: string\n  },\n  fetchOptions?: FetchOptions<TQueryFnData>,\n): QueryFunction<TQueryFnData, TQueryKey> {\n  if (process.env.NODE_ENV !== 'production') {\n    if (options.queryFn === skipToken) {\n      console.error(\n        `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${options.queryHash}'`,\n      )\n    }\n  }\n\n  // if we attempt to retry a fetch that was triggered from an initialPromise\n  // when we don't have a queryFn yet, we can't retry, so we just return the already rejected initialPromise\n  // if an observer has already mounted, we will be able to retry with that queryFn\n  if (!options.queryFn && fetchOptions?.initialPromise) {\n    return () => fetchOptions.initialPromise!\n  }\n\n  if (!options.queryFn || options.queryFn === skipToken) {\n    return () =>\n      Promise.reject(new Error(`Missing queryFn: '${options.queryHash}'`))\n  }\n\n  return options.queryFn\n}\n\nexport function shouldThrowError<T extends (...args: Array<any>) => boolean>(\n  throwOnError: boolean | T | undefined,\n  params: Parameters<T>,\n): boolean {\n  // Allow throwOnError function to override throwing behavior on a per-error basis\n  if (typeof throwOnError === 'function') {\n    return throwOnError(...params)\n  }\n\n  return !!throwOnError\n}\n", "import { Subscribable } from './subscribable'\nimport { isServer } from './utils'\n\ntype Listener = (focused: boolean) => void\n\ntype SetupFn = (\n  setFocused: (focused?: boolean) => void,\n) => (() => void) | undefined\n\nexport class FocusManager extends Subscribable<Listener> {\n  #focused?: boolean\n  #cleanup?: () => void\n\n  #setup: SetupFn\n\n  constructor() {\n    super()\n    this.#setup = (onFocus) => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onFocus()\n        // Listen to visibilitychange\n        window.addEventListener('visibilitychange', listener, false)\n\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('visibilitychange', listener)\n        }\n      }\n      return\n    }\n  }\n\n  protected onSubscribe(): void {\n    if (!this.#cleanup) {\n      this.setEventListener(this.#setup)\n    }\n  }\n\n  protected onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.#cleanup?.()\n      this.#cleanup = undefined\n    }\n  }\n\n  setEventListener(setup: SetupFn): void {\n    this.#setup = setup\n    this.#cleanup?.()\n    this.#cleanup = setup((focused) => {\n      if (typeof focused === 'boolean') {\n        this.setFocused(focused)\n      } else {\n        this.onFocus()\n      }\n    })\n  }\n\n  setFocused(focused?: boolean): void {\n    const changed = this.#focused !== focused\n    if (changed) {\n      this.#focused = focused\n      this.onFocus()\n    }\n  }\n\n  onFocus(): void {\n    const isFocused = this.isFocused()\n    this.listeners.forEach((listener) => {\n      listener(isFocused)\n    })\n  }\n\n  isFocused(): boolean {\n    if (typeof this.#focused === 'boolean') {\n      return this.#focused\n    }\n\n    // document global can be unavailable in react native\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    return globalThis.document?.visibilityState !== 'hidden'\n  }\n}\n\nexport const focusManager = new FocusManager()\n", "import { Subscribable } from './subscribable'\nimport { isServer } from './utils'\n\ntype Listener = (online: boolean) => void\ntype SetupFn = (setOnline: Listener) => (() => void) | undefined\n\nexport class OnlineManager extends Subscribable<Listener> {\n  #online = true\n  #cleanup?: () => void\n\n  #setup: SetupFn\n\n  constructor() {\n    super()\n    this.#setup = (onOnline) => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const onlineListener = () => onOnline(true)\n        const offlineListener = () => onOnline(false)\n        // Listen to online\n        window.addEventListener('online', onlineListener, false)\n        window.addEventListener('offline', offlineListener, false)\n\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('online', onlineListener)\n          window.removeEventListener('offline', offlineListener)\n        }\n      }\n\n      return\n    }\n  }\n\n  protected onSubscribe(): void {\n    if (!this.#cleanup) {\n      this.setEventListener(this.#setup)\n    }\n  }\n\n  protected onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.#cleanup?.()\n      this.#cleanup = undefined\n    }\n  }\n\n  setEventListener(setup: SetupFn): void {\n    this.#setup = setup\n    this.#cleanup?.()\n    this.#cleanup = setup(this.setOnline.bind(this))\n  }\n\n  setOnline(online: boolean): void {\n    const changed = this.#online !== online\n\n    if (changed) {\n      this.#online = online\n      this.listeners.forEach((listener) => {\n        listener(online)\n      })\n    }\n  }\n\n  isOnline(): boolean {\n    return this.#online\n  }\n}\n\nexport const onlineManager = new OnlineManager()\n", "/**\n * Thenable types which matches React's types for promises\n *\n * React seemingly uses `.status`, `.value` and `.reason` properties on a promises to optimistically unwrap data from promises\n *\n * @see https://github.com/facebook/react/blob/main/packages/shared/ReactTypes.js#L112-L138\n * @see https://github.com/facebook/react/blob/4f604941569d2e8947ce1460a0b2997e835f37b9/packages/react-debug-tools/src/ReactDebugHooks.js#L224-L227\n */\n\nimport { noop } from './utils'\n\ninterface Fulfilled<T> {\n  status: 'fulfilled'\n  value: T\n}\ninterface Rejected {\n  status: 'rejected'\n  reason: unknown\n}\ninterface Pending<T> {\n  status: 'pending'\n\n  /**\n   * Resolve the promise with a value.\n   * Will remove the `resolve` and `reject` properties from the promise.\n   */\n  resolve: (value: T) => void\n  /**\n   * Reject the promise with a reason.\n   * Will remove the `resolve` and `reject` properties from the promise.\n   */\n  reject: (reason: unknown) => void\n}\n\nexport type FulfilledThenable<T> = Promise<T> & Fulfilled<T>\nexport type RejectedThenable<T> = Promise<T> & Rejected\nexport type PendingThenable<T> = Promise<T> & Pending<T>\n\nexport type Thenable<T> =\n  | FulfilledThenable<T>\n  | RejectedThenable<T>\n  | PendingThenable<T>\n\nexport function pendingThenable<T>(): PendingThenable<T> {\n  let resolve: Pending<T>['resolve']\n  let reject: Pending<T>['reject']\n  // this could use `Promise.withResolvers()` in the future\n  const thenable = new Promise((_resolve, _reject) => {\n    resolve = _resolve\n    reject = _reject\n  }) as PendingThenable<T>\n\n  thenable.status = 'pending'\n  thenable.catch(() => {\n    // prevent unhandled rejection errors\n  })\n\n  function finalize(data: Fulfilled<T> | Rejected) {\n    Object.assign(thenable, data)\n\n    // clear pending props props to avoid calling them twice\n    delete (thenable as Partial<PendingThenable<T>>).resolve\n    delete (thenable as Partial<PendingThenable<T>>).reject\n  }\n\n  thenable.resolve = (value) => {\n    finalize({\n      status: 'fulfilled',\n      value,\n    })\n\n    resolve(value)\n  }\n  thenable.reject = (reason) => {\n    finalize({\n      status: 'rejected',\n      reason,\n    })\n\n    reject(reason)\n  }\n\n  return thenable\n}\n\n/**\n * This function takes a Promise-like input and detects whether the data\n * is synchronously available or not.\n *\n * It does not inspect .status, .value or .reason properties of the promise,\n * as those are not always available, and the .status of React's promises\n * should not be considered part of the public API.\n */\nexport function tryResolveSync(promise: Promise<unknown> | Thenable<unknown>) {\n  let data: unknown\n\n  promise\n    .then((result) => {\n      data = result\n      return result\n    }, noop)\n    // .catch can be unavailable on certain kinds of thenable's\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    ?.catch(noop)\n\n  if (data !== undefined) {\n    return { data }\n  }\n\n  return undefined\n}\n", "import { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { pendingThenable } from './thenable'\nimport { isServer, sleep } from './utils'\nimport type { CancelOptions, DefaultError, NetworkMode } from './types'\n\n// TYPES\n\ninterface RetryerConfig<TData = unknown, TError = DefaultError> {\n  fn: () => TData | Promise<TData>\n  initialPromise?: Promise<TData>\n  abort?: () => void\n  onError?: (error: TError) => void\n  onSuccess?: (data: TData) => void\n  onFail?: (failureCount: number, error: TError) => void\n  onPause?: () => void\n  onContinue?: () => void\n  retry?: RetryValue<TError>\n  retryDelay?: RetryDelayValue<TError>\n  networkMode: NetworkMode | undefined\n  canRun: () => boolean\n}\n\nexport interface Retryer<TData = unknown> {\n  promise: Promise<TData>\n  cancel: (cancelOptions?: CancelOptions) => void\n  continue: () => Promise<unknown>\n  cancelRetry: () => void\n  continueRetry: () => void\n  canStart: () => boolean\n  start: () => Promise<TData>\n}\n\nexport type RetryValue<TError> = boolean | number | ShouldRetryFunction<TError>\n\ntype ShouldRetryFunction<TError = DefaultError> = (\n  failureCount: number,\n  error: TError,\n) => boolean\n\nexport type RetryDelayValue<TError> = number | RetryDelayFunction<TError>\n\ntype RetryDelayFunction<TError = DefaultError> = (\n  failureCount: number,\n  error: TError,\n) => number\n\nfunction defaultRetryDelay(failureCount: number) {\n  return Math.min(1000 * 2 ** failureCount, 30000)\n}\n\nexport function canFetch(networkMode: NetworkMode | undefined): boolean {\n  return (networkMode ?? 'online') === 'online'\n    ? onlineManager.isOnline()\n    : true\n}\n\nexport class CancelledError extends Error {\n  revert?: boolean\n  silent?: boolean\n  constructor(options?: CancelOptions) {\n    super('CancelledError')\n    this.revert = options?.revert\n    this.silent = options?.silent\n  }\n}\n\nexport function isCancelledError(value: any): value is CancelledError {\n  return value instanceof CancelledError\n}\n\nexport function createRetryer<TData = unknown, TError = DefaultError>(\n  config: RetryerConfig<TData, TError>,\n): Retryer<TData> {\n  let isRetryCancelled = false\n  let failureCount = 0\n  let isResolved = false\n  let continueFn: ((value?: unknown) => void) | undefined\n\n  const thenable = pendingThenable<TData>()\n\n  const cancel = (cancelOptions?: CancelOptions): void => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions))\n\n      config.abort?.()\n    }\n  }\n  const cancelRetry = () => {\n    isRetryCancelled = true\n  }\n\n  const continueRetry = () => {\n    isRetryCancelled = false\n  }\n\n  const canContinue = () =>\n    focusManager.isFocused() &&\n    (config.networkMode === 'always' || onlineManager.isOnline()) &&\n    config.canRun()\n\n  const canStart = () => canFetch(config.networkMode) && config.canRun()\n\n  const resolve = (value: any) => {\n    if (!isResolved) {\n      isResolved = true\n      config.onSuccess?.(value)\n      continueFn?.()\n      thenable.resolve(value)\n    }\n  }\n\n  const reject = (value: any) => {\n    if (!isResolved) {\n      isResolved = true\n      config.onError?.(value)\n      continueFn?.()\n      thenable.reject(value)\n    }\n  }\n\n  const pause = () => {\n    return new Promise((continueResolve) => {\n      continueFn = (value) => {\n        if (isResolved || canContinue()) {\n          continueResolve(value)\n        }\n      }\n      config.onPause?.()\n    }).then(() => {\n      continueFn = undefined\n      if (!isResolved) {\n        config.onContinue?.()\n      }\n    })\n  }\n\n  // Create loop function\n  const run = () => {\n    // Do nothing if already resolved\n    if (isResolved) {\n      return\n    }\n\n    let promiseOrValue: any\n\n    // we can re-use config.initialPromise on the first call of run()\n    const initialPromise =\n      failureCount === 0 ? config.initialPromise : undefined\n\n    // Execute query\n    try {\n      promiseOrValue = initialPromise ?? config.fn()\n    } catch (error) {\n      promiseOrValue = Promise.reject(error)\n    }\n\n    Promise.resolve(promiseOrValue)\n      .then(resolve)\n      .catch((error) => {\n        // Stop if the fetch is already resolved\n        if (isResolved) {\n          return\n        }\n\n        // Do we need to retry the request?\n        const retry = config.retry ?? (isServer ? 0 : 3)\n        const retryDelay = config.retryDelay ?? defaultRetryDelay\n        const delay =\n          typeof retryDelay === 'function'\n            ? retryDelay(failureCount, error)\n            : retryDelay\n        const shouldRetry =\n          retry === true ||\n          (typeof retry === 'number' && failureCount < retry) ||\n          (typeof retry === 'function' && retry(failureCount, error))\n\n        if (isRetryCancelled || !shouldRetry) {\n          // We are done if the query does not need to be retried\n          reject(error)\n          return\n        }\n\n        failureCount++\n\n        // Notify on fail\n        config.onFail?.(failureCount, error)\n\n        // Delay\n        sleep(delay)\n          // Pause if the document is not visible or when the device is offline\n          .then(() => {\n            return canContinue() ? undefined : pause()\n          })\n          .then(() => {\n            if (isRetryCancelled) {\n              reject(error)\n            } else {\n              run()\n            }\n          })\n      })\n  }\n\n  return {\n    promise: thenable,\n    cancel,\n    continue: () => {\n      continueFn?.()\n      return thenable\n    },\n    cancelRetry,\n    continueRetry,\n    canStart,\n    start: () => {\n      // Start loop\n      if (canStart()) {\n        run()\n      } else {\n        pause().then(run)\n      }\n      return thenable\n    },\n  }\n}\n", "// TYPES\n\ntype NotifyCallback = () => void\n\ntype NotifyFunction = (callback: () => void) => void\n\ntype BatchNotifyFunction = (callback: () => void) => void\n\ntype BatchCallsCallback<T extends Array<unknown>> = (...args: T) => void\n\ntype ScheduleFunction = (callback: () => void) => void\n\nexport const defaultScheduler: ScheduleFunction = (cb) => setTimeout(cb, 0)\n\nexport function createNotifyManager() {\n  let queue: Array<NotifyCallback> = []\n  let transactions = 0\n  let notifyFn: NotifyFunction = (callback) => {\n    callback()\n  }\n  let batchNotifyFn: BatchNotifyFunction = (callback: () => void) => {\n    callback()\n  }\n  let scheduleFn = defaultScheduler\n\n  const schedule = (callback: NotifyCallback): void => {\n    if (transactions) {\n      queue.push(callback)\n    } else {\n      scheduleFn(() => {\n        notifyFn(callback)\n      })\n    }\n  }\n  const flush = (): void => {\n    const originalQueue = queue\n    queue = []\n    if (originalQueue.length) {\n      scheduleFn(() => {\n        batchNotifyFn(() => {\n          originalQueue.forEach((callback) => {\n            notifyFn(callback)\n          })\n        })\n      })\n    }\n  }\n\n  return {\n    batch: <T>(callback: () => T): T => {\n      let result\n      transactions++\n      try {\n        result = callback()\n      } finally {\n        transactions--\n        if (!transactions) {\n          flush()\n        }\n      }\n      return result\n    },\n    /**\n     * All calls to the wrapped function will be batched.\n     */\n    batchCalls: <T extends Array<unknown>>(\n      callback: BatchCallsCallback<T>,\n    ): BatchCallsCallback<T> => {\n      return (...args) => {\n        schedule(() => {\n          callback(...args)\n        })\n      }\n    },\n    schedule,\n    /**\n     * Use this method to set a custom notify function.\n     * This can be used to for example wrap notifications with `React.act` while running tests.\n     */\n    setNotifyFunction: (fn: NotifyFunction) => {\n      notifyFn = fn\n    },\n    /**\n     * Use this method to set a custom function to batch notifications together into a single tick.\n     * By default React Query will use the batch function provided by ReactDOM or React Native.\n     */\n    setBatchNotifyFunction: (fn: BatchNotifyFunction) => {\n      batchNotifyFn = fn\n    },\n    setScheduler: (fn: ScheduleFunction) => {\n      scheduleFn = fn\n    },\n  } as const\n}\n\n// SINGLETON\nexport const notifyManager = createNotifyManager()\n", "import { isServer, isValidTimeout } from './utils'\n\nexport abstract class Removable {\n  gcTime!: number\n  #gcTimeout?: ReturnType<typeof setTimeout>\n\n  destroy(): void {\n    this.clearGcTimeout()\n  }\n\n  protected scheduleGc(): void {\n    this.clearGcTimeout()\n\n    if (isValidTimeout(this.gcTime)) {\n      this.#gcTimeout = setTimeout(() => {\n        this.optionalRemove()\n      }, this.gcTime)\n    }\n  }\n\n  protected updateGcTime(newGcTime: number | undefined): void {\n    // Default to 5 minutes (Infinity for server-side) if no gcTime is set\n    this.gcTime = Math.max(\n      this.gcTime || 0,\n      newGcTime ?? (isServer ? Infinity : 5 * 60 * 1000),\n    )\n  }\n\n  protected clearGcTimeout() {\n    if (this.#gcTimeout) {\n      clearTimeout(this.#gcTimeout)\n      this.#gcTimeout = undefined\n    }\n  }\n\n  protected abstract optionalRemove(): void\n}\n", "import {\n  ensureQueryFn,\n  noop,\n  replaceData,\n  resolveEnabled,\n  resolveStaleTime,\n  skipToken,\n  timeUntilStale,\n} from './utils'\nimport { notifyManager } from './notifyManager'\nimport { canFetch, createRetryer, isCancelledError } from './retryer'\nimport { Removable } from './removable'\nimport type { QueryCache } from './queryCache'\nimport type { QueryClient } from './queryClient'\nimport type {\n  CancelOptions,\n  DefaultError,\n  FetchStatus,\n  InitialDataFunction,\n  OmitKeyof,\n  QueryFunctionContext,\n  QueryKey,\n  QueryMeta,\n  QueryOptions,\n  QueryStatus,\n  SetDataOptions,\n  StaleTime,\n} from './types'\nimport type { QueryObserver } from './queryObserver'\nimport type { Retryer } from './retryer'\n\n// TYPES\n\ninterface QueryConfig<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  client: QueryClient\n  queryKey: TQueryKey\n  queryHash: string\n  options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state?: QueryState<TData, TError>\n}\n\nexport interface QueryState<TData = unknown, TError = DefaultError> {\n  data: TData | undefined\n  dataUpdateCount: number\n  dataUpdatedAt: number\n  error: TError | null\n  errorUpdateCount: number\n  errorUpdatedAt: number\n  fetchFailureCount: number\n  fetchFailureReason: TError | null\n  fetchMeta: FetchMeta | null\n  isInvalidated: boolean\n  status: QueryStatus\n  fetchStatus: FetchStatus\n}\n\nexport interface FetchContext<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  fetchFn: () => unknown | Promise<unknown>\n  fetchOptions?: FetchOptions\n  signal: AbortSignal\n  options: QueryOptions<TQueryFnData, TError, TData, any>\n  client: QueryClient\n  queryKey: TQueryKey\n  state: QueryState<TData, TError>\n}\n\nexport interface QueryBehavior<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  onFetch: (\n    context: FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n    query: Query,\n  ) => void\n}\n\nexport type FetchDirection = 'forward' | 'backward'\n\nexport interface FetchMeta {\n  fetchMore?: { direction: FetchDirection }\n}\n\nexport interface FetchOptions<TData = unknown> {\n  cancelRefetch?: boolean\n  meta?: FetchMeta\n  initialPromise?: Promise<TData>\n}\n\ninterface FailedAction<TError> {\n  type: 'failed'\n  failureCount: number\n  error: TError\n}\n\ninterface FetchAction {\n  type: 'fetch'\n  meta?: FetchMeta\n}\n\ninterface SuccessAction<TData> {\n  data: TData | undefined\n  type: 'success'\n  dataUpdatedAt?: number\n  manual?: boolean\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface InvalidateAction {\n  type: 'invalidate'\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\ninterface SetStateAction<TData, TError> {\n  type: 'setState'\n  state: Partial<QueryState<TData, TError>>\n  setStateOptions?: SetStateOptions\n}\n\nexport type Action<TData, TError> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction<TError>\n  | FetchAction\n  | InvalidateAction\n  | PauseAction\n  | SetStateAction<TData, TError>\n  | SuccessAction<TData>\n\nexport interface SetStateOptions {\n  meta?: any\n}\n\n// CLASS\n\nexport class Query<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Removable {\n  queryKey: TQueryKey\n  queryHash: string\n  options!: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state: QueryState<TData, TError>\n\n  #initialState: QueryState<TData, TError>\n  #revertState?: QueryState<TData, TError>\n  #cache: QueryCache\n  #client: QueryClient\n  #retryer?: Retryer<TData>\n  observers: Array<QueryObserver<any, any, any, any, any>>\n  #defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  #abortSignalConsumed: boolean\n\n  constructor(config: QueryConfig<TQueryFnData, TError, TData, TQueryKey>) {\n    super()\n\n    this.#abortSignalConsumed = false\n    this.#defaultOptions = config.defaultOptions\n    this.setOptions(config.options)\n    this.observers = []\n    this.#client = config.client\n    this.#cache = this.#client.getQueryCache()\n    this.queryKey = config.queryKey\n    this.queryHash = config.queryHash\n    this.#initialState = getDefaultState(this.options)\n    this.state = config.state ?? this.#initialState\n    this.scheduleGc()\n  }\n  get meta(): QueryMeta | undefined {\n    return this.options.meta\n  }\n\n  get promise(): Promise<TData> | undefined {\n    return this.#retryer?.promise\n  }\n\n  setOptions(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): void {\n    this.options = { ...this.#defaultOptions, ...options }\n\n    this.updateGcTime(this.options.gcTime)\n  }\n\n  protected optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === 'idle') {\n      this.#cache.remove(this)\n    }\n  }\n\n  setData(\n    newData: TData,\n    options?: SetDataOptions & { manual: boolean },\n  ): TData {\n    const data = replaceData(this.state.data, newData, this.options)\n\n    // Set data and mark it as cached\n    this.#dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options?.updatedAt,\n      manual: options?.manual,\n    })\n\n    return data\n  }\n\n  setState(\n    state: Partial<QueryState<TData, TError>>,\n    setStateOptions?: SetStateOptions,\n  ): void {\n    this.#dispatch({ type: 'setState', state, setStateOptions })\n  }\n\n  cancel(options?: CancelOptions): Promise<void> {\n    const promise = this.#retryer?.promise\n    this.#retryer?.cancel(options)\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve()\n  }\n\n  destroy(): void {\n    super.destroy()\n\n    this.cancel({ silent: true })\n  }\n\n  reset(): void {\n    this.destroy()\n    this.setState(this.#initialState)\n  }\n\n  isActive(): boolean {\n    return this.observers.some(\n      (observer) => resolveEnabled(observer.options.enabled, this) !== false,\n    )\n  }\n\n  isDisabled(): boolean {\n    if (this.getObserversCount() > 0) {\n      return !this.isActive()\n    }\n    // if a query has no observers, it should still be considered disabled if it never attempted a fetch\n    return (\n      this.options.queryFn === skipToken ||\n      this.state.dataUpdateCount + this.state.errorUpdateCount === 0\n    )\n  }\n\n  isStatic(): boolean {\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(\n        (observer) =>\n          resolveStaleTime(observer.options.staleTime, this) === 'static',\n      )\n    }\n\n    return false\n  }\n\n  isStale(): boolean {\n    // check observers first, their `isStale` has the source of truth\n    // calculated with `isStaleByTime` and it takes `enabled` into account\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(\n        (observer) => observer.getCurrentResult().isStale,\n      )\n    }\n\n    return this.state.data === undefined || this.state.isInvalidated\n  }\n\n  isStaleByTime(staleTime: StaleTime = 0): boolean {\n    // no data is always stale\n    if (this.state.data === undefined) {\n      return true\n    }\n    // static is never stale\n    if (staleTime === 'static') {\n      return false\n    }\n    // if the query is invalidated, it is stale\n    if (this.state.isInvalidated) {\n      return true\n    }\n\n    return !timeUntilStale(this.state.dataUpdatedAt, staleTime)\n  }\n\n  onFocus(): void {\n    const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus())\n\n    observer?.refetch({ cancelRefetch: false })\n\n    // Continue fetch if currently paused\n    this.#retryer?.continue()\n  }\n\n  onOnline(): void {\n    const observer = this.observers.find((x) => x.shouldFetchOnReconnect())\n\n    observer?.refetch({ cancelRefetch: false })\n\n    // Continue fetch if currently paused\n    this.#retryer?.continue()\n  }\n\n  addObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer)\n\n      // Stop the query from being garbage collected\n      this.clearGcTimeout()\n\n      this.#cache.notify({ type: 'observerAdded', query: this, observer })\n    }\n  }\n\n  removeObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (this.observers.includes(observer)) {\n      this.observers = this.observers.filter((x) => x !== observer)\n\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.#retryer) {\n          if (this.#abortSignalConsumed) {\n            this.#retryer.cancel({ revert: true })\n          } else {\n            this.#retryer.cancelRetry()\n          }\n        }\n\n        this.scheduleGc()\n      }\n\n      this.#cache.notify({ type: 'observerRemoved', query: this, observer })\n    }\n  }\n\n  getObserversCount(): number {\n    return this.observers.length\n  }\n\n  invalidate(): void {\n    if (!this.state.isInvalidated) {\n      this.#dispatch({ type: 'invalidate' })\n    }\n  }\n\n  fetch(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    fetchOptions?: FetchOptions<TQueryFnData>,\n  ): Promise<TData> {\n    if (this.state.fetchStatus !== 'idle') {\n      if (this.state.data !== undefined && fetchOptions?.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetch\n        this.cancel({ silent: true })\n      } else if (this.#retryer) {\n        // make sure that retries that were potentially cancelled due to unmounts can continue\n        this.#retryer.continueRetry()\n        // Return current promise if we are already fetching\n        return this.#retryer.promise\n      }\n    }\n\n    // Update config if passed, otherwise the config from the last execution is used\n    if (options) {\n      this.setOptions(options)\n    }\n\n    // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n    if (!this.options.queryFn) {\n      const observer = this.observers.find((x) => x.options.queryFn)\n      if (observer) {\n        this.setOptions(observer.options)\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!Array.isArray(this.options.queryKey)) {\n        console.error(\n          `As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`,\n        )\n      }\n    }\n\n    const abortController = new AbortController()\n\n    // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n    const addSignalProperty = (object: unknown) => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          this.#abortSignalConsumed = true\n          return abortController.signal\n        },\n      })\n    }\n\n    // Create fetch function\n    const fetchFn = () => {\n      const queryFn = ensureQueryFn(this.options, fetchOptions)\n\n      // Create query function context\n      const createQueryFnContext = (): QueryFunctionContext<TQueryKey> => {\n        const queryFnContext: OmitKeyof<\n          QueryFunctionContext<TQueryKey>,\n          'signal'\n        > = {\n          client: this.#client,\n          queryKey: this.queryKey,\n          meta: this.meta,\n        }\n        addSignalProperty(queryFnContext)\n        return queryFnContext as QueryFunctionContext<TQueryKey>\n      }\n\n      const queryFnContext = createQueryFnContext()\n\n      this.#abortSignalConsumed = false\n      if (this.options.persister) {\n        return this.options.persister(\n          queryFn,\n          queryFnContext,\n          this as unknown as Query,\n        )\n      }\n\n      return queryFn(queryFnContext)\n    }\n\n    // Trigger behavior hook\n    const createFetchContext = (): FetchContext<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey\n    > => {\n      const context: OmitKeyof<\n        FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n        'signal'\n      > = {\n        fetchOptions,\n        options: this.options,\n        queryKey: this.queryKey,\n        client: this.#client,\n        state: this.state,\n        fetchFn,\n      }\n\n      addSignalProperty(context)\n      return context as FetchContext<TQueryFnData, TError, TData, TQueryKey>\n    }\n\n    const context = createFetchContext()\n\n    this.options.behavior?.onFetch(context, this as unknown as Query)\n\n    // Store state in case the current fetch needs to be reverted\n    this.#revertState = this.state\n\n    // Set to fetching state if not already in it\n    if (\n      this.state.fetchStatus === 'idle' ||\n      this.state.fetchMeta !== context.fetchOptions?.meta\n    ) {\n      this.#dispatch({ type: 'fetch', meta: context.fetchOptions?.meta })\n    }\n\n    const onError = (error: TError | { silent?: boolean }) => {\n      // Optimistically update state if needed\n      if (!(isCancelledError(error) && error.silent)) {\n        this.#dispatch({\n          type: 'error',\n          error: error as TError,\n        })\n      }\n\n      if (!isCancelledError(error)) {\n        // Notify cache callback\n        this.#cache.config.onError?.(\n          error as any,\n          this as Query<any, any, any, any>,\n        )\n        this.#cache.config.onSettled?.(\n          this.state.data,\n          error as any,\n          this as Query<any, any, any, any>,\n        )\n      }\n\n      // Schedule query gc after fetching\n      this.scheduleGc()\n    }\n\n    // Try to fetch the data\n    this.#retryer = createRetryer({\n      initialPromise: fetchOptions?.initialPromise as\n        | Promise<TData>\n        | undefined,\n      fn: context.fetchFn as () => Promise<TData>,\n      abort: abortController.abort.bind(abortController),\n      onSuccess: (data) => {\n        if (data === undefined) {\n          if (process.env.NODE_ENV !== 'production') {\n            console.error(\n              `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`,\n            )\n          }\n          onError(new Error(`${this.queryHash} data is undefined`) as any)\n          return\n        }\n\n        try {\n          this.setData(data)\n        } catch (error) {\n          onError(error as TError)\n          return\n        }\n\n        // Notify cache callback\n        this.#cache.config.onSuccess?.(data, this as Query<any, any, any, any>)\n        this.#cache.config.onSettled?.(\n          data,\n          this.state.error as any,\n          this as Query<any, any, any, any>,\n        )\n\n        // Schedule query gc after fetching\n        this.scheduleGc()\n      },\n      onError,\n      onFail: (failureCount, error) => {\n        this.#dispatch({ type: 'failed', failureCount, error })\n      },\n      onPause: () => {\n        this.#dispatch({ type: 'pause' })\n      },\n      onContinue: () => {\n        this.#dispatch({ type: 'continue' })\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode,\n      canRun: () => true,\n    })\n\n    return this.#retryer.start()\n  }\n\n  #dispatch(action: Action<TData, TError>): void {\n    const reducer = (\n      state: QueryState<TData, TError>,\n    ): QueryState<TData, TError> => {\n      switch (action.type) {\n        case 'failed':\n          return {\n            ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error,\n          }\n        case 'pause':\n          return {\n            ...state,\n            fetchStatus: 'paused',\n          }\n        case 'continue':\n          return {\n            ...state,\n            fetchStatus: 'fetching',\n          }\n        case 'fetch':\n          return {\n            ...state,\n            ...fetchState(state.data, this.options),\n            fetchMeta: action.meta ?? null,\n          }\n        case 'success':\n          // If fetching ends successfully, we don't need revertState as a fallback anymore.\n          this.#revertState = undefined\n          return {\n            ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: 'success',\n            ...(!action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0,\n              fetchFailureReason: null,\n            }),\n          }\n        case 'error':\n          const error = action.error\n\n          if (isCancelledError(error) && error.revert && this.#revertState) {\n            return { ...this.#revertState, fetchStatus: 'idle' }\n          }\n\n          return {\n            ...state,\n            error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error,\n            fetchStatus: 'idle',\n            status: 'error',\n          }\n        case 'invalidate':\n          return {\n            ...state,\n            isInvalidated: true,\n          }\n        case 'setState':\n          return {\n            ...state,\n            ...action.state,\n          }\n      }\n    }\n\n    this.state = reducer(this.state)\n\n    notifyManager.batch(() => {\n      this.observers.forEach((observer) => {\n        observer.onQueryUpdate()\n      })\n\n      this.#cache.notify({ query: this, type: 'updated', action })\n    })\n  }\n}\n\nexport function fetchState<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey,\n>(\n  data: TData | undefined,\n  options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n) {\n  return {\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchStatus: canFetch(options.networkMode) ? 'fetching' : 'paused',\n    ...(data === undefined &&\n      ({\n        error: null,\n        status: 'pending',\n      } as const)),\n  } as const\n}\n\nfunction getDefaultState<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey,\n>(\n  options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): QueryState<TData, TError> {\n  const data =\n    typeof options.initialData === 'function'\n      ? (options.initialData as InitialDataFunction<TData>)()\n      : options.initialData\n\n  const hasData = data !== undefined\n\n  const initialDataUpdatedAt = hasData\n    ? typeof options.initialDataUpdatedAt === 'function'\n      ? (options.initialDataUpdatedAt as () => number | undefined)()\n      : options.initialDataUpdatedAt\n    : 0\n\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? (initialDataUpdatedAt ?? Date.now()) : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'pending',\n    fetchStatus: 'idle',\n  }\n}\n", "import { hashQueryKeyByOptions, matchQuery } from './utils'\nimport { Query } from './query'\nimport { notifyManager } from './notifyManager'\nimport { Subscribable } from './subscribable'\nimport type { QueryFilters } from './utils'\nimport type { Action, QueryState } from './query'\nimport type {\n  DefaultError,\n  NotifyEvent,\n  QueryKey,\n  QueryOptions,\n  WithRequired,\n} from './types'\nimport type { QueryClient } from './queryClient'\nimport type { QueryObserver } from './queryObserver'\n\n// TYPES\n\ninterface QueryCacheConfig {\n  onError?: (\n    error: DefaultError,\n    query: Query<unknown, unknown, unknown>,\n  ) => void\n  onSuccess?: (data: unknown, query: Query<unknown, unknown, unknown>) => void\n  onSettled?: (\n    data: unknown | undefined,\n    error: DefaultError | null,\n    query: Query<unknown, unknown, unknown>,\n  ) => void\n}\n\ninterface NotifyEventQueryAdded extends NotifyEvent {\n  type: 'added'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryRemoved extends NotifyEvent {\n  type: 'removed'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryUpdated extends NotifyEvent {\n  type: 'updated'\n  query: Query<any, any, any, any>\n  action: Action<any, any>\n}\n\ninterface NotifyEventQueryObserverAdded extends NotifyEvent {\n  type: 'observerAdded'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverRemoved extends NotifyEvent {\n  type: 'observerRemoved'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverResultsUpdated extends NotifyEvent {\n  type: 'observerResultsUpdated'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverOptionsUpdated extends NotifyEvent {\n  type: 'observerOptionsUpdated'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\nexport type QueryCacheNotifyEvent =\n  | NotifyEventQueryAdded\n  | NotifyEventQueryRemoved\n  | NotifyEventQueryUpdated\n  | NotifyEventQueryObserverAdded\n  | NotifyEventQueryObserverRemoved\n  | NotifyEventQueryObserverResultsUpdated\n  | NotifyEventQueryObserverOptionsUpdated\n\ntype QueryCacheListener = (event: QueryCacheNotifyEvent) => void\n\nexport interface QueryStore {\n  has: (queryHash: string) => boolean\n  set: (queryHash: string, query: Query) => void\n  get: (queryHash: string) => Query | undefined\n  delete: (queryHash: string) => void\n  values: () => IterableIterator<Query>\n}\n\n// CLASS\n\nexport class QueryCache extends Subscribable<QueryCacheListener> {\n  #queries: QueryStore\n\n  constructor(public config: QueryCacheConfig = {}) {\n    super()\n    this.#queries = new Map<string, Query>()\n  }\n\n  build<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    client: QueryClient,\n    options: WithRequired<\n      QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n      'queryKey'\n    >,\n    state?: QueryState<TData, TError>,\n  ): Query<TQueryFnData, TError, TData, TQueryKey> {\n    const queryKey = options.queryKey\n    const queryHash =\n      options.queryHash ?? hashQueryKeyByOptions(queryKey, options)\n    let query = this.get<TQueryFnData, TError, TData, TQueryKey>(queryHash)\n\n    if (!query) {\n      query = new Query({\n        client,\n        queryKey,\n        queryHash,\n        options: client.defaultQueryOptions(options),\n        state,\n        defaultOptions: client.getQueryDefaults(queryKey),\n      })\n      this.add(query)\n    }\n\n    return query\n  }\n\n  add(query: Query<any, any, any, any>): void {\n    if (!this.#queries.has(query.queryHash)) {\n      this.#queries.set(query.queryHash, query)\n\n      this.notify({\n        type: 'added',\n        query,\n      })\n    }\n  }\n\n  remove(query: Query<any, any, any, any>): void {\n    const queryInMap = this.#queries.get(query.queryHash)\n\n    if (queryInMap) {\n      query.destroy()\n\n      if (queryInMap === query) {\n        this.#queries.delete(query.queryHash)\n      }\n\n      this.notify({ type: 'removed', query })\n    }\n  }\n\n  clear(): void {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        this.remove(query)\n      })\n    })\n  }\n\n  get<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryHash: string,\n  ): Query<TQueryFnData, TError, TData, TQueryKey> | undefined {\n    return this.#queries.get(queryHash) as\n      | Query<TQueryFnData, TError, TData, TQueryKey>\n      | undefined\n  }\n\n  getAll(): Array<Query> {\n    return [...this.#queries.values()]\n  }\n\n  find<TQueryFnData = unknown, TError = DefaultError, TData = TQueryFnData>(\n    filters: WithRequired<QueryFilters, 'queryKey'>,\n  ): Query<TQueryFnData, TError, TData> | undefined {\n    const defaultedFilters = { exact: true, ...filters }\n\n    return this.getAll().find((query) =>\n      matchQuery(defaultedFilters, query),\n    ) as Query<TQueryFnData, TError, TData> | undefined\n  }\n\n  findAll(filters: QueryFilters<any> = {}): Array<Query> {\n    const queries = this.getAll()\n    return Object.keys(filters).length > 0\n      ? queries.filter((query) => matchQuery(filters, query))\n      : queries\n  }\n\n  notify(event: QueryCacheNotifyEvent): void {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event)\n      })\n    })\n  }\n\n  onFocus(): void {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        query.onFocus()\n      })\n    })\n  }\n\n  onOnline(): void {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        query.onOnline()\n      })\n    })\n  }\n}\n", "import { notifyManager } from './notifyManager'\nimport { Removable } from './removable'\nimport { createRetryer } from './retryer'\nimport type {\n  DefaultError,\n  MutationMeta,\n  MutationOptions,\n  MutationStatus,\n} from './types'\nimport type { MutationCache } from './mutationCache'\nimport type { MutationObserver } from './mutationObserver'\nimport type { Retryer } from './retryer'\n\n// TYPES\n\ninterface MutationConfig<TData, TError, TVariables, TContext> {\n  mutationId: number\n  mutationCache: MutationCache\n  options: MutationOptions<TData, TError, TVariables, TContext>\n  state?: MutationState<TData, TError, TVariables, TContext>\n}\n\nexport interface MutationState<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = unknown,\n  TContext = unknown,\n> {\n  context: TContext | undefined\n  data: TData | undefined\n  error: TError | null\n  failureCount: number\n  failureReason: TError | null\n  isPaused: boolean\n  status: MutationStatus\n  variables: TVariables | undefined\n  submittedAt: number\n}\n\ninterface FailedAction<TError> {\n  type: 'failed'\n  failureCount: number\n  error: TError | null\n}\n\ninterface PendingAction<TVariables, TContext> {\n  type: 'pending'\n  isPaused: boolean\n  variables?: TVariables\n  context?: TContext\n}\n\ninterface SuccessAction<TData> {\n  type: 'success'\n  data: TData\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\nexport type Action<TData, TError, TVariables, TContext> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction<TError>\n  | PendingAction<TVariables, TContext>\n  | PauseAction\n  | SuccessAction<TData>\n\n// CLASS\n\nexport class Mutation<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = unknown,\n  TContext = unknown,\n> extends Removable {\n  state: MutationState<TData, TError, TVariables, TContext>\n  options!: MutationOptions<TData, TError, TVariables, TContext>\n  readonly mutationId: number\n\n  #observers: Array<MutationObserver<TData, TError, TVariables, TContext>>\n  #mutationCache: MutationCache\n  #retryer?: Retryer<TData>\n\n  constructor(config: MutationConfig<TData, TError, TVariables, TContext>) {\n    super()\n\n    this.mutationId = config.mutationId\n    this.#mutationCache = config.mutationCache\n    this.#observers = []\n    this.state = config.state || getDefaultState()\n\n    this.setOptions(config.options)\n    this.scheduleGc()\n  }\n\n  setOptions(\n    options: MutationOptions<TData, TError, TVariables, TContext>,\n  ): void {\n    this.options = options\n\n    this.updateGcTime(this.options.gcTime)\n  }\n\n  get meta(): MutationMeta | undefined {\n    return this.options.meta\n  }\n\n  addObserver(observer: MutationObserver<any, any, any, any>): void {\n    if (!this.#observers.includes(observer)) {\n      this.#observers.push(observer)\n\n      // Stop the mutation from being garbage collected\n      this.clearGcTimeout()\n\n      this.#mutationCache.notify({\n        type: 'observerAdded',\n        mutation: this,\n        observer,\n      })\n    }\n  }\n\n  removeObserver(observer: MutationObserver<any, any, any, any>): void {\n    this.#observers = this.#observers.filter((x) => x !== observer)\n\n    this.scheduleGc()\n\n    this.#mutationCache.notify({\n      type: 'observerRemoved',\n      mutation: this,\n      observer,\n    })\n  }\n\n  protected optionalRemove() {\n    if (!this.#observers.length) {\n      if (this.state.status === 'pending') {\n        this.scheduleGc()\n      } else {\n        this.#mutationCache.remove(this)\n      }\n    }\n  }\n\n  continue(): Promise<unknown> {\n    return (\n      this.#retryer?.continue() ??\n      // continuing a mutation assumes that variables are set, mutation must have been dehydrated before\n      this.execute(this.state.variables!)\n    )\n  }\n\n  async execute(variables: TVariables): Promise<TData> {\n    const onContinue = () => {\n      this.#dispatch({ type: 'continue' })\n    }\n\n    this.#retryer = createRetryer({\n      fn: () => {\n        if (!this.options.mutationFn) {\n          return Promise.reject(new Error('No mutationFn found'))\n        }\n        return this.options.mutationFn(variables)\n      },\n      onFail: (failureCount, error) => {\n        this.#dispatch({ type: 'failed', failureCount, error })\n      },\n      onPause: () => {\n        this.#dispatch({ type: 'pause' })\n      },\n      onContinue,\n      retry: this.options.retry ?? 0,\n      retryDelay: this.options.retryDelay,\n      networkMode: this.options.networkMode,\n      canRun: () => this.#mutationCache.canRun(this),\n    })\n\n    const restored = this.state.status === 'pending'\n    const isPaused = !this.#retryer.canStart()\n\n    try {\n      if (restored) {\n        // Dispatch continue action to unpause restored mutation\n        onContinue()\n      } else {\n        this.#dispatch({ type: 'pending', variables, isPaused })\n        // Notify cache callback\n        await this.#mutationCache.config.onMutate?.(\n          variables,\n          this as Mutation<unknown, unknown, unknown, unknown>,\n        )\n        const context = await this.options.onMutate?.(variables)\n        if (context !== this.state.context) {\n          this.#dispatch({\n            type: 'pending',\n            context,\n            variables,\n            isPaused,\n          })\n        }\n      }\n      const data = await this.#retryer.start()\n\n      // Notify cache callback\n      await this.#mutationCache.config.onSuccess?.(\n        data,\n        variables,\n        this.state.context,\n        this as Mutation<unknown, unknown, unknown, unknown>,\n      )\n\n      await this.options.onSuccess?.(data, variables, this.state.context!)\n\n      // Notify cache callback\n      await this.#mutationCache.config.onSettled?.(\n        data,\n        null,\n        this.state.variables,\n        this.state.context,\n        this as Mutation<unknown, unknown, unknown, unknown>,\n      )\n\n      await this.options.onSettled?.(data, null, variables, this.state.context)\n\n      this.#dispatch({ type: 'success', data })\n      return data\n    } catch (error) {\n      try {\n        // Notify cache callback\n        await this.#mutationCache.config.onError?.(\n          error as any,\n          variables,\n          this.state.context,\n          this as Mutation<unknown, unknown, unknown, unknown>,\n        )\n\n        await this.options.onError?.(\n          error as TError,\n          variables,\n          this.state.context,\n        )\n\n        // Notify cache callback\n        await this.#mutationCache.config.onSettled?.(\n          undefined,\n          error as any,\n          this.state.variables,\n          this.state.context,\n          this as Mutation<unknown, unknown, unknown, unknown>,\n        )\n\n        await this.options.onSettled?.(\n          undefined,\n          error as TError,\n          variables,\n          this.state.context,\n        )\n        throw error\n      } finally {\n        this.#dispatch({ type: 'error', error: error as TError })\n      }\n    } finally {\n      this.#mutationCache.runNext(this)\n    }\n  }\n\n  #dispatch(action: Action<TData, TError, TVariables, TContext>): void {\n    const reducer = (\n      state: MutationState<TData, TError, TVariables, TContext>,\n    ): MutationState<TData, TError, TVariables, TContext> => {\n      switch (action.type) {\n        case 'failed':\n          return {\n            ...state,\n            failureCount: action.failureCount,\n            failureReason: action.error,\n          }\n        case 'pause':\n          return {\n            ...state,\n            isPaused: true,\n          }\n        case 'continue':\n          return {\n            ...state,\n            isPaused: false,\n          }\n        case 'pending':\n          return {\n            ...state,\n            context: action.context,\n            data: undefined,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            isPaused: action.isPaused,\n            status: 'pending',\n            variables: action.variables,\n            submittedAt: Date.now(),\n          }\n        case 'success':\n          return {\n            ...state,\n            data: action.data,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            status: 'success',\n            isPaused: false,\n          }\n        case 'error':\n          return {\n            ...state,\n            data: undefined,\n            error: action.error,\n            failureCount: state.failureCount + 1,\n            failureReason: action.error,\n            isPaused: false,\n            status: 'error',\n          }\n      }\n    }\n    this.state = reducer(this.state)\n\n    notifyManager.batch(() => {\n      this.#observers.forEach((observer) => {\n        observer.onMutationUpdate(action)\n      })\n      this.#mutationCache.notify({\n        mutation: this,\n        type: 'updated',\n        action,\n      })\n    })\n  }\n}\n\nexport function getDefaultState<\n  TData,\n  TError,\n  TVariables,\n  TContext,\n>(): MutationState<TData, TError, TVariables, TContext> {\n  return {\n    context: undefined,\n    data: undefined,\n    error: null,\n    failureCount: 0,\n    failureReason: null,\n    isPaused: false,\n    status: 'idle',\n    variables: undefined,\n    submittedAt: 0,\n  }\n}\n", "import { notifyManager } from './notifyManager'\nimport { Mutation } from './mutation'\nimport { matchMutation, noop } from './utils'\nimport { Subscribable } from './subscribable'\nimport type { MutationObserver } from './mutationObserver'\nimport type { DefaultError, MutationOptions, NotifyEvent } from './types'\nimport type { QueryClient } from './queryClient'\nimport type { Action, MutationState } from './mutation'\nimport type { MutationFilters } from './utils'\n\n// TYPES\n\ninterface MutationCacheConfig {\n  onError?: (\n    error: DefaultError,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n  onSuccess?: (\n    data: unknown,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n  onMutate?: (\n    variables: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n  onSettled?: (\n    data: unknown | undefined,\n    error: DefaultError | null,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n}\n\ninterface NotifyEventMutationAdded extends NotifyEvent {\n  type: 'added'\n  mutation: Mutation<any, any, any, any>\n}\ninterface NotifyEventMutationRemoved extends NotifyEvent {\n  type: 'removed'\n  mutation: Mutation<any, any, any, any>\n}\n\ninterface NotifyEventMutationObserverAdded extends NotifyEvent {\n  type: 'observerAdded'\n  mutation: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any>\n}\n\ninterface NotifyEventMutationObserverRemoved extends NotifyEvent {\n  type: 'observerRemoved'\n  mutation: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any>\n}\n\ninterface NotifyEventMutationObserverOptionsUpdated extends NotifyEvent {\n  type: 'observerOptionsUpdated'\n  mutation?: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any, any>\n}\n\ninterface NotifyEventMutationUpdated extends NotifyEvent {\n  type: 'updated'\n  mutation: Mutation<any, any, any, any>\n  action: Action<any, any, any, any>\n}\n\nexport type MutationCacheNotifyEvent =\n  | NotifyEventMutationAdded\n  | NotifyEventMutationRemoved\n  | NotifyEventMutationObserverAdded\n  | NotifyEventMutationObserverRemoved\n  | NotifyEventMutationObserverOptionsUpdated\n  | NotifyEventMutationUpdated\n\ntype MutationCacheListener = (event: MutationCacheNotifyEvent) => void\n\n// CLASS\n\nexport class MutationCache extends Subscribable<MutationCacheListener> {\n  #mutations: Set<Mutation<any, any, any, any>>\n  #scopes: Map<string, Array<Mutation<any, any, any, any>>>\n  #mutationId: number\n\n  constructor(public config: MutationCacheConfig = {}) {\n    super()\n    this.#mutations = new Set()\n    this.#scopes = new Map()\n    this.#mutationId = 0\n  }\n\n  build<TData, TError, TVariables, TContext>(\n    client: QueryClient,\n    options: MutationOptions<TData, TError, TVariables, TContext>,\n    state?: MutationState<TData, TError, TVariables, TContext>,\n  ): Mutation<TData, TError, TVariables, TContext> {\n    const mutation = new Mutation({\n      mutationCache: this,\n      mutationId: ++this.#mutationId,\n      options: client.defaultMutationOptions(options),\n      state,\n    })\n\n    this.add(mutation)\n\n    return mutation\n  }\n\n  add(mutation: Mutation<any, any, any, any>): void {\n    this.#mutations.add(mutation)\n    const scope = scopeFor(mutation)\n    if (typeof scope === 'string') {\n      const scopedMutations = this.#scopes.get(scope)\n      if (scopedMutations) {\n        scopedMutations.push(mutation)\n      } else {\n        this.#scopes.set(scope, [mutation])\n      }\n    }\n    this.notify({ type: 'added', mutation })\n  }\n\n  remove(mutation: Mutation<any, any, any, any>): void {\n    if (this.#mutations.delete(mutation)) {\n      const scope = scopeFor(mutation)\n      if (typeof scope === 'string') {\n        const scopedMutations = this.#scopes.get(scope)\n        if (scopedMutations) {\n          if (scopedMutations.length > 1) {\n            const index = scopedMutations.indexOf(mutation)\n            if (index !== -1) {\n              scopedMutations.splice(index, 1)\n            }\n          } else if (scopedMutations[0] === mutation) {\n            this.#scopes.delete(scope)\n          }\n        }\n      }\n    }\n\n    // Currently we notify the removal even if the mutation was already removed.\n    // Consider making this an error or not notifying of the removal depending on the desired semantics.\n    this.notify({ type: 'removed', mutation })\n  }\n\n  canRun(mutation: Mutation<any, any, any, any>): boolean {\n    const scope = scopeFor(mutation)\n    if (typeof scope === 'string') {\n      const mutationsWithSameScope = this.#scopes.get(scope)\n      const firstPendingMutation = mutationsWithSameScope?.find(\n        (m) => m.state.status === 'pending',\n      )\n      // we can run if there is no current pending mutation (start use-case)\n      // or if WE are the first pending mutation (continue use-case)\n      return !firstPendingMutation || firstPendingMutation === mutation\n    } else {\n      // For unscoped mutations there are never any pending mutations in front of the\n      // current mutation\n      return true\n    }\n  }\n\n  runNext(mutation: Mutation<any, any, any, any>): Promise<unknown> {\n    const scope = scopeFor(mutation)\n    if (typeof scope === 'string') {\n      const foundMutation = this.#scopes\n        .get(scope)\n        ?.find((m) => m !== mutation && m.state.isPaused)\n\n      return foundMutation?.continue() ?? Promise.resolve()\n    } else {\n      return Promise.resolve()\n    }\n  }\n\n  clear(): void {\n    notifyManager.batch(() => {\n      this.#mutations.forEach((mutation) => {\n        this.notify({ type: 'removed', mutation })\n      })\n      this.#mutations.clear()\n      this.#scopes.clear()\n    })\n  }\n\n  getAll(): Array<Mutation> {\n    return Array.from(this.#mutations)\n  }\n\n  find<\n    TData = unknown,\n    TError = DefaultError,\n    TVariables = any,\n    TContext = unknown,\n  >(\n    filters: MutationFilters,\n  ): Mutation<TData, TError, TVariables, TContext> | undefined {\n    const defaultedFilters = { exact: true, ...filters }\n\n    return this.getAll().find((mutation) =>\n      matchMutation(defaultedFilters, mutation),\n    ) as Mutation<TData, TError, TVariables, TContext> | undefined\n  }\n\n  findAll(filters: MutationFilters = {}): Array<Mutation> {\n    return this.getAll().filter((mutation) => matchMutation(filters, mutation))\n  }\n\n  notify(event: MutationCacheNotifyEvent) {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event)\n      })\n    })\n  }\n\n  resumePausedMutations(): Promise<unknown> {\n    const pausedMutations = this.getAll().filter((x) => x.state.isPaused)\n\n    return notifyManager.batch(() =>\n      Promise.all(\n        pausedMutations.map((mutation) => mutation.continue().catch(noop)),\n      ),\n    )\n  }\n}\n\nfunction scopeFor(mutation: Mutation<any, any, any, any>) {\n  return mutation.options.scope?.id\n}\n", "import { addToEnd, addToStart, ensureQueryFn } from './utils'\nimport type { QueryBehavior } from './query'\nimport type {\n  InfiniteData,\n  InfiniteQueryPageParamsOptions,\n  OmitKeyof,\n  QueryFunctionContext,\n  QueryKey,\n} from './types'\n\nexport function infiniteQueryBehavior<TQueryFnData, TError, TData, TPageParam>(\n  pages?: number,\n): QueryBehavior<TQueryFnData, TError, InfiniteData<TData, TPageParam>> {\n  return {\n    onFetch: (context, query) => {\n      const options = context.options as InfiniteQueryPageParamsOptions<TData>\n      const direction = context.fetchOptions?.meta?.fetchMore?.direction\n      const oldPages = context.state.data?.pages || []\n      const oldPageParams = context.state.data?.pageParams || []\n      let result: InfiniteData<unknown> = { pages: [], pageParams: [] }\n      let currentPage = 0\n\n      const fetchFn = async () => {\n        let cancelled = false\n        const addSignalProperty = (object: unknown) => {\n          Object.defineProperty(object, 'signal', {\n            enumerable: true,\n            get: () => {\n              if (context.signal.aborted) {\n                cancelled = true\n              } else {\n                context.signal.addEventListener('abort', () => {\n                  cancelled = true\n                })\n              }\n              return context.signal\n            },\n          })\n        }\n\n        const queryFn = ensureQueryFn(context.options, context.fetchOptions)\n\n        // Create function to fetch a page\n        const fetchPage = async (\n          data: InfiniteData<unknown>,\n          param: unknown,\n          previous?: boolean,\n        ): Promise<InfiniteData<unknown>> => {\n          if (cancelled) {\n            return Promise.reject()\n          }\n\n          if (param == null && data.pages.length) {\n            return Promise.resolve(data)\n          }\n\n          const createQueryFnContext = () => {\n            const queryFnContext: OmitKeyof<\n              QueryFunctionContext<QueryKey, unknown>,\n              'signal'\n            > = {\n              client: context.client,\n              queryKey: context.queryKey,\n              pageParam: param,\n              direction: previous ? 'backward' : 'forward',\n              meta: context.options.meta,\n            }\n            addSignalProperty(queryFnContext)\n            return queryFnContext as QueryFunctionContext<QueryKey, unknown>\n          }\n\n          const queryFnContext = createQueryFnContext()\n\n          const page = await queryFn(queryFnContext)\n\n          const { maxPages } = context.options\n          const addTo = previous ? addToStart : addToEnd\n\n          return {\n            pages: addTo(data.pages, page, maxPages),\n            pageParams: addTo(data.pageParams, param, maxPages),\n          }\n        }\n\n        // fetch next / previous page?\n        if (direction && oldPages.length) {\n          const previous = direction === 'backward'\n          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam\n          const oldData = {\n            pages: oldPages,\n            pageParams: oldPageParams,\n          }\n          const param = pageParamFn(options, oldData)\n\n          result = await fetchPage(oldData, param, previous)\n        } else {\n          const remainingPages = pages ?? oldPages.length\n\n          // Fetch all pages\n          do {\n            const param =\n              currentPage === 0\n                ? (oldPageParams[0] ?? options.initialPageParam)\n                : getNextPageParam(options, result)\n            if (currentPage > 0 && param == null) {\n              break\n            }\n            result = await fetchPage(result, param)\n            currentPage++\n          } while (currentPage < remainingPages)\n        }\n\n        return result\n      }\n      if (context.options.persister) {\n        context.fetchFn = () => {\n          return context.options.persister?.(\n            fetchFn as any,\n            {\n              client: context.client,\n              queryKey: context.queryKey,\n              meta: context.options.meta,\n              signal: context.signal,\n            },\n            query,\n          )\n        }\n      } else {\n        context.fetchFn = fetchFn\n      }\n    },\n  }\n}\n\nfunction getNextPageParam(\n  options: InfiniteQueryPageParamsOptions<any>,\n  { pages, pageParams }: InfiniteData<unknown>,\n): unknown | undefined {\n  const lastIndex = pages.length - 1\n  return pages.length > 0\n    ? options.getNextPageParam(\n        pages[lastIndex],\n        pages,\n        pageParams[lastIndex],\n        pageParams,\n      )\n    : undefined\n}\n\nfunction getPreviousPageParam(\n  options: InfiniteQueryPageParamsOptions<any>,\n  { pages, pageParams }: InfiniteData<unknown>,\n): unknown | undefined {\n  return pages.length > 0\n    ? options.getPreviousPageParam?.(pages[0], pages, pageParams[0], pageParams)\n    : undefined\n}\n\n/**\n * Checks if there is a next page.\n */\nexport function hasNextPage(\n  options: InfiniteQueryPageParamsOptions<any, any>,\n  data?: InfiniteData<unknown>,\n): boolean {\n  if (!data) return false\n  return getNextPageParam(options, data) != null\n}\n\n/**\n * Checks if there is a previous page.\n */\nexport function hasPreviousPage(\n  options: InfiniteQueryPageParamsOptions<any, any>,\n  data?: InfiniteData<unknown>,\n): boolean {\n  if (!data || !options.getPreviousPageParam) return false\n  return getPreviousPageParam(options, data) != null\n}\n", "import {\n  functionalUpdate,\n  hashKey,\n  hashQueryKeyByOptions,\n  noop,\n  partialMatchKey,\n  resolveStaleTime,\n  skipToken,\n} from './utils'\nimport { QueryCache } from './queryCache'\nimport { MutationCache } from './mutationCache'\nimport { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { notifyManager } from './notifyManager'\nimport { infiniteQueryBehavior } from './infiniteQueryBehavior'\nimport type {\n  CancelOptions,\n  DefaultError,\n  DefaultOptions,\n  DefaultedQueryObserverOptions,\n  EnsureInfiniteQueryDataOptions,\n  EnsureQueryDataOptions,\n  FetchInfiniteQueryOptions,\n  FetchQueryOptions,\n  InferDataFromTag,\n  InferErrorFromTag,\n  InfiniteData,\n  InvalidateOptions,\n  InvalidateQueryFilters,\n  MutationKey,\n  MutationObserverOptions,\n  MutationOptions,\n  NoInfer,\n  OmitKeyof,\n  QueryClientConfig,\n  QueryKey,\n  QueryObserverOptions,\n  QueryOptions,\n  RefetchOptions,\n  RefetchQueryFilters,\n  ResetOptions,\n  SetDataOptions,\n} from './types'\nimport type { QueryState } from './query'\nimport type { MutationFilters, QueryFilters, Updater } from './utils'\n\n// TYPES\n\ninterface QueryDefaults {\n  queryKey: QueryKey\n  defaultOptions: OmitKeyof<QueryOptions<any, any, any>, 'queryKey'>\n}\n\ninterface MutationDefaults {\n  mutationKey: MutationKey\n  defaultOptions: MutationOptions<any, any, any, any>\n}\n\n// CLASS\n\nexport class QueryClient {\n  #queryCache: QueryCache\n  #mutationCache: MutationCache\n  #defaultOptions: DefaultOptions\n  #queryDefaults: Map<string, QueryDefaults>\n  #mutationDefaults: Map<string, MutationDefaults>\n  #mountCount: number\n  #unsubscribeFocus?: () => void\n  #unsubscribeOnline?: () => void\n\n  constructor(config: QueryClientConfig = {}) {\n    this.#queryCache = config.queryCache || new QueryCache()\n    this.#mutationCache = config.mutationCache || new MutationCache()\n    this.#defaultOptions = config.defaultOptions || {}\n    this.#queryDefaults = new Map()\n    this.#mutationDefaults = new Map()\n    this.#mountCount = 0\n  }\n\n  mount(): void {\n    this.#mountCount++\n    if (this.#mountCount !== 1) return\n\n    this.#unsubscribeFocus = focusManager.subscribe(async (focused) => {\n      if (focused) {\n        await this.resumePausedMutations()\n        this.#queryCache.onFocus()\n      }\n    })\n    this.#unsubscribeOnline = onlineManager.subscribe(async (online) => {\n      if (online) {\n        await this.resumePausedMutations()\n        this.#queryCache.onOnline()\n      }\n    })\n  }\n\n  unmount(): void {\n    this.#mountCount--\n    if (this.#mountCount !== 0) return\n\n    this.#unsubscribeFocus?.()\n    this.#unsubscribeFocus = undefined\n\n    this.#unsubscribeOnline?.()\n    this.#unsubscribeOnline = undefined\n  }\n\n  isFetching<TQueryFilters extends QueryFilters<any> = QueryFilters>(\n    filters?: TQueryFilters,\n  ): number {\n    return this.#queryCache.findAll({ ...filters, fetchStatus: 'fetching' })\n      .length\n  }\n\n  isMutating<\n    TMutationFilters extends MutationFilters<any, any> = MutationFilters,\n  >(filters?: TMutationFilters): number {\n    return this.#mutationCache.findAll({ ...filters, status: 'pending' }).length\n  }\n\n  /**\n   * Imperative (non-reactive) way to retrieve data for a QueryKey.\n   * Should only be used in callbacks or functions where reading the latest data is necessary, e.g. for optimistic updates.\n   *\n   * Hint: Do not use this function inside a component, because it won't receive updates.\n   * Use `useQuery` to create a `QueryObserver` that subscribes to changes.\n   */\n  getQueryData<\n    TQueryFnData = unknown,\n    TTaggedQueryKey extends QueryKey = QueryKey,\n    TInferredQueryFnData = InferDataFromTag<TQueryFnData, TTaggedQueryKey>,\n  >(queryKey: TTaggedQueryKey): TInferredQueryFnData | undefined {\n    const options = this.defaultQueryOptions({ queryKey })\n\n    return this.#queryCache.get<TInferredQueryFnData>(options.queryHash)?.state\n      .data\n  }\n\n  ensureQueryData<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: EnsureQueryDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData> {\n    const defaultedOptions = this.defaultQueryOptions(options)\n    const query = this.#queryCache.build(this, defaultedOptions)\n    const cachedData = query.state.data\n\n    if (cachedData === undefined) {\n      return this.fetchQuery(options)\n    }\n\n    if (\n      options.revalidateIfStale &&\n      query.isStaleByTime(resolveStaleTime(defaultedOptions.staleTime, query))\n    ) {\n      void this.prefetchQuery(defaultedOptions)\n    }\n\n    return Promise.resolve(cachedData)\n  }\n\n  getQueriesData<\n    TQueryFnData = unknown,\n    TQueryFilters extends QueryFilters<any> = QueryFilters,\n  >(filters: TQueryFilters): Array<[QueryKey, TQueryFnData | undefined]> {\n    return this.#queryCache.findAll(filters).map(({ queryKey, state }) => {\n      const data = state.data as TQueryFnData | undefined\n      return [queryKey, data]\n    })\n  }\n\n  setQueryData<\n    TQueryFnData = unknown,\n    TTaggedQueryKey extends QueryKey = QueryKey,\n    TInferredQueryFnData = InferDataFromTag<TQueryFnData, TTaggedQueryKey>,\n  >(\n    queryKey: TTaggedQueryKey,\n    updater: Updater<\n      NoInfer<TInferredQueryFnData> | undefined,\n      NoInfer<TInferredQueryFnData> | undefined\n    >,\n    options?: SetDataOptions,\n  ): NoInfer<TInferredQueryFnData> | undefined {\n    const defaultedOptions = this.defaultQueryOptions<\n      any,\n      any,\n      unknown,\n      any,\n      QueryKey\n    >({ queryKey })\n\n    const query = this.#queryCache.get<TInferredQueryFnData>(\n      defaultedOptions.queryHash,\n    )\n    const prevData = query?.state.data\n    const data = functionalUpdate(updater, prevData)\n\n    if (data === undefined) {\n      return undefined\n    }\n\n    return this.#queryCache\n      .build(this, defaultedOptions)\n      .setData(data, { ...options, manual: true })\n  }\n\n  setQueriesData<\n    TQueryFnData,\n    TQueryFilters extends QueryFilters<any> = QueryFilters,\n  >(\n    filters: TQueryFilters,\n    updater: Updater<\n      NoInfer<TQueryFnData> | undefined,\n      NoInfer<TQueryFnData> | undefined\n    >,\n    options?: SetDataOptions,\n  ): Array<[QueryKey, TQueryFnData | undefined]> {\n    return notifyManager.batch(() =>\n      this.#queryCache\n        .findAll(filters)\n        .map(({ queryKey }) => [\n          queryKey,\n          this.setQueryData<TQueryFnData>(queryKey, updater, options),\n        ]),\n    )\n  }\n\n  getQueryState<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TTaggedQueryKey extends QueryKey = QueryKey,\n    TInferredQueryFnData = InferDataFromTag<TQueryFnData, TTaggedQueryKey>,\n    TInferredError = InferErrorFromTag<TError, TTaggedQueryKey>,\n  >(\n    queryKey: TTaggedQueryKey,\n  ): QueryState<TInferredQueryFnData, TInferredError> | undefined {\n    const options = this.defaultQueryOptions({ queryKey })\n    return this.#queryCache.get<TInferredQueryFnData, TInferredError>(\n      options.queryHash,\n    )?.state\n  }\n\n  removeQueries<TTaggedQueryKey extends QueryKey = QueryKey>(\n    filters?: QueryFilters<TTaggedQueryKey>,\n  ): void {\n    const queryCache = this.#queryCache\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        queryCache.remove(query)\n      })\n    })\n  }\n\n  resetQueries<TTaggedQueryKey extends QueryKey = QueryKey>(\n    filters?: QueryFilters<TTaggedQueryKey>,\n    options?: ResetOptions,\n  ): Promise<void> {\n    const queryCache = this.#queryCache\n\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        query.reset()\n      })\n      return this.refetchQueries(\n        {\n          type: 'active',\n          ...filters,\n        },\n        options,\n      )\n    })\n  }\n\n  cancelQueries<TTaggedQueryKey extends QueryKey = QueryKey>(\n    filters?: QueryFilters<TTaggedQueryKey>,\n    cancelOptions: CancelOptions = {},\n  ): Promise<void> {\n    const defaultedCancelOptions = { revert: true, ...cancelOptions }\n\n    const promises = notifyManager.batch(() =>\n      this.#queryCache\n        .findAll(filters)\n        .map((query) => query.cancel(defaultedCancelOptions)),\n    )\n\n    return Promise.all(promises).then(noop).catch(noop)\n  }\n\n  invalidateQueries<TTaggedQueryKey extends QueryKey = QueryKey>(\n    filters?: InvalidateQueryFilters<TTaggedQueryKey>,\n    options: InvalidateOptions = {},\n  ): Promise<void> {\n    return notifyManager.batch(() => {\n      this.#queryCache.findAll(filters).forEach((query) => {\n        query.invalidate()\n      })\n\n      if (filters?.refetchType === 'none') {\n        return Promise.resolve()\n      }\n      return this.refetchQueries(\n        {\n          ...filters,\n          type: filters?.refetchType ?? filters?.type ?? 'active',\n        },\n        options,\n      )\n    })\n  }\n\n  refetchQueries<TTaggedQueryKey extends QueryKey = QueryKey>(\n    filters?: RefetchQueryFilters<TTaggedQueryKey>,\n    options: RefetchOptions = {},\n  ): Promise<void> {\n    const fetchOptions = {\n      ...options,\n      cancelRefetch: options.cancelRefetch ?? true,\n    }\n    const promises = notifyManager.batch(() =>\n      this.#queryCache\n        .findAll(filters)\n        .filter((query) => !query.isDisabled() && !query.isStatic())\n        .map((query) => {\n          let promise = query.fetch(undefined, fetchOptions)\n          if (!fetchOptions.throwOnError) {\n            promise = promise.catch(noop)\n          }\n          return query.state.fetchStatus === 'paused'\n            ? Promise.resolve()\n            : promise\n        }),\n    )\n\n    return Promise.all(promises).then(noop)\n  }\n\n  fetchQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = never,\n  >(\n    options: FetchQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<TData> {\n    const defaultedOptions = this.defaultQueryOptions(options)\n\n    // https://github.com/tannerlinsley/react-query/issues/652\n    if (defaultedOptions.retry === undefined) {\n      defaultedOptions.retry = false\n    }\n\n    const query = this.#queryCache.build(this, defaultedOptions)\n\n    return query.isStaleByTime(\n      resolveStaleTime(defaultedOptions.staleTime, query),\n    )\n      ? query.fetch(defaultedOptions)\n      : Promise.resolve(query.state.data as TData)\n  }\n\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void> {\n    return this.fetchQuery(options).then(noop).catch(noop)\n  }\n\n  fetchInfiniteQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: FetchInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<InfiniteData<TData, TPageParam>> {\n    options.behavior = infiniteQueryBehavior<\n      TQueryFnData,\n      TError,\n      TData,\n      TPageParam\n    >(options.pages)\n    return this.fetchQuery(options as any)\n  }\n\n  prefetchInfiniteQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: FetchInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<void> {\n    return this.fetchInfiniteQuery(options).then(noop).catch(noop)\n  }\n\n  ensureInfiniteQueryData<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: EnsureInfiniteQueryDataOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<InfiniteData<TData, TPageParam>> {\n    options.behavior = infiniteQueryBehavior<\n      TQueryFnData,\n      TError,\n      TData,\n      TPageParam\n    >(options.pages)\n\n    return this.ensureQueryData(options as any)\n  }\n\n  resumePausedMutations(): Promise<unknown> {\n    if (onlineManager.isOnline()) {\n      return this.#mutationCache.resumePausedMutations()\n    }\n    return Promise.resolve()\n  }\n\n  getQueryCache(): QueryCache {\n    return this.#queryCache\n  }\n\n  getMutationCache(): MutationCache {\n    return this.#mutationCache\n  }\n\n  getDefaultOptions(): DefaultOptions {\n    return this.#defaultOptions\n  }\n\n  setDefaultOptions(options: DefaultOptions): void {\n    this.#defaultOptions = options\n  }\n\n  setQueryDefaults<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryData = TQueryFnData,\n  >(\n    queryKey: QueryKey,\n    options: Partial<\n      OmitKeyof<\n        QueryObserverOptions<TQueryFnData, TError, TData, TQueryData>,\n        'queryKey'\n      >\n    >,\n  ): void {\n    this.#queryDefaults.set(hashKey(queryKey), {\n      queryKey,\n      defaultOptions: options,\n    })\n  }\n\n  getQueryDefaults(\n    queryKey: QueryKey,\n  ): OmitKeyof<QueryObserverOptions<any, any, any, any, any>, 'queryKey'> {\n    const defaults = [...this.#queryDefaults.values()]\n\n    const result: OmitKeyof<\n      QueryObserverOptions<any, any, any, any, any>,\n      'queryKey'\n    > = {}\n\n    defaults.forEach((queryDefault) => {\n      if (partialMatchKey(queryKey, queryDefault.queryKey)) {\n        Object.assign(result, queryDefault.defaultOptions)\n      }\n    })\n    return result\n  }\n\n  setMutationDefaults<\n    TData = unknown,\n    TError = DefaultError,\n    TVariables = void,\n    TContext = unknown,\n  >(\n    mutationKey: MutationKey,\n    options: OmitKeyof<\n      MutationObserverOptions<TData, TError, TVariables, TContext>,\n      'mutationKey'\n    >,\n  ): void {\n    this.#mutationDefaults.set(hashKey(mutationKey), {\n      mutationKey,\n      defaultOptions: options,\n    })\n  }\n\n  getMutationDefaults(\n    mutationKey: MutationKey,\n  ): OmitKeyof<MutationObserverOptions<any, any, any, any>, 'mutationKey'> {\n    const defaults = [...this.#mutationDefaults.values()]\n\n    const result: OmitKeyof<\n      MutationObserverOptions<any, any, any, any>,\n      'mutationKey'\n    > = {}\n\n    defaults.forEach((queryDefault) => {\n      if (partialMatchKey(mutationKey, queryDefault.mutationKey)) {\n        Object.assign(result, queryDefault.defaultOptions)\n      }\n    })\n\n    return result\n  }\n\n  defaultQueryOptions<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = never,\n  >(\n    options:\n      | QueryObserverOptions<\n          TQueryFnData,\n          TError,\n          TData,\n          TQueryData,\n          TQueryKey,\n          TPageParam\n        >\n      | DefaultedQueryObserverOptions<\n          TQueryFnData,\n          TError,\n          TData,\n          TQueryData,\n          TQueryKey\n        >,\n  ): DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  > {\n    if (options._defaulted) {\n      return options as DefaultedQueryObserverOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryData,\n        TQueryKey\n      >\n    }\n\n    const defaultedOptions = {\n      ...this.#defaultOptions.queries,\n      ...this.getQueryDefaults(options.queryKey),\n      ...options,\n      _defaulted: true,\n    }\n\n    if (!defaultedOptions.queryHash) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(\n        defaultedOptions.queryKey,\n        defaultedOptions,\n      )\n    }\n\n    // dependent default values\n    if (defaultedOptions.refetchOnReconnect === undefined) {\n      defaultedOptions.refetchOnReconnect =\n        defaultedOptions.networkMode !== 'always'\n    }\n    if (defaultedOptions.throwOnError === undefined) {\n      defaultedOptions.throwOnError = !!defaultedOptions.suspense\n    }\n\n    if (!defaultedOptions.networkMode && defaultedOptions.persister) {\n      defaultedOptions.networkMode = 'offlineFirst'\n    }\n\n    if (defaultedOptions.queryFn === skipToken) {\n      defaultedOptions.enabled = false\n    }\n\n    return defaultedOptions as DefaultedQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >\n  }\n\n  defaultMutationOptions<T extends MutationOptions<any, any, any, any>>(\n    options?: T,\n  ): T {\n    if (options?._defaulted) {\n      return options\n    }\n    return {\n      ...this.#defaultOptions.mutations,\n      ...(options?.mutationKey &&\n        this.getMutationDefaults(options.mutationKey)),\n      ...options,\n      _defaulted: true,\n    } as T\n  }\n\n  clear(): void {\n    this.#queryCache.clear()\n    this.#mutationCache.clear()\n  }\n}\n", "import { focusManager } from './focusManager'\nimport { notifyManager } from './notifyManager'\nimport { fetchState } from './query'\nimport { Subscribable } from './subscribable'\nimport { pendingThenable } from './thenable'\nimport {\n  isServer,\n  isValidTimeout,\n  noop,\n  replaceData,\n  resolveEnabled,\n  resolveStaleTime,\n  shallowEqualObjects,\n  timeUntilStale,\n} from './utils'\nimport type { FetchOptions, Query, QueryState } from './query'\nimport type { QueryClient } from './queryClient'\nimport type { PendingThenable, Thenable } from './thenable'\nimport type {\n  DefaultError,\n  DefaultedQueryObserverOptions,\n  PlaceholderDataFunction,\n  QueryKey,\n  QueryObserverBaseResult,\n  QueryObserverOptions,\n  QueryObserverResult,\n  QueryOptions,\n  RefetchOptions,\n} from './types'\n\ntype QueryObserverListener<TData, TError> = (\n  result: QueryObserverResult<TData, TError>,\n) => void\n\ninterface ObserverFetchOptions extends FetchOptions {\n  throwOnError?: boolean\n}\n\nexport class QueryObserver<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Subscribable<QueryObserverListener<TData, TError>> {\n  #client: QueryClient\n  #currentQuery: Query<TQueryFnData, TError, TQueryData, TQueryKey> = undefined!\n  #currentQueryInitialState: QueryState<TQueryData, TError> = undefined!\n  #currentResult: QueryObserverResult<TData, TError> = undefined!\n  #currentResultState?: QueryState<TQueryData, TError>\n  #currentResultOptions?: QueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >\n  #currentThenable: Thenable<TData>\n  #selectError: TError | null\n  #selectFn?: (data: TQueryData) => TData\n  #selectResult?: TData\n  // This property keeps track of the last query with defined data.\n  // It will be used to pass the previous data and query to the placeholder function between renders.\n  #lastQueryWithDefinedData?: Query<TQueryFnData, TError, TQueryData, TQueryKey>\n  #staleTimeoutId?: ReturnType<typeof setTimeout>\n  #refetchIntervalId?: ReturnType<typeof setInterval>\n  #currentRefetchInterval?: number | false\n  #trackedProps = new Set<keyof QueryObserverResult>()\n\n  constructor(\n    client: QueryClient,\n    public options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ) {\n    super()\n\n    this.#client = client\n    this.#selectError = null\n    this.#currentThenable = pendingThenable()\n    if (!this.options.experimental_prefetchInRender) {\n      this.#currentThenable.reject(\n        new Error('experimental_prefetchInRender feature flag is not enabled'),\n      )\n    }\n\n    this.bindMethods()\n    this.setOptions(options)\n  }\n\n  protected bindMethods(): void {\n    this.refetch = this.refetch.bind(this)\n  }\n\n  protected onSubscribe(): void {\n    if (this.listeners.size === 1) {\n      this.#currentQuery.addObserver(this)\n\n      if (shouldFetchOnMount(this.#currentQuery, this.options)) {\n        this.#executeFetch()\n      } else {\n        this.updateResult()\n      }\n\n      this.#updateTimers()\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.hasListeners()) {\n      this.destroy()\n    }\n  }\n\n  shouldFetchOnReconnect(): boolean {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnReconnect,\n    )\n  }\n\n  shouldFetchOnWindowFocus(): boolean {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnWindowFocus,\n    )\n  }\n\n  destroy(): void {\n    this.listeners = new Set()\n    this.#clearStaleTimeout()\n    this.#clearRefetchInterval()\n    this.#currentQuery.removeObserver(this)\n  }\n\n  setOptions(\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): void {\n    const prevOptions = this.options\n    const prevQuery = this.#currentQuery\n\n    this.options = this.#client.defaultQueryOptions(options)\n\n    if (\n      this.options.enabled !== undefined &&\n      typeof this.options.enabled !== 'boolean' &&\n      typeof this.options.enabled !== 'function' &&\n      typeof resolveEnabled(this.options.enabled, this.#currentQuery) !==\n        'boolean'\n    ) {\n      throw new Error(\n        'Expected enabled to be a boolean or a callback that returns a boolean',\n      )\n    }\n\n    this.#updateQuery()\n    this.#currentQuery.setOptions(this.options)\n\n    if (\n      prevOptions._defaulted &&\n      !shallowEqualObjects(this.options, prevOptions)\n    ) {\n      this.#client.getQueryCache().notify({\n        type: 'observerOptionsUpdated',\n        query: this.#currentQuery,\n        observer: this,\n      })\n    }\n\n    const mounted = this.hasListeners()\n\n    // Fetch if there are subscribers\n    if (\n      mounted &&\n      shouldFetchOptionally(\n        this.#currentQuery,\n        prevQuery,\n        this.options,\n        prevOptions,\n      )\n    ) {\n      this.#executeFetch()\n    }\n\n    // Update result\n    this.updateResult()\n\n    // Update stale interval if needed\n    if (\n      mounted &&\n      (this.#currentQuery !== prevQuery ||\n        resolveEnabled(this.options.enabled, this.#currentQuery) !==\n          resolveEnabled(prevOptions.enabled, this.#currentQuery) ||\n        resolveStaleTime(this.options.staleTime, this.#currentQuery) !==\n          resolveStaleTime(prevOptions.staleTime, this.#currentQuery))\n    ) {\n      this.#updateStaleTimeout()\n    }\n\n    const nextRefetchInterval = this.#computeRefetchInterval()\n\n    // Update refetch interval if needed\n    if (\n      mounted &&\n      (this.#currentQuery !== prevQuery ||\n        resolveEnabled(this.options.enabled, this.#currentQuery) !==\n          resolveEnabled(prevOptions.enabled, this.#currentQuery) ||\n        nextRefetchInterval !== this.#currentRefetchInterval)\n    ) {\n      this.#updateRefetchInterval(nextRefetchInterval)\n    }\n  }\n\n  getOptimisticResult(\n    options: DefaultedQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): QueryObserverResult<TData, TError> {\n    const query = this.#client.getQueryCache().build(this.#client, options)\n\n    const result = this.createResult(query, options)\n\n    if (shouldAssignObserverCurrentProperties(this, result)) {\n      // this assigns the optimistic result to the current Observer\n      // because if the query function changes, useQuery will be performing\n      // an effect where it would fetch again.\n      // When the fetch finishes, we perform a deep data cloning in order\n      // to reuse objects references. This deep data clone is performed against\n      // the `observer.currentResult.data` property\n      // When QueryKey changes, we refresh the query and get new `optimistic`\n      // result, while we leave the `observer.currentResult`, so when new data\n      // arrives, it finds the old `observer.currentResult` which is related\n      // to the old QueryKey. Which means that currentResult and selectData are\n      // out of sync already.\n      // To solve this, we move the cursor of the currentResult every time\n      // an observer reads an optimistic value.\n\n      // When keeping the previous data, the result doesn't change until new\n      // data arrives.\n      this.#currentResult = result\n      this.#currentResultOptions = this.options\n      this.#currentResultState = this.#currentQuery.state\n    }\n    return result\n  }\n\n  getCurrentResult(): QueryObserverResult<TData, TError> {\n    return this.#currentResult\n  }\n\n  trackResult(\n    result: QueryObserverResult<TData, TError>,\n    onPropTracked?: (key: keyof QueryObserverResult) => void,\n  ): QueryObserverResult<TData, TError> {\n    return new Proxy(result, {\n      get: (target, key) => {\n        this.trackProp(key as keyof QueryObserverResult)\n        onPropTracked?.(key as keyof QueryObserverResult)\n        return Reflect.get(target, key)\n      },\n    })\n  }\n\n  trackProp(key: keyof QueryObserverResult) {\n    this.#trackedProps.add(key)\n  }\n\n  getCurrentQuery(): Query<TQueryFnData, TError, TQueryData, TQueryKey> {\n    return this.#currentQuery\n  }\n\n  refetch({ ...options }: RefetchOptions = {}): Promise<\n    QueryObserverResult<TData, TError>\n  > {\n    return this.fetch({\n      ...options,\n    })\n  }\n\n  fetchOptimistic(\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): Promise<QueryObserverResult<TData, TError>> {\n    const defaultedOptions = this.#client.defaultQueryOptions(options)\n\n    const query = this.#client\n      .getQueryCache()\n      .build(this.#client, defaultedOptions)\n\n    return query.fetch().then(() => this.createResult(query, defaultedOptions))\n  }\n\n  protected fetch(\n    fetchOptions: ObserverFetchOptions,\n  ): Promise<QueryObserverResult<TData, TError>> {\n    return this.#executeFetch({\n      ...fetchOptions,\n      cancelRefetch: fetchOptions.cancelRefetch ?? true,\n    }).then(() => {\n      this.updateResult()\n      return this.#currentResult\n    })\n  }\n\n  #executeFetch(\n    fetchOptions?: Omit<ObserverFetchOptions, 'initialPromise'>,\n  ): Promise<TQueryData | undefined> {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.#updateQuery()\n\n    // Fetch\n    let promise: Promise<TQueryData | undefined> = this.#currentQuery.fetch(\n      this.options as QueryOptions<TQueryFnData, TError, TQueryData, TQueryKey>,\n      fetchOptions,\n    )\n\n    if (!fetchOptions?.throwOnError) {\n      promise = promise.catch(noop)\n    }\n\n    return promise\n  }\n\n  #updateStaleTimeout(): void {\n    this.#clearStaleTimeout()\n    const staleTime = resolveStaleTime(\n      this.options.staleTime,\n      this.#currentQuery,\n    )\n\n    if (isServer || this.#currentResult.isStale || !isValidTimeout(staleTime)) {\n      return\n    }\n\n    const time = timeUntilStale(this.#currentResult.dataUpdatedAt, staleTime)\n\n    // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n    const timeout = time + 1\n\n    this.#staleTimeoutId = setTimeout(() => {\n      if (!this.#currentResult.isStale) {\n        this.updateResult()\n      }\n    }, timeout)\n  }\n\n  #computeRefetchInterval() {\n    return (\n      (typeof this.options.refetchInterval === 'function'\n        ? this.options.refetchInterval(this.#currentQuery)\n        : this.options.refetchInterval) ?? false\n    )\n  }\n\n  #updateRefetchInterval(nextInterval: number | false): void {\n    this.#clearRefetchInterval()\n\n    this.#currentRefetchInterval = nextInterval\n\n    if (\n      isServer ||\n      resolveEnabled(this.options.enabled, this.#currentQuery) === false ||\n      !isValidTimeout(this.#currentRefetchInterval) ||\n      this.#currentRefetchInterval === 0\n    ) {\n      return\n    }\n\n    this.#refetchIntervalId = setInterval(() => {\n      if (\n        this.options.refetchIntervalInBackground ||\n        focusManager.isFocused()\n      ) {\n        this.#executeFetch()\n      }\n    }, this.#currentRefetchInterval)\n  }\n\n  #updateTimers(): void {\n    this.#updateStaleTimeout()\n    this.#updateRefetchInterval(this.#computeRefetchInterval())\n  }\n\n  #clearStaleTimeout(): void {\n    if (this.#staleTimeoutId) {\n      clearTimeout(this.#staleTimeoutId)\n      this.#staleTimeoutId = undefined\n    }\n  }\n\n  #clearRefetchInterval(): void {\n    if (this.#refetchIntervalId) {\n      clearInterval(this.#refetchIntervalId)\n      this.#refetchIntervalId = undefined\n    }\n  }\n\n  protected createResult(\n    query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): QueryObserverResult<TData, TError> {\n    const prevQuery = this.#currentQuery\n    const prevOptions = this.options\n    const prevResult = this.#currentResult as\n      | QueryObserverResult<TData, TError>\n      | undefined\n    const prevResultState = this.#currentResultState\n    const prevResultOptions = this.#currentResultOptions\n    const queryChange = query !== prevQuery\n    const queryInitialState = queryChange\n      ? query.state\n      : this.#currentQueryInitialState\n\n    const { state } = query\n    let newState = { ...state }\n    let isPlaceholderData = false\n    let data: TData | undefined\n\n    // Optimistically set result in fetching state if needed\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners()\n\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options)\n\n      const fetchOptionally =\n        mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions)\n\n      if (fetchOnMount || fetchOptionally) {\n        newState = {\n          ...newState,\n          ...fetchState(state.data, query.options),\n        }\n      }\n      if (options._optimisticResults === 'isRestoring') {\n        newState.fetchStatus = 'idle'\n      }\n    }\n\n    let { error, errorUpdatedAt, status } = newState\n\n    // Per default, use query data\n    data = newState.data as unknown as TData\n    let skipSelect = false\n\n    // use placeholderData if needed\n    if (\n      options.placeholderData !== undefined &&\n      data === undefined &&\n      status === 'pending'\n    ) {\n      let placeholderData\n\n      // Memoize placeholder data\n      if (\n        prevResult?.isPlaceholderData &&\n        options.placeholderData === prevResultOptions?.placeholderData\n      ) {\n        placeholderData = prevResult.data\n        // we have to skip select when reading this memoization\n        // because prevResult.data is already \"selected\"\n        skipSelect = true\n      } else {\n        // compute placeholderData\n        placeholderData =\n          typeof options.placeholderData === 'function'\n            ? (\n                options.placeholderData as unknown as PlaceholderDataFunction<TQueryData>\n              )(\n                this.#lastQueryWithDefinedData?.state.data,\n                this.#lastQueryWithDefinedData as any,\n              )\n            : options.placeholderData\n      }\n\n      if (placeholderData !== undefined) {\n        status = 'success'\n        data = replaceData(\n          prevResult?.data,\n          placeholderData as unknown,\n          options,\n        ) as TData\n        isPlaceholderData = true\n      }\n    }\n\n    // Select data if needed\n    // this also runs placeholderData through the select function\n    if (options.select && data !== undefined && !skipSelect) {\n      // Memoize select result\n      if (\n        prevResult &&\n        data === prevResultState?.data &&\n        options.select === this.#selectFn\n      ) {\n        data = this.#selectResult\n      } else {\n        try {\n          this.#selectFn = options.select\n          data = options.select(data as any)\n          data = replaceData(prevResult?.data, data, options)\n          this.#selectResult = data\n          this.#selectError = null\n        } catch (selectError) {\n          this.#selectError = selectError as TError\n        }\n      }\n    }\n\n    if (this.#selectError) {\n      error = this.#selectError as any\n      data = this.#selectResult\n      errorUpdatedAt = Date.now()\n      status = 'error'\n    }\n\n    const isFetching = newState.fetchStatus === 'fetching'\n    const isPending = status === 'pending'\n    const isError = status === 'error'\n\n    const isLoading = isPending && isFetching\n    const hasData = data !== undefined\n\n    const result: QueryObserverBaseResult<TData, TError> = {\n      status,\n      fetchStatus: newState.fetchStatus,\n      isPending,\n      isSuccess: status === 'success',\n      isError,\n      isInitialLoading: isLoading,\n      isLoading,\n      data,\n      dataUpdatedAt: newState.dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: newState.fetchFailureCount,\n      failureReason: newState.fetchFailureReason,\n      errorUpdateCount: newState.errorUpdateCount,\n      isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,\n      isFetchedAfterMount:\n        newState.dataUpdateCount > queryInitialState.dataUpdateCount ||\n        newState.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isPending,\n      isLoadingError: isError && !hasData,\n      isPaused: newState.fetchStatus === 'paused',\n      isPlaceholderData,\n      isRefetchError: isError && hasData,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      promise: this.#currentThenable,\n    }\n\n    const nextResult = result as QueryObserverResult<TData, TError>\n\n    if (this.options.experimental_prefetchInRender) {\n      const finalizeThenableIfPossible = (thenable: PendingThenable<TData>) => {\n        if (nextResult.status === 'error') {\n          thenable.reject(nextResult.error)\n        } else if (nextResult.data !== undefined) {\n          thenable.resolve(nextResult.data)\n        }\n      }\n\n      /**\n       * Create a new thenable and result promise when the results have changed\n       */\n      const recreateThenable = () => {\n        const pending =\n          (this.#currentThenable =\n          nextResult.promise =\n            pendingThenable())\n\n        finalizeThenableIfPossible(pending)\n      }\n\n      const prevThenable = this.#currentThenable\n      switch (prevThenable.status) {\n        case 'pending':\n          // Finalize the previous thenable if it was pending\n          // and we are still observing the same query\n          if (query.queryHash === prevQuery.queryHash) {\n            finalizeThenableIfPossible(prevThenable)\n          }\n          break\n        case 'fulfilled':\n          if (\n            nextResult.status === 'error' ||\n            nextResult.data !== prevThenable.value\n          ) {\n            recreateThenable()\n          }\n          break\n        case 'rejected':\n          if (\n            nextResult.status !== 'error' ||\n            nextResult.error !== prevThenable.reason\n          ) {\n            recreateThenable()\n          }\n          break\n      }\n    }\n\n    return nextResult\n  }\n\n  updateResult(): void {\n    const prevResult = this.#currentResult as\n      | QueryObserverResult<TData, TError>\n      | undefined\n\n    const nextResult = this.createResult(this.#currentQuery, this.options)\n\n    this.#currentResultState = this.#currentQuery.state\n    this.#currentResultOptions = this.options\n\n    if (this.#currentResultState.data !== undefined) {\n      this.#lastQueryWithDefinedData = this.#currentQuery\n    }\n\n    // Only notify and update result if something has changed\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return\n    }\n\n    this.#currentResult = nextResult\n\n    const shouldNotifyListeners = (): boolean => {\n      if (!prevResult) {\n        return true\n      }\n\n      const { notifyOnChangeProps } = this.options\n      const notifyOnChangePropsValue =\n        typeof notifyOnChangeProps === 'function'\n          ? notifyOnChangeProps()\n          : notifyOnChangeProps\n\n      if (\n        notifyOnChangePropsValue === 'all' ||\n        (!notifyOnChangePropsValue && !this.#trackedProps.size)\n      ) {\n        return true\n      }\n\n      const includedProps = new Set(\n        notifyOnChangePropsValue ?? this.#trackedProps,\n      )\n\n      if (this.options.throwOnError) {\n        includedProps.add('error')\n      }\n\n      return Object.keys(this.#currentResult).some((key) => {\n        const typedKey = key as keyof QueryObserverResult\n        const changed = this.#currentResult[typedKey] !== prevResult[typedKey]\n\n        return changed && includedProps.has(typedKey)\n      })\n    }\n\n    this.#notify({ listeners: shouldNotifyListeners() })\n  }\n\n  #updateQuery(): void {\n    const query = this.#client.getQueryCache().build(this.#client, this.options)\n\n    if (query === this.#currentQuery) {\n      return\n    }\n\n    const prevQuery = this.#currentQuery as\n      | Query<TQueryFnData, TError, TQueryData, TQueryKey>\n      | undefined\n    this.#currentQuery = query\n    this.#currentQueryInitialState = query.state\n\n    if (this.hasListeners()) {\n      prevQuery?.removeObserver(this)\n      query.addObserver(this)\n    }\n  }\n\n  onQueryUpdate(): void {\n    this.updateResult()\n\n    if (this.hasListeners()) {\n      this.#updateTimers()\n    }\n  }\n\n  #notify(notifyOptions: { listeners: boolean }): void {\n    notifyManager.batch(() => {\n      // First, trigger the listeners\n      if (notifyOptions.listeners) {\n        this.listeners.forEach((listener) => {\n          listener(this.#currentResult)\n        })\n      }\n\n      // Then the cache listeners\n      this.#client.getQueryCache().notify({\n        query: this.#currentQuery,\n        type: 'observerResultsUpdated',\n      })\n    })\n  }\n}\n\nfunction shouldLoadOnMount(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any>,\n): boolean {\n  return (\n    resolveEnabled(options.enabled, query) !== false &&\n    query.state.data === undefined &&\n    !(query.state.status === 'error' && options.retryOnMount === false)\n  )\n}\n\nfunction shouldFetchOnMount(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    shouldLoadOnMount(query, options) ||\n    (query.state.data !== undefined &&\n      shouldFetchOn(query, options, options.refetchOnMount))\n  )\n}\n\nfunction shouldFetchOn(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n  field: (typeof options)['refetchOnMount'] &\n    (typeof options)['refetchOnWindowFocus'] &\n    (typeof options)['refetchOnReconnect'],\n) {\n  if (\n    resolveEnabled(options.enabled, query) !== false &&\n    resolveStaleTime(options.staleTime, query) !== 'static'\n  ) {\n    const value = typeof field === 'function' ? field(query) : field\n\n    return value === 'always' || (value !== false && isStale(query, options))\n  }\n  return false\n}\n\nfunction shouldFetchOptionally(\n  query: Query<any, any, any, any>,\n  prevQuery: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n  prevOptions: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    (query !== prevQuery ||\n      resolveEnabled(prevOptions.enabled, query) === false) &&\n    (!options.suspense || query.state.status !== 'error') &&\n    isStale(query, options)\n  )\n}\n\nfunction isStale(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    resolveEnabled(options.enabled, query) !== false &&\n    query.isStaleByTime(resolveStaleTime(options.staleTime, query))\n  )\n}\n\n// this function would decide if we will update the observer's 'current'\n// properties after an optimistic reading via getOptimisticResult\nfunction shouldAssignObserverCurrentProperties<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  observer: QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  optimisticResult: QueryObserverResult<TData, TError>,\n) {\n  // if the newly created result isn't what the observer is holding as current,\n  // then we'll need to update the properties as well\n  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {\n    return true\n  }\n\n  // basically, just keep previous properties if nothing changed\n  return false\n}\n", "import { notifyManager } from './notifyManager'\nimport { QueryObserver } from './queryObserver'\nimport { Subscribable } from './subscribable'\nimport { replaceEqualDeep } from './utils'\nimport type {\n  DefaultedQueryObserverOptions,\n  QueryObserverOptions,\n  QueryObserverResult,\n} from './types'\nimport type { QueryClient } from './queryClient'\n\nfunction difference<T>(array1: Array<T>, array2: Array<T>): Array<T> {\n  const excludeSet = new Set(array2)\n  return array1.filter((x) => !excludeSet.has(x))\n}\n\nfunction replaceAt<T>(array: Array<T>, index: number, value: T): Array<T> {\n  const copy = array.slice(0)\n  copy[index] = value\n  return copy\n}\n\ntype QueriesObserverListener = (result: Array<QueryObserverResult>) => void\n\ntype CombineFn<TCombinedResult> = (\n  result: Array<QueryObserverResult>,\n) => TCombinedResult\n\nexport interface QueriesObserverOptions<\n  TCombinedResult = Array<QueryObserverResult>,\n> {\n  combine?: CombineFn<TCombinedResult>\n}\n\nexport class QueriesObserver<\n  TCombinedResult = Array<QueryObserverResult>,\n> extends Subscribable<QueriesObserverListener> {\n  #client: QueryClient\n  #result!: Array<QueryObserverResult>\n  #queries: Array<QueryObserverOptions>\n  #options?: QueriesObserverOptions<TCombinedResult>\n  #observers: Array<QueryObserver>\n  #combinedResult?: TCombinedResult\n  #lastCombine?: CombineFn<TCombinedResult>\n  #lastResult?: Array<QueryObserverResult>\n  #observerMatches: Array<QueryObserverMatch> = []\n\n  constructor(\n    client: QueryClient,\n    queries: Array<QueryObserverOptions<any, any, any, any, any>>,\n    options?: QueriesObserverOptions<TCombinedResult>,\n  ) {\n    super()\n\n    this.#client = client\n    this.#options = options\n    this.#queries = []\n    this.#observers = []\n    this.#result = []\n\n    this.setQueries(queries)\n  }\n\n  protected onSubscribe(): void {\n    if (this.listeners.size === 1) {\n      this.#observers.forEach((observer) => {\n        observer.subscribe((result) => {\n          this.#onUpdate(observer, result)\n        })\n      })\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.listeners.size) {\n      this.destroy()\n    }\n  }\n\n  destroy(): void {\n    this.listeners = new Set()\n    this.#observers.forEach((observer) => {\n      observer.destroy()\n    })\n  }\n\n  setQueries(\n    queries: Array<QueryObserverOptions>,\n    options?: QueriesObserverOptions<TCombinedResult>,\n  ): void {\n    this.#queries = queries\n    this.#options = options\n\n    if (process.env.NODE_ENV !== 'production') {\n      const queryHashes = queries.map(\n        (query) => this.#client.defaultQueryOptions(query).queryHash,\n      )\n      if (new Set(queryHashes).size !== queryHashes.length) {\n        console.warn(\n          '[QueriesObserver]: Duplicate Queries found. This might result in unexpected behavior.',\n        )\n      }\n    }\n\n    notifyManager.batch(() => {\n      const prevObservers = this.#observers\n\n      const newObserverMatches = this.#findMatchingObservers(this.#queries)\n      this.#observerMatches = newObserverMatches\n\n      // set options for the new observers to notify of changes\n      newObserverMatches.forEach((match) =>\n        match.observer.setOptions(match.defaultedQueryOptions),\n      )\n\n      const newObservers = newObserverMatches.map((match) => match.observer)\n      const newResult = newObservers.map((observer) =>\n        observer.getCurrentResult(),\n      )\n\n      const hasIndexChange = newObservers.some(\n        (observer, index) => observer !== prevObservers[index],\n      )\n\n      if (prevObservers.length === newObservers.length && !hasIndexChange) {\n        return\n      }\n\n      this.#observers = newObservers\n      this.#result = newResult\n\n      if (!this.hasListeners()) {\n        return\n      }\n\n      difference(prevObservers, newObservers).forEach((observer) => {\n        observer.destroy()\n      })\n\n      difference(newObservers, prevObservers).forEach((observer) => {\n        observer.subscribe((result) => {\n          this.#onUpdate(observer, result)\n        })\n      })\n\n      this.#notify()\n    })\n  }\n\n  getCurrentResult(): Array<QueryObserverResult> {\n    return this.#result\n  }\n\n  getQueries() {\n    return this.#observers.map((observer) => observer.getCurrentQuery())\n  }\n\n  getObservers() {\n    return this.#observers\n  }\n\n  getOptimisticResult(\n    queries: Array<QueryObserverOptions>,\n    combine: CombineFn<TCombinedResult> | undefined,\n  ): [\n    rawResult: Array<QueryObserverResult>,\n    combineResult: (r?: Array<QueryObserverResult>) => TCombinedResult,\n    trackResult: () => Array<QueryObserverResult>,\n  ] {\n    const matches = this.#findMatchingObservers(queries)\n    const result = matches.map((match) =>\n      match.observer.getOptimisticResult(match.defaultedQueryOptions),\n    )\n\n    return [\n      result,\n      (r?: Array<QueryObserverResult>) => {\n        return this.#combineResult(r ?? result, combine)\n      },\n      () => {\n        return this.#trackResult(result, matches)\n      },\n    ]\n  }\n\n  #trackResult(\n    result: Array<QueryObserverResult>,\n    matches: Array<QueryObserverMatch>,\n  ) {\n    return matches.map((match, index) => {\n      const observerResult = result[index]!\n      return !match.defaultedQueryOptions.notifyOnChangeProps\n        ? match.observer.trackResult(observerResult, (accessedProp) => {\n            // track property on all observers to ensure proper (synchronized) tracking (#7000)\n            matches.forEach((m) => {\n              m.observer.trackProp(accessedProp)\n            })\n          })\n        : observerResult\n    })\n  }\n\n  #combineResult(\n    input: Array<QueryObserverResult>,\n    combine: CombineFn<TCombinedResult> | undefined,\n  ): TCombinedResult {\n    if (combine) {\n      if (\n        !this.#combinedResult ||\n        this.#result !== this.#lastResult ||\n        combine !== this.#lastCombine\n      ) {\n        this.#lastCombine = combine\n        this.#lastResult = this.#result\n        this.#combinedResult = replaceEqualDeep(\n          this.#combinedResult,\n          combine(input),\n        )\n      }\n\n      return this.#combinedResult\n    }\n    return input as any\n  }\n\n  #findMatchingObservers(\n    queries: Array<QueryObserverOptions>,\n  ): Array<QueryObserverMatch> {\n    const prevObserversMap = new Map(\n      this.#observers.map((observer) => [observer.options.queryHash, observer]),\n    )\n\n    const observers: Array<QueryObserverMatch> = []\n\n    queries.forEach((options) => {\n      const defaultedOptions = this.#client.defaultQueryOptions(options)\n      const match = prevObserversMap.get(defaultedOptions.queryHash)\n      if (match) {\n        observers.push({\n          defaultedQueryOptions: defaultedOptions,\n          observer: match,\n        })\n      } else {\n        observers.push({\n          defaultedQueryOptions: defaultedOptions,\n          observer: new QueryObserver(this.#client, defaultedOptions),\n        })\n      }\n    })\n\n    return observers\n  }\n\n  #onUpdate(observer: QueryObserver, result: QueryObserverResult): void {\n    const index = this.#observers.indexOf(observer)\n    if (index !== -1) {\n      this.#result = replaceAt(this.#result, index, result)\n      this.#notify()\n    }\n  }\n\n  #notify(): void {\n    if (this.hasListeners()) {\n      const previousResult = this.#combinedResult\n      const newTracked = this.#trackResult(this.#result, this.#observerMatches)\n      const newResult = this.#combineResult(newTracked, this.#options?.combine)\n\n      if (previousResult !== newResult) {\n        notifyManager.batch(() => {\n          this.listeners.forEach((listener) => {\n            listener(this.#result)\n          })\n        })\n      }\n    }\n  }\n}\n\ntype QueryObserverMatch = {\n  defaultedQueryOptions: DefaultedQueryObserverOptions\n  observer: QueryObserver\n}\n", "import { QueryObserver } from './queryObserver'\nimport {\n  hasNextPage,\n  hasPreviousPage,\n  infiniteQueryBehavior,\n} from './infiniteQueryBehavior'\nimport type { Subscribable } from './subscribable'\nimport type {\n  DefaultError,\n  DefaultedInfiniteQueryObserverOptions,\n  FetchNextPageOptions,\n  FetchPreviousPageOptions,\n  InfiniteData,\n  InfiniteQueryObserverBaseResult,\n  InfiniteQueryObserverOptions,\n  InfiniteQueryObserverResult,\n  QueryKey,\n} from './types'\nimport type { QueryClient } from './queryClient'\nimport type { Query } from './query'\n\ntype InfiniteQueryObserverListener<TData, TError> = (\n  result: InfiniteQueryObserverResult<TData, TError>,\n) => void\n\nexport class InfiniteQueryObserver<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> extends QueryObserver<\n  TQueryFnData,\n  TError,\n  TData,\n  InfiniteData<TQueryFnData, TPageParam>,\n  TQueryKey\n> {\n  // Type override\n  subscribe!: Subscribable<\n    InfiniteQueryObserverListener<TData, TError>\n  >['subscribe']\n\n  // Type override\n  getCurrentResult!: ReplaceReturnType<\n    QueryObserver<\n      TQueryFnData,\n      TError,\n      TData,\n      InfiniteData<TQueryFnData, TPageParam>,\n      TQueryKey\n    >['getCurrentResult'],\n    InfiniteQueryObserverResult<TData, TError>\n  >\n\n  // Type override\n  protected fetch!: ReplaceReturnType<\n    QueryObserver<\n      TQueryFnData,\n      TError,\n      TData,\n      InfiniteData<TQueryFnData, TPageParam>,\n      TQueryKey\n    >['fetch'],\n    Promise<InfiniteQueryObserverResult<TData, TError>>\n  >\n\n  constructor(\n    client: QueryClient,\n    options: InfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ) {\n    super(client, options)\n  }\n\n  protected bindMethods(): void {\n    super.bindMethods()\n    this.fetchNextPage = this.fetchNextPage.bind(this)\n    this.fetchPreviousPage = this.fetchPreviousPage.bind(this)\n  }\n\n  setOptions(\n    options: InfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): void {\n    super.setOptions({\n      ...options,\n      behavior: infiniteQueryBehavior(),\n    })\n  }\n\n  getOptimisticResult(\n    options: DefaultedInfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): InfiniteQueryObserverResult<TData, TError> {\n    options.behavior = infiniteQueryBehavior()\n    return super.getOptimisticResult(options) as InfiniteQueryObserverResult<\n      TData,\n      TError\n    >\n  }\n\n  fetchNextPage(\n    options?: FetchNextPageOptions,\n  ): Promise<InfiniteQueryObserverResult<TData, TError>> {\n    return this.fetch({\n      ...options,\n      meta: {\n        fetchMore: { direction: 'forward' },\n      },\n    })\n  }\n\n  fetchPreviousPage(\n    options?: FetchPreviousPageOptions,\n  ): Promise<InfiniteQueryObserverResult<TData, TError>> {\n    return this.fetch({\n      ...options,\n      meta: {\n        fetchMore: { direction: 'backward' },\n      },\n    })\n  }\n\n  protected createResult(\n    query: Query<\n      TQueryFnData,\n      TError,\n      InfiniteData<TQueryFnData, TPageParam>,\n      TQueryKey\n    >,\n    options: InfiniteQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): InfiniteQueryObserverResult<TData, TError> {\n    const { state } = query\n    const parentResult = super.createResult(query, options)\n\n    const { isFetching, isRefetching, isError, isRefetchError } = parentResult\n    const fetchDirection = state.fetchMeta?.fetchMore?.direction\n\n    const isFetchNextPageError = isError && fetchDirection === 'forward'\n    const isFetchingNextPage = isFetching && fetchDirection === 'forward'\n\n    const isFetchPreviousPageError = isError && fetchDirection === 'backward'\n    const isFetchingPreviousPage = isFetching && fetchDirection === 'backward'\n\n    const result: InfiniteQueryObserverBaseResult<TData, TError> = {\n      ...parentResult,\n      fetchNextPage: this.fetchNextPage,\n      fetchPreviousPage: this.fetchPreviousPage,\n      hasNextPage: hasNextPage(options, state.data),\n      hasPreviousPage: hasPreviousPage(options, state.data),\n      isFetchNextPageError,\n      isFetchingNextPage,\n      isFetchPreviousPageError,\n      isFetchingPreviousPage,\n      isRefetchError:\n        isRefetchError && !isFetchNextPageError && !isFetchPreviousPageError,\n      isRefetching:\n        isRefetching && !isFetchingNextPage && !isFetchingPreviousPage,\n    }\n\n    return result as InfiniteQueryObserverResult<TData, TError>\n  }\n}\n\ntype ReplaceReturnType<\n  TFunction extends (...args: Array<any>) => unknown,\n  TReturn,\n> = (...args: Parameters<TFunction>) => TReturn\n", "import { getDefaultState } from './mutation'\nimport { notifyManager } from './notifyManager'\nimport { Subscribable } from './subscribable'\nimport { hashKey, shallowEqualObjects } from './utils'\nimport type { QueryClient } from './queryClient'\nimport type {\n  DefaultError,\n  MutateOptions,\n  MutationObserverOptions,\n  MutationObserverResult,\n} from './types'\nimport type { Action, Mutation } from './mutation'\n\n// TYPES\n\ntype MutationObserverListener<TData, TError, TVariables, TContext> = (\n  result: MutationObserverResult<TData, TError, TVariables, TContext>,\n) => void\n\n// CLASS\n\nexport class MutationObserver<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n> extends Subscribable<\n  MutationObserverListener<TData, TError, TVariables, TContext>\n> {\n  options!: MutationObserverOptions<TData, TError, TVariables, TContext>\n\n  #client: QueryClient\n  #currentResult: MutationObserverResult<TData, TError, TVariables, TContext> =\n    undefined!\n  #currentMutation?: Mutation<TData, TError, TVariables, TContext>\n  #mutateOptions?: MutateOptions<TData, TError, TVariables, TContext>\n\n  constructor(\n    client: QueryClient,\n    options: MutationObserverOptions<TData, TError, TVariables, TContext>,\n  ) {\n    super()\n\n    this.#client = client\n    this.setOptions(options)\n    this.bindMethods()\n    this.#updateResult()\n  }\n\n  protected bindMethods(): void {\n    this.mutate = this.mutate.bind(this)\n    this.reset = this.reset.bind(this)\n  }\n\n  setOptions(\n    options: MutationObserverOptions<TData, TError, TVariables, TContext>,\n  ) {\n    const prevOptions = this.options as\n      | MutationObserverOptions<TData, TError, TVariables, TContext>\n      | undefined\n    this.options = this.#client.defaultMutationOptions(options)\n    if (!shallowEqualObjects(this.options, prevOptions)) {\n      this.#client.getMutationCache().notify({\n        type: 'observerOptionsUpdated',\n        mutation: this.#currentMutation,\n        observer: this,\n      })\n    }\n\n    if (\n      prevOptions?.mutationKey &&\n      this.options.mutationKey &&\n      hashKey(prevOptions.mutationKey) !== hashKey(this.options.mutationKey)\n    ) {\n      this.reset()\n    } else if (this.#currentMutation?.state.status === 'pending') {\n      this.#currentMutation.setOptions(this.options)\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.hasListeners()) {\n      this.#currentMutation?.removeObserver(this)\n    }\n  }\n\n  onMutationUpdate(action: Action<TData, TError, TVariables, TContext>): void {\n    this.#updateResult()\n\n    this.#notify(action)\n  }\n\n  getCurrentResult(): MutationObserverResult<\n    TData,\n    TError,\n    TVariables,\n    TContext\n  > {\n    return this.#currentResult\n  }\n\n  reset(): void {\n    // reset needs to remove the observer from the mutation because there is no way to \"get it back\"\n    // another mutate call will yield a new mutation!\n    this.#currentMutation?.removeObserver(this)\n    this.#currentMutation = undefined\n    this.#updateResult()\n    this.#notify()\n  }\n\n  mutate(\n    variables: TVariables,\n    options?: MutateOptions<TData, TError, TVariables, TContext>,\n  ): Promise<TData> {\n    this.#mutateOptions = options\n\n    this.#currentMutation?.removeObserver(this)\n\n    this.#currentMutation = this.#client\n      .getMutationCache()\n      .build(this.#client, this.options)\n\n    this.#currentMutation.addObserver(this)\n\n    return this.#currentMutation.execute(variables)\n  }\n\n  #updateResult(): void {\n    const state =\n      this.#currentMutation?.state ??\n      getDefaultState<TData, TError, TVariables, TContext>()\n\n    this.#currentResult = {\n      ...state,\n      isPending: state.status === 'pending',\n      isSuccess: state.status === 'success',\n      isError: state.status === 'error',\n      isIdle: state.status === 'idle',\n      mutate: this.mutate,\n      reset: this.reset,\n    } as MutationObserverResult<TData, TError, TVariables, TContext>\n  }\n\n  #notify(action?: Action<TData, TError, TVariables, TContext>): void {\n    notifyManager.batch(() => {\n      // First trigger the mutate callbacks\n      if (this.#mutateOptions && this.hasListeners()) {\n        const variables = this.#currentResult.variables!\n        const context = this.#currentResult.context\n\n        if (action?.type === 'success') {\n          this.#mutateOptions.onSuccess?.(action.data, variables, context!)\n          this.#mutateOptions.onSettled?.(action.data, null, variables, context)\n        } else if (action?.type === 'error') {\n          this.#mutateOptions.onError?.(action.error, variables, context)\n          this.#mutateOptions.onSettled?.(\n            undefined,\n            action.error,\n            variables,\n            context,\n          )\n        }\n      }\n\n      // Then trigger the listeners\n      this.listeners.forEach((listener) => {\n        listener(this.#currentResult)\n      })\n    })\n  }\n}\n", "'use client'\nimport * as React from 'react'\n\nimport {\n  QueriesObserver,\n  QueryObserver,\n  noop,\n  notifyManager,\n} from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport { useIsRestoring } from './IsRestoringProvider'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary,\n} from './errorBoundaryUtils'\nimport {\n  ensureSuspenseTimers,\n  fetchOptimistic,\n  shouldSuspend,\n  willFetch,\n} from './suspense'\nimport type {\n  DefinedUseQueryResult,\n  UseQueryOptions,\n  UseQueryResult,\n} from './types'\nimport type {\n  DefaultError,\n  OmitKeyof,\n  QueriesObserverOptions,\n  QueriesPlaceholderDataFunction,\n  QueryClient,\n  QueryFunction,\n  QueryKey,\n  QueryObserverOptions,\n  ThrowOnError,\n} from '@tanstack/query-core'\n\n// This defines the `UseQueryOptions` that are accepted in `QueriesOptions` & `GetOptions`.\n// `placeholderData` function always gets undefined passed\ntype UseQueryOptionsForUseQueries<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = OmitKeyof<\n  UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  'placeholderData' | 'subscribed'\n> & {\n  placeholderData?: TQueryFnData | QueriesPlaceholderDataFunction<TQueryFnData>\n}\n\n// Avoid TS depth-limit error in case of large array literal\ntype MAXIMUM_DEPTH = 20\n\n// Widen the type of the symbol to enable type inference even if skipToken is not immutable.\ntype SkipTokenForUseQueries = symbol\n\ntype GetUseQueryOptionsForUseQueries<T> =\n  // Part 1: responsible for applying explicit type parameter to function arguments, if object { queryFnData: TQueryFnData, error: TError, data: TData }\n  T extends {\n    queryFnData: infer TQueryFnData\n    error?: infer TError\n    data: infer TData\n  }\n    ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n      ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n      : T extends { data: infer TData; error?: infer TError }\n        ? UseQueryOptionsForUseQueries<unknown, TError, TData>\n        : // Part 2: responsible for applying explicit type parameter to function arguments, if tuple [TQueryFnData, TError, TData]\n          T extends [infer TQueryFnData, infer TError, infer TData]\n          ? UseQueryOptionsForUseQueries<TQueryFnData, TError, TData>\n          : T extends [infer TQueryFnData, infer TError]\n            ? UseQueryOptionsForUseQueries<TQueryFnData, TError>\n            : T extends [infer TQueryFnData]\n              ? UseQueryOptionsForUseQueries<TQueryFnData>\n              : // Part 3: responsible for inferring and enforcing type if no explicit parameter was provided\n                T extends {\n                    queryFn?:\n                      | QueryFunction<infer TQueryFnData, infer TQueryKey>\n                      | SkipTokenForUseQueries\n                    select?: (data: any) => infer TData\n                    throwOnError?: ThrowOnError<any, infer TError, any, any>\n                  }\n                ? UseQueryOptionsForUseQueries<\n                    TQueryFnData,\n                    unknown extends TError ? DefaultError : TError,\n                    unknown extends TData ? TQueryFnData : TData,\n                    TQueryKey\n                  >\n                : // Fallback\n                  UseQueryOptionsForUseQueries\n\n// A defined initialData setting should return a DefinedUseQueryResult rather than UseQueryResult\ntype GetDefinedOrUndefinedQueryResult<T, TData, TError = unknown> = T extends {\n  initialData?: infer TInitialData\n}\n  ? unknown extends TInitialData\n    ? UseQueryResult<TData, TError>\n    : TInitialData extends TData\n      ? DefinedUseQueryResult<TData, TError>\n      : TInitialData extends () => infer TInitialDataResult\n        ? unknown extends TInitialDataResult\n          ? UseQueryResult<TData, TError>\n          : TInitialDataResult extends TData\n            ? DefinedUseQueryResult<TData, TError>\n            : UseQueryResult<TData, TError>\n        : UseQueryResult<TData, TError>\n  : UseQueryResult<TData, TError>\n\ntype GetUseQueryResult<T> =\n  // Part 1: responsible for mapping explicit type parameter to function result, if object\n  T extends { queryFnData: any; error?: infer TError; data: infer TData }\n    ? GetDefinedOrUndefinedQueryResult<T, TData, TError>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n      ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData, TError>\n      : T extends { data: infer TData; error?: infer TError }\n        ? GetDefinedOrUndefinedQueryResult<T, TData, TError>\n        : // Part 2: responsible for mapping explicit type parameter to function result, if tuple\n          T extends [any, infer TError, infer TData]\n          ? GetDefinedOrUndefinedQueryResult<T, TData, TError>\n          : T extends [infer TQueryFnData, infer TError]\n            ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData, TError>\n            : T extends [infer TQueryFnData]\n              ? GetDefinedOrUndefinedQueryResult<T, TQueryFnData>\n              : // Part 3: responsible for mapping inferred type to results, if no explicit parameter was provided\n                T extends {\n                    queryFn?:\n                      | QueryFunction<infer TQueryFnData, any>\n                      | SkipTokenForUseQueries\n                    select?: (data: any) => infer TData\n                    throwOnError?: ThrowOnError<any, infer TError, any, any>\n                  }\n                ? GetDefinedOrUndefinedQueryResult<\n                    T,\n                    unknown extends TData ? TQueryFnData : TData,\n                    unknown extends TError ? DefaultError : TError\n                  >\n                : // Fallback\n                  UseQueryResult\n\n/**\n * QueriesOptions reducer recursively unwraps function arguments to infer/enforce type param\n */\nexport type QueriesOptions<\n  T extends Array<any>,\n  TResults extends Array<any> = [],\n  TDepth extends ReadonlyArray<number> = [],\n> = TDepth['length'] extends MAXIMUM_DEPTH\n  ? Array<UseQueryOptionsForUseQueries>\n  : T extends []\n    ? []\n    : T extends [infer Head]\n      ? [...TResults, GetUseQueryOptionsForUseQueries<Head>]\n      : T extends [infer Head, ...infer Tails]\n        ? QueriesOptions<\n            [...Tails],\n            [...TResults, GetUseQueryOptionsForUseQueries<Head>],\n            [...TDepth, 1]\n          >\n        : ReadonlyArray<unknown> extends T\n          ? T\n          : // If T is *some* array but we couldn't assign unknown[] to it, then it must hold some known/homogenous type!\n            // use this to infer the param types in the case of Array.map() argument\n            T extends Array<\n                UseQueryOptionsForUseQueries<\n                  infer TQueryFnData,\n                  infer TError,\n                  infer TData,\n                  infer TQueryKey\n                >\n              >\n            ? Array<\n                UseQueryOptionsForUseQueries<\n                  TQueryFnData,\n                  TError,\n                  TData,\n                  TQueryKey\n                >\n              >\n            : // Fallback\n              Array<UseQueryOptionsForUseQueries>\n\n/**\n * QueriesResults reducer recursively maps type param to results\n */\nexport type QueriesResults<\n  T extends Array<any>,\n  TResults extends Array<any> = [],\n  TDepth extends ReadonlyArray<number> = [],\n> = TDepth['length'] extends MAXIMUM_DEPTH\n  ? Array<UseQueryResult>\n  : T extends []\n    ? []\n    : T extends [infer Head]\n      ? [...TResults, GetUseQueryResult<Head>]\n      : T extends [infer Head, ...infer Tails]\n        ? QueriesResults<\n            [...Tails],\n            [...TResults, GetUseQueryResult<Head>],\n            [...TDepth, 1]\n          >\n        : { [K in keyof T]: GetUseQueryResult<T[K]> }\n\nexport function useQueries<\n  T extends Array<any>,\n  TCombinedResult = QueriesResults<T>,\n>(\n  {\n    queries,\n    ...options\n  }: {\n    queries:\n      | readonly [...QueriesOptions<T>]\n      | readonly [...{ [K in keyof T]: GetUseQueryOptionsForUseQueries<T[K]> }]\n    combine?: (result: QueriesResults<T>) => TCombinedResult\n    subscribed?: boolean\n  },\n  queryClient?: QueryClient,\n): TCombinedResult {\n  const client = useQueryClient(queryClient)\n  const isRestoring = useIsRestoring()\n  const errorResetBoundary = useQueryErrorResetBoundary()\n\n  const defaultedQueries = React.useMemo(\n    () =>\n      queries.map((opts) => {\n        const defaultedOptions = client.defaultQueryOptions(\n          opts as QueryObserverOptions,\n        )\n\n        // Make sure the results are already in fetching state before subscribing or updating options\n        defaultedOptions._optimisticResults = isRestoring\n          ? 'isRestoring'\n          : 'optimistic'\n\n        return defaultedOptions\n      }),\n    [queries, client, isRestoring],\n  )\n\n  defaultedQueries.forEach((query) => {\n    ensureSuspenseTimers(query)\n    ensurePreventErrorBoundaryRetry(query, errorResetBoundary)\n  })\n\n  useClearResetErrorBoundary(errorResetBoundary)\n\n  const [observer] = React.useState(\n    () =>\n      new QueriesObserver<TCombinedResult>(\n        client,\n        defaultedQueries,\n        options as QueriesObserverOptions<TCombinedResult>,\n      ),\n  )\n\n  // note: this must be called before useSyncExternalStore\n  const [optimisticResult, getCombinedResult, trackResult] =\n    observer.getOptimisticResult(\n      defaultedQueries,\n      (options as QueriesObserverOptions<TCombinedResult>).combine,\n    )\n\n  const shouldSubscribe = !isRestoring && options.subscribed !== false\n  React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        shouldSubscribe\n          ? observer.subscribe(notifyManager.batchCalls(onStoreChange))\n          : noop,\n      [observer, shouldSubscribe],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    observer.setQueries(\n      defaultedQueries,\n      options as QueriesObserverOptions<TCombinedResult>,\n    )\n  }, [defaultedQueries, options, observer])\n\n  const shouldAtLeastOneSuspend = optimisticResult.some((result, index) =>\n    shouldSuspend(defaultedQueries[index], result),\n  )\n\n  const suspensePromises = shouldAtLeastOneSuspend\n    ? optimisticResult.flatMap((result, index) => {\n        const opts = defaultedQueries[index]\n\n        if (opts) {\n          const queryObserver = new QueryObserver(client, opts)\n          if (shouldSuspend(opts, result)) {\n            return fetchOptimistic(opts, queryObserver, errorResetBoundary)\n          } else if (willFetch(result, isRestoring)) {\n            void fetchOptimistic(opts, queryObserver, errorResetBoundary)\n          }\n        }\n        return []\n      })\n    : []\n\n  if (suspensePromises.length > 0) {\n    throw Promise.all(suspensePromises)\n  }\n  const firstSingleResultWhichShouldThrow = optimisticResult.find(\n    (result, index) => {\n      const query = defaultedQueries[index]\n      return (\n        query &&\n        getHasError({\n          result,\n          errorResetBoundary,\n          throwOnError: query.throwOnError,\n          query: client.getQueryCache().get(query.queryHash),\n          suspense: query.suspense,\n        })\n      )\n    },\n  )\n\n  if (firstSingleResultWhichShouldThrow?.error) {\n    throw firstSingleResultWhichShouldThrow.error\n  }\n\n  return getCombinedResult(trackResult())\n}\n", "'use client'\nimport * as React from 'react'\n\nimport type { QueryClient } from '@tanstack/query-core'\n\nexport const QueryClientContext = React.createContext<QueryClient | undefined>(\n  undefined,\n)\n\nexport const useQueryClient = (queryClient?: QueryClient) => {\n  const client = React.useContext(QueryClientContext)\n\n  if (queryClient) {\n    return queryClient\n  }\n\n  if (!client) {\n    throw new Error('No QueryClient set, use QueryClientProvider to set one')\n  }\n\n  return client\n}\n\nexport type QueryClientProviderProps = {\n  client: QueryClient\n  children?: React.ReactNode\n}\n\nexport const QueryClientProvider = ({\n  client,\n  children,\n}: QueryClientProviderProps): React.JSX.Element => {\n  React.useEffect(() => {\n    client.mount()\n    return () => {\n      client.unmount()\n    }\n  }, [client])\n\n  return (\n    <QueryClientContext.Provider value={client}>\n      {children}\n    </QueryClientContext.Provider>\n  )\n}\n", "'use client'\nimport * as React from 'react'\n\nconst IsRestoringContext = React.createContext(false)\n\nexport const useIsRestoring = () => React.useContext(IsRestoringContext)\nexport const IsRestoringProvider = IsRestoringContext.Provider\n", "'use client'\nimport * as React from 'react'\n\n// CONTEXT\nexport type QueryErrorResetFunction = () => void\nexport type QueryErrorIsResetFunction = () => boolean\nexport type QueryErrorClearResetFunction = () => void\n\nexport interface QueryErrorResetBoundaryValue {\n  clearReset: QueryErrorClearResetFunction\n  isReset: QueryErrorIsResetFunction\n  reset: QueryErrorResetFunction\n}\n\nfunction createValue(): QueryErrorResetBoundaryValue {\n  let isReset = false\n  return {\n    clearReset: () => {\n      isReset = false\n    },\n    reset: () => {\n      isReset = true\n    },\n    isReset: () => {\n      return isReset\n    },\n  }\n}\n\nconst QueryErrorResetBoundaryContext = React.createContext(createValue())\n\n// HOOK\n\nexport const useQueryErrorResetBoundary = () =>\n  React.useContext(QueryErrorResetBoundaryContext)\n\n// COMPONENT\n\nexport type QueryErrorResetBoundaryFunction = (\n  value: QueryErrorResetBoundaryValue,\n) => React.ReactNode\n\nexport interface QueryErrorResetBoundaryProps {\n  children: QueryErrorResetBoundaryFunction | React.ReactNode\n}\n\nexport const QueryErrorResetBoundary = ({\n  children,\n}: QueryErrorResetBoundaryProps) => {\n  const [value] = React.useState(() => createValue())\n  return (\n    <QueryErrorResetBoundaryContext.Provider value={value}>\n      {typeof children === 'function' ? children(value) : children}\n    </QueryErrorResetBoundaryContext.Provider>\n  )\n}\n", "'use client'\nimport * as React from 'react'\nimport { shouldThrowError } from '@tanstack/query-core'\nimport type {\n  DefaultedQueryObserverOptions,\n  Query,\n  QueryKey,\n  QueryObserverResult,\n  ThrowOnError,\n} from '@tanstack/query-core'\nimport type { QueryErrorResetBoundaryValue } from './QueryErrorResetBoundary'\n\nexport const ensurePreventErrorBoundaryRetry = <\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) => {\n  if (\n    options.suspense ||\n    options.throwOnError ||\n    options.experimental_prefetchInRender\n  ) {\n    // Prevent retrying failed query if the error boundary has not been reset yet\n    if (!errorResetBoundary.isReset()) {\n      options.retryOnMount = false\n    }\n  }\n}\n\nexport const useClearResetErrorBoundary = (\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) => {\n  React.useEffect(() => {\n    errorResetBoundary.clearReset()\n  }, [errorResetBoundary])\n}\n\nexport const getHasError = <\n  TData,\n  TError,\n  TQueryFnData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>({\n  result,\n  errorResetBoundary,\n  throwOnError,\n  query,\n  suspense,\n}: {\n  result: QueryObserverResult<TData, TError>\n  errorResetBoundary: QueryErrorResetBoundaryValue\n  throwOnError: ThrowOnError<TQueryFnData, TError, TQueryData, TQueryKey>\n  query: Query<TQueryFnData, TError, TQueryData, TQueryKey> | undefined\n  suspense: boolean | undefined\n}) => {\n  return (\n    result.isError &&\n    !errorResetBoundary.isReset() &&\n    !result.isFetching &&\n    query &&\n    ((suspense && result.data === undefined) ||\n      shouldThrowError(throwOnError, [result.error, query]))\n  )\n}\n", "import type {\n  DefaultError,\n  DefaultedQueryObserverOptions,\n  Query,\n  QueryKey,\n  QueryObserver,\n  QueryObserverResult,\n} from '@tanstack/query-core'\nimport type { QueryErrorResetBoundaryValue } from './QueryErrorResetBoundary'\n\nexport const defaultThrowOnError = <\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  _error: TError,\n  query: Query<TQueryFnData, TError, TData, TQueryKey>,\n) => query.state.data === undefined\n\nexport const ensureSuspenseTimers = (\n  defaultedOptions: DefaultedQueryObserverOptions<any, any, any, any, any>,\n) => {\n  if (defaultedOptions.suspense) {\n    // Handle staleTime to ensure minimum 1000ms in Suspense mode\n    // This prevents unnecessary refetching when components remount after suspending\n\n    const clamp = (value: number | 'static' | undefined) =>\n      value === 'static' ? value : Math.max(value ?? 1000, 1000)\n\n    const originalStaleTime = defaultedOptions.staleTime\n    defaultedOptions.staleTime =\n      typeof originalStaleTime === 'function'\n        ? (...args) => clamp(originalStaleTime(...args))\n        : clamp(originalStaleTime)\n\n    if (typeof defaultedOptions.gcTime === 'number') {\n      defaultedOptions.gcTime = Math.max(defaultedOptions.gcTime, 1000)\n    }\n  }\n}\n\nexport const willFetch = (\n  result: QueryObserverResult<any, any>,\n  isRestoring: boolean,\n) => result.isLoading && result.isFetching && !isRestoring\n\nexport const shouldSuspend = (\n  defaultedOptions:\n    | DefaultedQueryObserverOptions<any, any, any, any, any>\n    | undefined,\n  result: QueryObserverResult<any, any>,\n) => defaultedOptions?.suspense && result.isPending\n\nexport const fetchOptimistic = <\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  defaultedOptions: DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  observer: QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  errorResetBoundary: QueryErrorResetBoundaryValue,\n) =>\n  observer.fetchOptimistic(defaultedOptions).catch(() => {\n    errorResetBoundary.clearReset()\n  })\n", "'use client'\nimport * as React from 'react'\n\nimport { isServer, noop, notifyManager } from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport { useQueryErrorResetBoundary } from './QueryErrorResetBoundary'\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary,\n} from './errorBoundaryUtils'\nimport { useIsRestoring } from './IsRestoringProvider'\nimport {\n  ensureSuspenseTimers,\n  fetchOptimistic,\n  shouldSuspend,\n  willFetch,\n} from './suspense'\nimport type {\n  QueryClient,\n  QueryKey,\n  QueryObserver,\n  QueryObserverResult,\n} from '@tanstack/query-core'\nimport type { UseBaseQueryOptions } from './types'\n\nexport function useBaseQuery<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n>(\n  options: UseBaseQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >,\n  Observer: typeof QueryObserver,\n  queryClient?: QueryClient,\n): QueryObserverResult<TData, TError> {\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof options !== 'object' || Array.isArray(options)) {\n      throw new Error(\n        'Bad argument type. Starting with v5, only the \"Object\" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object',\n      )\n    }\n  }\n\n  const isRestoring = useIsRestoring()\n  const errorResetBoundary = useQueryErrorResetBoundary()\n  const client = useQueryClient(queryClient)\n  const defaultedOptions = client.defaultQueryOptions(options)\n\n  ;(client.getDefaultOptions().queries as any)?._experimental_beforeQuery?.(\n    defaultedOptions,\n  )\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (!defaultedOptions.queryFn) {\n      console.error(\n        `[${defaultedOptions.queryHash}]: No queryFn was passed as an option, and no default queryFn was found. The queryFn parameter is only optional when using a default queryFn. More info here: https://tanstack.com/query/latest/docs/framework/react/guides/default-query-function`,\n      )\n    }\n  }\n\n  // Make sure results are optimistically set in fetching state before subscribing or updating options\n  defaultedOptions._optimisticResults = isRestoring\n    ? 'isRestoring'\n    : 'optimistic'\n\n  ensureSuspenseTimers(defaultedOptions)\n  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary)\n\n  useClearResetErrorBoundary(errorResetBoundary)\n\n  // this needs to be invoked before creating the Observer because that can create a cache entry\n  const isNewCacheEntry = !client\n    .getQueryCache()\n    .get(defaultedOptions.queryHash)\n\n  const [observer] = React.useState(\n    () =>\n      new Observer<TQueryFnData, TError, TData, TQueryData, TQueryKey>(\n        client,\n        defaultedOptions,\n      ),\n  )\n\n  // note: this must be called before useSyncExternalStore\n  const result = observer.getOptimisticResult(defaultedOptions)\n\n  const shouldSubscribe = !isRestoring && options.subscribed !== false\n  React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) => {\n        const unsubscribe = shouldSubscribe\n          ? observer.subscribe(notifyManager.batchCalls(onStoreChange))\n          : noop\n\n        // Update result to make sure we did not miss any query updates\n        // between creating the observer and subscribing to it.\n        observer.updateResult()\n\n        return unsubscribe\n      },\n      [observer, shouldSubscribe],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  React.useEffect(() => {\n    observer.setOptions(defaultedOptions)\n  }, [defaultedOptions, observer])\n\n  // Handle suspense\n  if (shouldSuspend(defaultedOptions, result)) {\n    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary)\n  }\n\n  // Handle error boundary\n  if (\n    getHasError({\n      result,\n      errorResetBoundary,\n      throwOnError: defaultedOptions.throwOnError,\n      query: client\n        .getQueryCache()\n        .get<\n          TQueryFnData,\n          TError,\n          TQueryData,\n          TQueryKey\n        >(defaultedOptions.queryHash),\n      suspense: defaultedOptions.suspense,\n    })\n  ) {\n    throw result.error\n  }\n\n  ;(client.getDefaultOptions().queries as any)?._experimental_afterQuery?.(\n    defaultedOptions,\n    result,\n  )\n\n  if (\n    defaultedOptions.experimental_prefetchInRender &&\n    !isServer &&\n    willFetch(result, isRestoring)\n  ) {\n    const promise = isNewCacheEntry\n      ? // Fetch immediately on render in order to ensure `.promise` is resolved even if the component is unmounted\n        fetchOptimistic(defaultedOptions, observer, errorResetBoundary)\n      : // subscribe to the \"cache promise\" so that we can finalize the currentThenable once data comes in\n        client.getQueryCache().get(defaultedOptions.queryHash)?.promise\n\n    promise?.catch(noop).finally(() => {\n      // `.updateResult()` will trigger `.#currentThenable` to finalize\n      observer.updateResult()\n    })\n  }\n\n  // Handle result property usage tracking\n  return !defaultedOptions.notifyOnChangeProps\n    ? observer.trackResult(result)\n    : result\n}\n", "'use client'\nimport { QueryObserver } from '@tanstack/query-core'\nimport { useBaseQuery } from './useBaseQuery'\nimport type {\n  DefaultError,\n  NoInfer,\n  QueryClient,\n  QueryKey,\n} from '@tanstack/query-core'\nimport type {\n  DefinedUseQueryResult,\n  UseQueryOptions,\n  UseQueryResult,\n} from './types'\nimport type {\n  DefinedInitialDataOptions,\n  UndefinedInitialDataOptions,\n} from './queryOptions'\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n  queryClient?: QueryClient,\n): DefinedUseQueryResult<NoInfer<TData>, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n  queryClient?: QueryClient,\n): UseQueryResult<NoInfer<TData>, TError>\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  queryClient?: QueryClient,\n): UseQueryResult<NoInfer<TData>, TError>\n\nexport function useQuery(options: UseQueryOptions, queryClient?: QueryClient) {\n  return useBaseQuery(options, QueryObserver, queryClient)\n}\n", "'use client'\nimport { QueryObserver, skipToken } from '@tanstack/query-core'\nimport { useBaseQuery } from './useBaseQuery'\nimport { defaultThrowOnError } from './suspense'\nimport type { UseSuspenseQueryOptions, UseSuspenseQueryResult } from './types'\nimport type { DefaultError, QueryClient, QueryKey } from '@tanstack/query-core'\n\nexport function useSuspenseQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UseSuspenseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  queryClient?: QueryClient,\n): UseSuspenseQueryResult<TData, TError> {\n  if (process.env.NODE_ENV !== 'production') {\n    if ((options.queryFn as any) === skipToken) {\n      console.error('skipToken is not allowed for useSuspenseQuery')\n    }\n  }\n\n  return useBaseQuery(\n    {\n      ...options,\n      enabled: true,\n      suspense: true,\n      throwOnError: defaultThrowOnError,\n      placeholderData: undefined,\n    },\n    QueryObserver,\n    queryClient,\n  ) as UseSuspenseQueryResult<TData, TError>\n}\n", "'use client'\nimport { InfiniteQueryObserver, skipToken } from '@tanstack/query-core'\nimport { useBaseQuery } from './useBaseQuery'\nimport { defaultThrowOnError } from './suspense'\nimport type {\n  DefaultError,\n  InfiniteData,\n  InfiniteQueryObserverSuccessResult,\n  QueryClient,\n  QueryKey,\n  QueryObserver,\n} from '@tanstack/query-core'\nimport type {\n  UseSuspenseInfiniteQueryOptions,\n  UseSuspenseInfiniteQueryResult,\n} from './types'\n\nexport function useSuspenseInfiniteQuery<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  options: UseSuspenseInfiniteQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  >,\n  queryClient?: QueryClient,\n): UseSuspenseInfiniteQueryResult<TData, TError> {\n  if (process.env.NODE_ENV !== 'production') {\n    if ((options.queryFn as any) === skipToken) {\n      console.error('skipToken is not allowed for useSuspenseInfiniteQuery')\n    }\n  }\n\n  return useBaseQuery(\n    {\n      ...options,\n      enabled: true,\n      suspense: true,\n      throwOnError: defaultThrowOnError,\n    },\n    InfiniteQueryObserver as typeof QueryObserver,\n    queryClient,\n  ) as InfiniteQueryObserverSuccessResult<TData, TError>\n}\n", "'use client'\nimport { skipToken } from '@tanstack/query-core'\nimport { useQueries } from './useQueries'\nimport { defaultThrowOnError } from './suspense'\nimport type { UseSuspenseQueryOptions, UseSuspenseQueryResult } from './types'\nimport type {\n  DefaultError,\n  QueryClient,\n  QueryFunction,\n  ThrowOnError,\n} from '@tanstack/query-core'\n\n// Avoid TS depth-limit error in case of large array literal\ntype MAXIMUM_DEPTH = 20\n\n// Widen the type of the symbol to enable type inference even if skipToken is not immutable.\ntype SkipTokenForUseQueries = symbol\n\ntype GetUseSuspenseQueryOptions<T> =\n  // Part 1: responsible for applying explicit type parameter to function arguments, if object { queryFnData: TQueryFnData, error: TError, data: TData }\n  T extends {\n    queryFnData: infer TQueryFnData\n    error?: infer TError\n    data: infer TData\n  }\n    ? UseSuspenseQueryOptions<TQueryFnData, TError, TData>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n      ? UseSuspenseQueryOptions<TQueryFnData, TError>\n      : T extends { data: infer TData; error?: infer TError }\n        ? UseSuspenseQueryOptions<unknown, TError, TData>\n        : // Part 2: responsible for applying explicit type parameter to function arguments, if tuple [TQueryFnData, TError, TData]\n          T extends [infer TQueryFnData, infer TError, infer TData]\n          ? UseSuspenseQueryOptions<TQueryFnData, TError, TData>\n          : T extends [infer TQueryFnData, infer TError]\n            ? UseSuspenseQueryOptions<TQueryFnData, TError>\n            : T extends [infer TQueryFnData]\n              ? UseSuspenseQueryOptions<TQueryFnData>\n              : // Part 3: responsible for inferring and enforcing type if no explicit parameter was provided\n                T extends {\n                    queryFn?:\n                      | QueryFunction<infer TQueryFnData, infer TQueryKey>\n                      | SkipTokenForUseQueries\n                    select?: (data: any) => infer TData\n                    throwOnError?: ThrowOnError<any, infer TError, any, any>\n                  }\n                ? UseSuspenseQueryOptions<\n                    TQueryFnData,\n                    TError,\n                    TData,\n                    TQueryKey\n                  >\n                : T extends {\n                      queryFn?:\n                        | QueryFunction<infer TQueryFnData, infer TQueryKey>\n                        | SkipTokenForUseQueries\n                      throwOnError?: ThrowOnError<any, infer TError, any, any>\n                    }\n                  ? UseSuspenseQueryOptions<\n                      TQueryFnData,\n                      TError,\n                      TQueryFnData,\n                      TQueryKey\n                    >\n                  : // Fallback\n                    UseSuspenseQueryOptions\n\ntype GetUseSuspenseQueryResult<T> =\n  // Part 1: responsible for mapping explicit type parameter to function result, if object\n  T extends { queryFnData: any; error?: infer TError; data: infer TData }\n    ? UseSuspenseQueryResult<TData, TError>\n    : T extends { queryFnData: infer TQueryFnData; error?: infer TError }\n      ? UseSuspenseQueryResult<TQueryFnData, TError>\n      : T extends { data: infer TData; error?: infer TError }\n        ? UseSuspenseQueryResult<TData, TError>\n        : // Part 2: responsible for mapping explicit type parameter to function result, if tuple\n          T extends [any, infer TError, infer TData]\n          ? UseSuspenseQueryResult<TData, TError>\n          : T extends [infer TQueryFnData, infer TError]\n            ? UseSuspenseQueryResult<TQueryFnData, TError>\n            : T extends [infer TQueryFnData]\n              ? UseSuspenseQueryResult<TQueryFnData>\n              : // Part 3: responsible for mapping inferred type to results, if no explicit parameter was provided\n                T extends {\n                    queryFn?:\n                      | QueryFunction<infer TQueryFnData, any>\n                      | SkipTokenForUseQueries\n                    select?: (data: any) => infer TData\n                    throwOnError?: ThrowOnError<any, infer TError, any, any>\n                  }\n                ? UseSuspenseQueryResult<\n                    unknown extends TData ? TQueryFnData : TData,\n                    unknown extends TError ? DefaultError : TError\n                  >\n                : T extends {\n                      queryFn?:\n                        | QueryFunction<infer TQueryFnData, any>\n                        | SkipTokenForUseQueries\n                      throwOnError?: ThrowOnError<any, infer TError, any, any>\n                    }\n                  ? UseSuspenseQueryResult<\n                      TQueryFnData,\n                      unknown extends TError ? DefaultError : TError\n                    >\n                  : // Fallback\n                    UseSuspenseQueryResult\n\n/**\n * SuspenseQueriesOptions reducer recursively unwraps function arguments to infer/enforce type param\n */\nexport type SuspenseQueriesOptions<\n  T extends Array<any>,\n  TResults extends Array<any> = [],\n  TDepth extends ReadonlyArray<number> = [],\n> = TDepth['length'] extends MAXIMUM_DEPTH\n  ? Array<UseSuspenseQueryOptions>\n  : T extends []\n    ? []\n    : T extends [infer Head]\n      ? [...TResults, GetUseSuspenseQueryOptions<Head>]\n      : T extends [infer Head, ...infer Tails]\n        ? SuspenseQueriesOptions<\n            [...Tails],\n            [...TResults, GetUseSuspenseQueryOptions<Head>],\n            [...TDepth, 1]\n          >\n        : Array<unknown> extends T\n          ? T\n          : // If T is *some* array but we couldn't assign unknown[] to it, then it must hold some known/homogenous type!\n            // use this to infer the param types in the case of Array.map() argument\n            T extends Array<\n                UseSuspenseQueryOptions<\n                  infer TQueryFnData,\n                  infer TError,\n                  infer TData,\n                  infer TQueryKey\n                >\n              >\n            ? Array<\n                UseSuspenseQueryOptions<TQueryFnData, TError, TData, TQueryKey>\n              >\n            : // Fallback\n              Array<UseSuspenseQueryOptions>\n\n/**\n * SuspenseQueriesResults reducer recursively maps type param to results\n */\nexport type SuspenseQueriesResults<\n  T extends Array<any>,\n  TResults extends Array<any> = [],\n  TDepth extends ReadonlyArray<number> = [],\n> = TDepth['length'] extends MAXIMUM_DEPTH\n  ? Array<UseSuspenseQueryResult>\n  : T extends []\n    ? []\n    : T extends [infer Head]\n      ? [...TResults, GetUseSuspenseQueryResult<Head>]\n      : T extends [infer Head, ...infer Tails]\n        ? SuspenseQueriesResults<\n            [...Tails],\n            [...TResults, GetUseSuspenseQueryResult<Head>],\n            [...TDepth, 1]\n          >\n        : { [K in keyof T]: GetUseSuspenseQueryResult<T[K]> }\n\nexport function useSuspenseQueries<\n  T extends Array<any>,\n  TCombinedResult = SuspenseQueriesResults<T>,\n>(\n  options: {\n    queries:\n      | readonly [...SuspenseQueriesOptions<T>]\n      | readonly [...{ [K in keyof T]: GetUseSuspenseQueryOptions<T[K]> }]\n    combine?: (result: SuspenseQueriesResults<T>) => TCombinedResult\n  },\n  queryClient?: QueryClient,\n): TCombinedResult\n\nexport function useSuspenseQueries<\n  T extends Array<any>,\n  TCombinedResult = SuspenseQueriesResults<T>,\n>(\n  options: {\n    queries: readonly [...SuspenseQueriesOptions<T>]\n    combine?: (result: SuspenseQueriesResults<T>) => TCombinedResult\n  },\n  queryClient?: QueryClient,\n): TCombinedResult\n\nexport function useSuspenseQueries(options: any, queryClient?: QueryClient) {\n  return useQueries(\n    {\n      ...options,\n      queries: options.queries.map((query: any) => {\n        if (process.env.NODE_ENV !== 'production') {\n          if (query.queryFn === skipToken) {\n            console.error('skipToken is not allowed for useSuspenseQueries')\n          }\n        }\n\n        return {\n          ...query,\n          suspense: true,\n          throwOnError: defaultThrowOnError,\n          enabled: true,\n          placeholderData: undefined,\n        }\n      }),\n    },\n    queryClient,\n  )\n}\n", "import { useQueryClient } from './QueryClientProvider'\nimport type { DefaultError, QueryClient, QueryKey } from '@tanstack/query-core'\nimport type { UsePrefetchQueryOptions } from './types'\n\nexport function usePrefetchQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UsePrefetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  queryClient?: QueryClient,\n) {\n  const client = useQueryClient(queryClient)\n\n  if (!client.getQueryState(options.queryKey)) {\n    client.prefetchQuery(options)\n  }\n}\n", "import { useQueryClient } from './QueryClientProvider'\nimport type {\n  DefaultError,\n  FetchInfiniteQueryOptions,\n  QueryClient,\n  QueryKey,\n} from '@tanstack/query-core'\n\nexport function usePrefetchInfiniteQuery<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  options: FetchInfiniteQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  >,\n  queryClient?: QueryClient,\n) {\n  const client = useQueryClient(queryClient)\n\n  if (!client.getQueryState(options.queryKey)) {\n    client.prefetchInfiniteQuery(options)\n  }\n}\n", "import type {\n  DataTag,\n  DefaultError,\n  InitialDataFunction,\n  NonUndefinedGuard,\n  OmitKeyof,\n  QueryFunction,\n  QueryKey,\n  SkipToken,\n} from '@tanstack/query-core'\nimport type { UseQueryOptions } from './types'\n\nexport type UndefinedInitialDataOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = UseQueryOptions<TQueryFnData, TError, TData, TQueryKey> & {\n  initialData?:\n    | undefined\n    | InitialDataFunction<NonUndefinedGuard<TQueryFnData>>\n    | NonUndefinedGuard<TQueryFnData>\n}\n\nexport type UnusedSkipTokenOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = OmitKeyof<\n  UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  'queryFn'\n> & {\n  queryFn?: Exclude<\n    UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>['queryFn'],\n    SkipToken | undefined\n  >\n}\n\nexport type DefinedInitialDataOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = Omit<UseQueryOptions<TQueryFnData, TError, TData, TQueryKey>, 'queryFn'> & {\n  initialData:\n    | NonUndefinedGuard<TQueryFnData>\n    | (() => NonUndefinedGuard<TQueryFnData>)\n  queryFn?: QueryFunction<TQueryFnData, TQueryKey>\n}\n\nexport function queryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n): DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey> & {\n  queryKey: DataTag<TQueryKey, TQueryFnData, TError>\n}\n\nexport function queryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UnusedSkipTokenOptions<TQueryFnData, TError, TData, TQueryKey>,\n): UnusedSkipTokenOptions<TQueryFnData, TError, TData, TQueryKey> & {\n  queryKey: DataTag<TQueryKey, TQueryFnData, TError>\n}\n\nexport function queryOptions<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n): UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey> & {\n  queryKey: DataTag<TQueryKey, TQueryFnData, TError>\n}\n\nexport function queryOptions(options: unknown) {\n  return options\n}\n", "import type {\n  DataTag,\n  DefaultError,\n  InfiniteData,\n  InitialDataFunction,\n  NonUndefinedGuard,\n  OmitKeyof,\n  QueryKey,\n  SkipToken,\n} from '@tanstack/query-core'\nimport type { UseInfiniteQueryOptions } from './types'\n\nexport type UndefinedInitialDataInfiniteOptions<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = UseInfiniteQueryOptions<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey,\n  TPageParam\n> & {\n  initialData?:\n    | undefined\n    | NonUndefinedGuard<InfiniteData<TQueryFnData, TPageParam>>\n    | InitialDataFunction<\n        NonUndefinedGuard<InfiniteData<TQueryFnData, TPageParam>>\n      >\n}\n\nexport type UnusedSkipTokenInfiniteOptions<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = OmitKeyof<\n  UseInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>,\n  'queryFn'\n> & {\n  queryFn?: Exclude<\n    UseInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >['queryFn'],\n    SkipToken | undefined\n  >\n}\n\nexport type DefinedInitialDataInfiniteOptions<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> = UseInfiniteQueryOptions<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey,\n  TPageParam\n> & {\n  initialData:\n    | NonUndefinedGuard<InfiniteData<TQueryFnData, TPageParam>>\n    | (() => NonUndefinedGuard<InfiniteData<TQueryFnData, TPageParam>>)\n    | undefined\n}\n\nexport function infiniteQueryOptions<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  options: DefinedInitialDataInfiniteOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  >,\n): DefinedInitialDataInfiniteOptions<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey,\n  TPageParam\n> & {\n  queryKey: DataTag<TQueryKey, InfiniteData<TQueryFnData>, TError>\n}\n\nexport function infiniteQueryOptions<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  options: UnusedSkipTokenInfiniteOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  >,\n): UnusedSkipTokenInfiniteOptions<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey,\n  TPageParam\n> & {\n  queryKey: DataTag<TQueryKey, InfiniteData<TQueryFnData>, TError>\n}\n\nexport function infiniteQueryOptions<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  options: UndefinedInitialDataInfiniteOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  >,\n): UndefinedInitialDataInfiniteOptions<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey,\n  TPageParam\n> & {\n  queryKey: DataTag<TQueryKey, InfiniteData<TQueryFnData>, TError>\n}\n\nexport function infiniteQueryOptions(options: unknown) {\n  return options\n}\n", "'use client'\nimport * as React from 'react'\nimport {\n  MutationObserver,\n  noop,\n  notifyManager,\n  shouldThrowError,\n} from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport type {\n  UseMutateFunction,\n  UseMutationOptions,\n  UseMutationResult,\n} from './types'\nimport type { DefaultError, QueryClient } from '@tanstack/query-core'\n\n// HOOK\n\nexport function useMutation<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = void,\n  TContext = unknown,\n>(\n  options: UseMutationOptions<TData, TError, TVariables, TContext>,\n  queryClient?: QueryClient,\n): UseMutationResult<TData, TError, TVariables, TContext> {\n  const client = useQueryClient(queryClient)\n\n  const [observer] = React.useState(\n    () =>\n      new MutationObserver<TData, TError, TVariables, TContext>(\n        client,\n        options,\n      ),\n  )\n\n  React.useEffect(() => {\n    observer.setOptions(options)\n  }, [observer, options])\n\n  const result = React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) =>\n        observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer],\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult(),\n  )\n\n  const mutate = React.useCallback<\n    UseMutateFunction<TData, TError, TVariables, TContext>\n  >(\n    (variables, mutateOptions) => {\n      observer.mutate(variables, mutateOptions).catch(noop)\n    },\n    [observer],\n  )\n\n  if (\n    result.error &&\n    shouldThrowError(observer.options.throwOnError, [result.error])\n  ) {\n    throw result.error\n  }\n\n  return { ...result, mutate, mutateAsync: result.mutate }\n}\n", "'use client'\nimport { InfiniteQueryObserver } from '@tanstack/query-core'\nimport { useBaseQuery } from './useBaseQuery'\nimport type {\n  DefaultError,\n  InfiniteData,\n  QueryClient,\n  QueryKey,\n  QueryObserver,\n} from '@tanstack/query-core'\nimport type {\n  DefinedUseInfiniteQueryResult,\n  UseInfiniteQueryOptions,\n  UseInfiniteQueryResult,\n} from './types'\nimport type {\n  DefinedInitialDataInfiniteOptions,\n  UndefinedInitialDataInfiniteOptions,\n} from './infiniteQueryOptions'\n\nexport function useInfiniteQuery<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  options: DefinedInitialDataInfiniteOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  >,\n  queryClient?: QueryClient,\n): DefinedUseInfiniteQueryResult<TData, TError>\n\nexport function useInfiniteQuery<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  options: UndefinedInitialDataInfiniteOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  >,\n  queryClient?: QueryClient,\n): UseInfiniteQueryResult<TData, TError>\n\nexport function useInfiniteQuery<\n  TQueryFnData,\n  TError = DefaultError,\n  TData = InfiniteData<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n>(\n  options: UseInfiniteQueryOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryKey,\n    TPageParam\n  >,\n  queryClient?: QueryClient,\n): UseInfiniteQueryResult<TData, TError>\n\nexport function useInfiniteQuery(\n  options: UseInfiniteQueryOptions,\n  queryClient?: QueryClient,\n) {\n  return useBaseQuery(\n    options,\n    InfiniteQueryObserver as typeof QueryObserver,\n    queryClient,\n  )\n}\n", "import type { InvertKeyValue, ValueOf } from '../types';\n\n// reference: https://www.jsonrpc.org/specification\n\n/**\n * JSON-RPC 2.0 Error codes\n *\n * `-32000` to `-32099` are reserved for implementation-defined server-errors.\n * For tRPC we're copying the last digits of HTTP 4XX errors.\n */\nexport const TRPC_ERROR_CODES_BY_KEY = {\n  /**\n   * Invalid JSON was received by the server.\n   * An error occurred on the server while parsing the JSON text.\n   */\n  PARSE_ERROR: -32700,\n  /**\n   * The JSON sent is not a valid Request object.\n   */\n  BAD_REQUEST: -32600, // 400\n\n  // Internal JSON-RPC error\n  INTERNAL_SERVER_ERROR: -32603, // 500\n  NOT_IMPLEMENTED: -32603, // 501\n  BAD_GATEWAY: -32603, // 502\n  SERVICE_UNAVAILABLE: -32603, // 503\n  GATEWAY_TIMEOUT: -32603, // 504\n\n  // Implementation specific errors\n  UNAUTHORIZED: -32001, // 401\n  PAYMENT_REQUIRED: -32002, // 402\n  FORBIDDEN: -32003, // 403\n  NOT_FOUND: -32004, // 404\n  METHOD_NOT_SUPPORTED: -32005, // 405\n  TIMEOUT: -32008, // 408\n  CONFLICT: -32009, // 409\n  PRECONDITION_FAILED: -32012, // 412\n  PAYLOAD_TOO_LARGE: -32013, // 413\n  UNSUPPORTED_MEDIA_TYPE: -32015, // 415\n  UNPROCESSABLE_CONTENT: -32022, // 422\n  TOO_MANY_REQUESTS: -32029, // 429\n  CLIENT_CLOSED_REQUEST: -32099, // 499\n} as const;\n\n// pure\nexport const TRPC_ERROR_CODES_BY_NUMBER: InvertKeyValue<\n  typeof TRPC_ERROR_CODES_BY_KEY\n> = {\n  [-32700]: 'PARSE_ERROR',\n  [-32600]: 'BAD_REQUEST',\n  [-32603]: 'INTERNAL_SERVER_ERROR',\n  [-32001]: 'UNAUTHORIZED',\n  [-32002]: 'PAYMENT_REQUIRED',\n  [-32003]: 'FORBIDDEN',\n  [-32004]: 'NOT_FOUND',\n  [-32005]: 'METHOD_NOT_SUPPORTED',\n  [-32008]: 'TIMEOUT',\n  [-32009]: 'CONFLICT',\n  [-32012]: 'PRECONDITION_FAILED',\n  [-32013]: 'PAYLOAD_TOO_LARGE',\n  [-32015]: 'UNSUPPORTED_MEDIA_TYPE',\n  [-32022]: 'UNPROCESSABLE_CONTENT',\n  [-32029]: 'TOO_MANY_REQUESTS',\n  [-32099]: 'CLIENT_CLOSED_REQUEST',\n};\n\nexport type TRPC_ERROR_CODE_NUMBER = ValueOf<typeof TRPC_ERROR_CODES_BY_KEY>;\nexport type TRPC_ERROR_CODE_KEY = keyof typeof TRPC_ERROR_CODES_BY_KEY;\n\n/**\n * tRPC error codes that are considered retryable\n * With out of the box SSE, the client will reconnect when these errors are encountered\n */\nexport const retryableRpcCodes: TRPC_ERROR_CODE_NUMBER[] = [\n  TRPC_ERROR_CODES_BY_KEY.BAD_GATEWAY,\n  TRPC_ERROR_CODES_BY_KEY.SERVICE_UNAVAILABLE,\n  TRPC_ERROR_CODES_BY_KEY.GATEWAY_TIMEOUT,\n  TRPC_ERROR_CODES_BY_KEY.INTERNAL_SERVER_ERROR,\n];\n", "/** @internal */\nexport type UnsetMarker = 'unsetMarker' & {\n  __brand: 'unsetMarker';\n};\n\n/**\n * Ensures there are no duplicate keys when building a procedure.\n * @internal\n */\nexport function mergeWithoutOverrides<TType extends Record<string, unknown>>(\n  obj1: TType,\n  ...objs: Partial<TType>[]\n): TType {\n  const newObj: TType = Object.assign(Object.create(null), obj1);\n\n  for (const overrides of objs) {\n    for (const key in overrides) {\n      if (key in newObj && newObj[key] !== overrides[key]) {\n        throw new Error(`Duplicate key ${key}`);\n      }\n      newObj[key as keyof TType] = overrides[key] as TType[keyof TType];\n    }\n  }\n  return newObj;\n}\n\n/**\n * Check that value is object\n * @internal\n */\nexport function isObject(value: unknown): value is Record<string, unknown> {\n  return !!value && !Array.isArray(value) && typeof value === 'object';\n}\n\ntype AnyFn = ((...args: any[]) => unknown) & Record<keyof any, unknown>;\nexport function isFunction(fn: unknown): fn is AnyFn {\n  return typeof fn === 'function';\n}\n\n/**\n * Create an object without inheriting anything from `Object.prototype`\n * @internal\n */\nexport function omitPrototype<TObj extends Record<string, unknown>>(\n  obj: TObj,\n): TObj {\n  return Object.assign(Object.create(null), obj);\n}\n\nconst asyncIteratorsSupported =\n  typeof Symbol === 'function' && !!Symbol.asyncIterator;\n\nexport function isAsyncIterable<TValue>(\n  value: unknown,\n): value is AsyncIterable<TValue> {\n  return (\n    asyncIteratorsSupported && isObject(value) && Symbol.asyncIterator in value\n  );\n}\n\n/**\n * Run an IIFE\n */\nexport const run = <TValue>(fn: () => TValue): TValue => fn();\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport function noop(): void {}\n\nexport function identity<T>(it: T): T {\n  return it;\n}\n\n/**\n * Generic runtime assertion function. Throws, if the condition is not `true`.\n *\n * Can be used as a slightly less dangerous variant of type assertions. Code\n * mistakes would be revealed at runtime then (hopefully during testing).\n */\nexport function assert(\n  condition: boolean,\n  msg = 'no additional info',\n): asserts condition {\n  if (!condition) {\n    throw new Error(`AssertionError: ${msg}`);\n  }\n}\n\nexport function sleep(ms = 0): Promise<void> {\n  return new Promise<void>((res) => setTimeout(res, ms));\n}\n\n/**\n * Ponyfill for\n * [`AbortSignal.any`](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/any_static).\n */\nexport function abortSignalsAnyPonyfill(signals: AbortSignal[]): AbortSignal {\n  if (typeof AbortSignal.any === 'function') {\n    return AbortSignal.any(signals);\n  }\n\n  const ac = new AbortController();\n\n  for (const signal of signals) {\n    if (signal.aborted) {\n      trigger();\n      break;\n    }\n    signal.addEventListener('abort', trigger, { once: true });\n  }\n\n  return ac.signal;\n\n  function trigger() {\n    ac.abort();\n    for (const signal of signals) {\n      signal.removeEventListener('abort', trigger);\n    }\n  }\n}\n", "interface ProxyCallbackOptions {\n  path: readonly string[];\n  args: readonly unknown[];\n}\ntype ProxyCallback = (opts: ProxyCallbackOptions) => unknown;\n\nconst noop = () => {\n  // noop\n};\n\nconst freezeIfAvailable = (obj: object) => {\n  if (Object.freeze) {\n    Object.freeze(obj);\n  }\n};\n\nfunction createInnerProxy(\n  callback: ProxyCallback,\n  path: readonly string[],\n  memo: Record<string, unknown>,\n) {\n  const cacheKey = path.join('.');\n\n  memo[cacheKey] ??= new Proxy(noop, {\n    get(_obj, key) {\n      if (typeof key !== 'string' || key === 'then') {\n        // special case for if the proxy is accidentally treated\n        // like a PromiseLike (like in `Promise.resolve(proxy)`)\n        return undefined;\n      }\n      return createInnerProxy(callback, [...path, key], memo);\n    },\n    apply(_1, _2, args) {\n      const lastOfPath = path[path.length - 1];\n\n      let opts = { args, path };\n      // special handling for e.g. `trpc.hello.call(this, 'there')` and `trpc.hello.apply(this, ['there'])\n      if (lastOfPath === 'call') {\n        opts = {\n          args: args.length >= 2 ? [args[1]] : [],\n          path: path.slice(0, -1),\n        };\n      } else if (lastOfPath === 'apply') {\n        opts = {\n          args: args.length >= 2 ? args[1] : [],\n          path: path.slice(0, -1),\n        };\n      }\n      freezeIfAvailable(opts.args);\n      freezeIfAvailable(opts.path);\n      return callback(opts);\n    },\n  });\n\n  return memo[cacheKey];\n}\n\n/**\n * Creates a proxy that calls the callback with the path and arguments\n *\n * @internal\n */\nexport const createRecursiveProxy = <TFaux = unknown>(\n  callback: ProxyCallback,\n): TFaux => createInnerProxy(callback, [], Object.create(null)) as TFaux;\n\n/**\n * Used in place of `new Proxy` where each handler will map 1 level deep to another value.\n *\n * @internal\n */\nexport const createFlatProxy = <TFaux>(\n  callback: (path: keyof TFaux) => any,\n): TFaux => {\n  return new Proxy(noop, {\n    get(_obj, name) {\n      if (name === 'then') {\n        // special case for if the proxy is accidentally treated\n        // like a PromiseLike (like in `Promise.resolve(proxy)`)\n        return undefined;\n      }\n      return callback(name as any);\n    },\n  }) as TFaux;\n};\n", "import type { TRPCError } from '../error/TRPCError';\nimport type { TRPC_ERROR_CODES_BY_KEY, TRPCResponse } from '../rpc';\nimport { TRPC_ERROR_CODES_BY_NUMBER } from '../rpc';\nimport type { InvertKeyValue, ValueOf } from '../types';\nimport { isObject } from '../utils';\n\nexport const JSONRPC2_TO_HTTP_CODE: Record<\n  keyof typeof TRPC_ERROR_CODES_BY_KEY,\n  number\n> = {\n  PARSE_ERROR: 400,\n  BAD_REQUEST: 400,\n  UNAUTHORIZED: 401,\n  PAYMENT_REQUIRED: 402,\n  FORBIDDEN: 403,\n  NOT_FOUND: 404,\n  METHOD_NOT_SUPPORTED: 405,\n  TIMEOUT: 408,\n  CONFLICT: 409,\n  PRECONDITION_FAILED: 412,\n  PAYLOAD_TOO_LARGE: 413,\n  UNSUPPORTED_MEDIA_TYPE: 415,\n  UNPROCESSABLE_CONTENT: 422,\n  TOO_MANY_REQUESTS: 429,\n  CLIENT_CLOSED_REQUEST: 499,\n  INTERNAL_SERVER_ERROR: 500,\n  NOT_IMPLEMENTED: 501,\n  BAD_GATEWAY: 502,\n  SERVICE_UNAVAILABLE: 503,\n  GATEWAY_TIMEOUT: 504,\n};\n\nexport const HTTP_CODE_TO_JSONRPC2: InvertKeyValue<\n  typeof JSONRPC2_TO_HTTP_CODE\n> = {\n  400: 'BAD_REQUEST',\n  401: 'UNAUTHORIZED',\n  402: 'PAYMENT_REQUIRED',\n  403: 'FORBIDDEN',\n  404: 'NOT_FOUND',\n  405: 'METHOD_NOT_SUPPORTED',\n  408: 'TIMEOUT',\n  409: 'CONFLICT',\n  412: 'PRECONDITION_FAILED',\n  413: 'PAYLOAD_TOO_LARGE',\n  415: 'UNSUPPORTED_MEDIA_TYPE',\n  422: 'UNPROCESSABLE_CONTENT',\n  429: 'TOO_MANY_REQUESTS',\n  499: 'CLIENT_CLOSED_REQUEST',\n  500: 'INTERNAL_SERVER_ERROR',\n  501: 'NOT_IMPLEMENTED',\n  502: 'BAD_GATEWAY',\n  503: 'SERVICE_UNAVAILABLE',\n  504: 'GATEWAY_TIMEOUT',\n} as const;\n\nexport function getStatusCodeFromKey(\n  code: keyof typeof TRPC_ERROR_CODES_BY_KEY,\n) {\n  return JSONRPC2_TO_HTTP_CODE[code] ?? 500;\n}\n\nexport function getStatusKeyFromCode(\n  code: keyof typeof HTTP_CODE_TO_JSONRPC2,\n): ValueOf<typeof HTTP_CODE_TO_JSONRPC2> {\n  return HTTP_CODE_TO_JSONRPC2[code] ?? 'INTERNAL_SERVER_ERROR';\n}\n\nexport function getHTTPStatusCode(json: TRPCResponse | TRPCResponse[]) {\n  const arr = Array.isArray(json) ? json : [json];\n  const httpStatuses = new Set<number>(\n    arr.map((res) => {\n      if ('error' in res && isObject(res.error.data)) {\n        if (typeof res.error.data?.['httpStatus'] === 'number') {\n          return res.error.data['httpStatus'];\n        }\n        const code = TRPC_ERROR_CODES_BY_NUMBER[res.error.code];\n        return getStatusCodeFromKey(code);\n      }\n      return 200;\n    }),\n  );\n\n  if (httpStatuses.size !== 1) {\n    return 207;\n  }\n\n  const httpStatus = httpStatuses.values().next().value;\n\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  return httpStatus!;\n}\n\nexport function getHTTPStatusCodeFromError(error: TRPCError) {\n  return getStatusCodeFromKey(error.code);\n}\n", "function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return module.exports = _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports, _typeof(o);\n}\nmodule.exports = _typeof, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "var _typeof = require(\"./typeof.js\")[\"default\"];\nfunction toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nmodule.exports = toPrimitive, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "var _typeof = require(\"./typeof.js\")[\"default\"];\nvar toPrimitive = require(\"./toPrimitive.js\");\nfunction toPropertyKey(t) {\n  var i = toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nmodule.exports = toPropertyKey, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "var toPropertyKey = require(\"./toPropertyKey.js\");\nfunction _defineProperty(e, r, t) {\n  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nmodule.exports = _defineProperty, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "var defineProperty = require(\"./defineProperty.js\");\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nmodule.exports = _objectSpread2, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "import { getHTTPStatusCodeFromError } from '../http/getHTTPStatusCode';\nimport type { ProcedureType } from '../procedure';\nimport type { AnyRootTypes, RootConfig } from '../rootConfig';\nimport { TRPC_ERROR_CODES_BY_KEY } from '../rpc';\nimport type { DefaultErrorShape } from './formatter';\nimport type { TRPCError } from './TRPCError';\n\n/**\n * @internal\n */\nexport function getErrorShape<TRoot extends AnyRootTypes>(opts: {\n  config: RootConfig<TRoot>;\n  error: TRPCError;\n  type: ProcedureType | 'unknown';\n  path: string | undefined;\n  input: unknown;\n  ctx: TRoot['ctx'] | undefined;\n}): TRoot['errorShape'] {\n  const { path, error, config } = opts;\n  const { code } = opts.error;\n  const shape: DefaultErrorShape = {\n    message: error.message,\n    code: TRPC_ERROR_CODES_BY_KEY[code],\n    data: {\n      code,\n      httpStatus: getHTTPStatusCodeFromError(error),\n    },\n  };\n  if (config.isDev && typeof opts.error.stack === 'string') {\n    shape.data.stack = opts.error.stack;\n  }\n  if (typeof path === 'string') {\n    shape.data.path = path;\n  }\n  return config.errorFormatter({ ...opts, shape });\n}\n", "import type { ProcedureType } from '../procedure';\nimport type {\n  TRPC_ERROR_CODE_KEY,\n  TRPC_ERROR_CODE_NUMBER,\n  TRPCErrorShape,\n} from '../rpc';\nimport type { TRPCError } from './TRPCError';\n\n/**\n * @internal\n */\nexport type ErrorFormatter<TContext, TShape extends TRPCErrorShape> = (opts: {\n  error: TRPCError;\n  type: ProcedureType | 'unknown';\n  path: string | undefined;\n  input: unknown;\n  ctx: TContext | undefined;\n  shape: DefaultErrorShape;\n}) => TShape;\n\n/**\n * @internal\n */\nexport type DefaultErrorData = {\n  code: TRPC_ERROR_CODE_KEY;\n  httpStatus: number;\n  /**\n   * Path to the procedure that threw the error\n   */\n  path?: string;\n  /**\n   * Stack trace of the error (only in development)\n   */\n  stack?: string;\n};\n\n/**\n * @internal\n */\nexport interface DefaultErrorShape extends TRPCErrorShape<DefaultErrorData> {\n  message: string;\n  code: TRPC_ERROR_CODE_NUMBER;\n}\n\nexport const defaultFormatter: ErrorFormatter<any, any> = ({ shape }) => {\n  return shape;\n};\n", "import type { TRPC_ERROR_CODE_KEY } from '../rpc/codes';\nimport { isObject } from '../utils';\n\nclass UnknownCauseError extends Error {\n  [key: string]: unknown;\n}\nexport function getCauseFromUnknown(cause: unknown): Error | undefined {\n  if (cause instanceof Error) {\n    return cause;\n  }\n\n  const type = typeof cause;\n  if (type === 'undefined' || type === 'function' || cause === null) {\n    return undefined;\n  }\n\n  // Primitive types just get wrapped in an error\n  if (type !== 'object') {\n    // eslint-disable-next-line @typescript-eslint/no-base-to-string\n    return new Error(String(cause));\n  }\n\n  // If it's an object, we'll create a synthetic error\n  if (isObject(cause)) {\n    return Object.assign(new UnknownCauseError(), cause);\n  }\n\n  return undefined;\n}\n\nexport function getTRPCErrorFromUnknown(cause: unknown): TRPCError {\n  if (cause instanceof TRPCError) {\n    return cause;\n  }\n  if (cause instanceof Error && cause.name === 'TRPCError') {\n    // https://github.com/trpc/trpc/pull/4848\n    return cause as TRPCError;\n  }\n\n  const trpcError = new TRPCError({\n    code: 'INTERNAL_SERVER_ERROR',\n    cause,\n  });\n\n  // Inherit stack from error\n  if (cause instanceof Error && cause.stack) {\n    trpcError.stack = cause.stack;\n  }\n\n  return trpcError;\n}\n\nexport class TRPCError extends Error {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore override doesn't work in all environments due to \"This member cannot have an 'override' modifier because it is not declared in the base class 'Error'\"\n  public override readonly cause?: Error;\n  public readonly code;\n\n  constructor(opts: {\n    message?: string;\n    code: TRPC_ERROR_CODE_KEY;\n    cause?: unknown;\n  }) {\n    const cause = getCauseFromUnknown(opts.cause);\n    const message = opts.message ?? cause?.message ?? opts.code;\n\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore https://github.com/tc39/proposal-error-cause\n    super(message, { cause });\n\n    this.code = opts.code;\n    this.name = 'TRPCError';\n    this.cause ??= cause;\n  }\n}\n", "import type { AnyRootTypes, RootConfig } from './rootConfig';\nimport type { AnyRouter, inferRouterError } from './router';\nimport type {\n  TRPCResponse,\n  TRPCResponseMessage,\n  TRPCResultMessage,\n} from './rpc';\nimport { isObject } from './utils';\n\n/**\n * @public\n */\nexport interface DataTransformer {\n  serialize: (object: any) => any;\n  deserialize: (object: any) => any;\n}\n\ninterface InputDataTransformer extends DataTransformer {\n  /**\n   * This function runs **on the client** before sending the data to the server.\n   */\n  serialize: (object: any) => any;\n  /**\n   * This function runs **on the server** to transform the data before it is passed to the resolver\n   */\n  deserialize: (object: any) => any;\n}\n\ninterface OutputDataTransformer extends DataTransformer {\n  /**\n   * This function runs **on the server** before sending the data to the client.\n   */\n  serialize: (object: any) => any;\n  /**\n   * This function runs **only on the client** to transform the data sent from the server.\n   */\n  deserialize: (object: any) => any;\n}\n\n/**\n * @public\n */\nexport interface CombinedDataTransformer {\n  /**\n   * Specify how the data sent from the client to the server should be transformed.\n   */\n  input: InputDataTransformer;\n  /**\n   * Specify how the data sent from the server to the client should be transformed.\n   */\n  output: OutputDataTransformer;\n}\n\n/**\n * @public\n */\nexport type CombinedDataTransformerClient = {\n  input: Pick<CombinedDataTransformer['input'], 'serialize'>;\n  output: Pick<CombinedDataTransformer['output'], 'deserialize'>;\n};\n\n/**\n * @public\n */\nexport type DataTransformerOptions = CombinedDataTransformer | DataTransformer;\n\n/**\n * @internal\n */\nexport function getDataTransformer(\n  transformer: DataTransformerOptions,\n): CombinedDataTransformer {\n  if ('input' in transformer) {\n    return transformer;\n  }\n  return { input: transformer, output: transformer };\n}\n\n/**\n * @internal\n */\nexport const defaultTransformer: CombinedDataTransformer = {\n  input: { serialize: (obj) => obj, deserialize: (obj) => obj },\n  output: { serialize: (obj) => obj, deserialize: (obj) => obj },\n};\n\nfunction transformTRPCResponseItem<\n  TResponseItem extends TRPCResponse | TRPCResponseMessage,\n>(config: RootConfig<AnyRootTypes>, item: TResponseItem): TResponseItem {\n  if ('error' in item) {\n    return {\n      ...item,\n      error: config.transformer.output.serialize(item.error),\n    };\n  }\n\n  if ('data' in item.result) {\n    return {\n      ...item,\n      result: {\n        ...item.result,\n        data: config.transformer.output.serialize(item.result.data),\n      },\n    };\n  }\n\n  return item;\n}\n\n/**\n * Takes a unserialized `TRPCResponse` and serializes it with the router's transformers\n **/\nexport function transformTRPCResponse<\n  TResponse extends\n    | TRPCResponse\n    | TRPCResponse[]\n    | TRPCResponseMessage\n    | TRPCResponseMessage[],\n>(config: RootConfig<AnyRootTypes>, itemOrItems: TResponse) {\n  return Array.isArray(itemOrItems)\n    ? itemOrItems.map((item) => transformTRPCResponseItem(config, item))\n    : transformTRPCResponseItem(config, itemOrItems);\n}\n\n// FIXME:\n// - the generics here are probably unnecessary\n// - the RPC-spec could probably be simplified to combine HTTP + WS\n/** @internal */\nfunction transformResultInner<TRouter extends AnyRouter, TOutput>(\n  response:\n    | TRPCResponse<TOutput, inferRouterError<TRouter>>\n    | TRPCResponseMessage<TOutput, inferRouterError<TRouter>>,\n  transformer: DataTransformer,\n) {\n  if ('error' in response) {\n    const error = transformer.deserialize(\n      response.error,\n    ) as inferRouterError<TRouter>;\n    return {\n      ok: false,\n      error: {\n        ...response,\n        error,\n      },\n    } as const;\n  }\n\n  const result = {\n    ...response.result,\n    ...((!response.result.type || response.result.type === 'data') && {\n      type: 'data',\n      data: transformer.deserialize(response.result.data),\n    }),\n  } as TRPCResultMessage<TOutput>['result'];\n  return { ok: true, result } as const;\n}\n\nclass TransformResultError extends Error {\n  constructor() {\n    super('Unable to transform response from server');\n  }\n}\n\n/**\n * Transforms and validates that the result is a valid TRPCResponse\n * @internal\n */\nexport function transformResult<TRouter extends AnyRouter, TOutput>(\n  response:\n    | TRPCResponse<TOutput, inferRouterError<TRouter>>\n    | TRPCResponseMessage<TOutput, inferRouterError<TRouter>>,\n  transformer: DataTransformer,\n): ReturnType<typeof transformResultInner> {\n  let result: ReturnType<typeof transformResultInner>;\n  try {\n    // Use the data transformers on the JSON-response\n    result = transformResultInner(response, transformer);\n  } catch {\n    throw new TransformResultError();\n  }\n\n  // check that output of the transformers is a valid TRPCResponse\n  if (\n    !result.ok &&\n    (!isObject(result.error.error) ||\n      typeof result.error.error['code'] !== 'number')\n  ) {\n    throw new TransformResultError();\n  }\n  if (result.ok && !isObject(result.result)) {\n    throw new TransformResultError();\n  }\n  return result;\n}\n", "import type { Observable } from '../observable';\nimport { createRecursiveProxy } from './createProxy';\nimport { defaultFormatter } from './error/formatter';\nimport { getTRPCErrorFromUnknown, TRPCError } from './error/TRPCError';\nimport type {\n  AnyProcedure,\n  ErrorHandlerOptions,\n  inferProcedureInput,\n  inferProcedureOutput,\n  LegacyObservableSubscriptionProcedure,\n} from './procedure';\nimport type { ProcedureCallOptions } from './procedureBuilder';\nimport type { AnyRootTypes, RootConfig } from './rootConfig';\nimport { defaultTransformer } from './transformer';\nimport type { MaybePromise, ValueOf } from './types';\nimport {\n  isFunction,\n  isObject,\n  mergeWithoutOverrides,\n  omitPrototype,\n} from './utils';\n\nexport interface RouterRecord {\n  [key: string]: AnyProcedure | RouterRecord;\n}\n\ntype DecorateProcedure<TProcedure extends AnyProcedure> = (\n  input: inferProcedureInput<TProcedure>,\n) => Promise<\n  TProcedure['_def']['type'] extends 'subscription'\n    ? TProcedure extends LegacyObservableSubscriptionProcedure<any>\n      ? Observable<inferProcedureOutput<TProcedure>, TRPCError>\n      : inferProcedureOutput<TProcedure>\n    : inferProcedureOutput<TProcedure>\n>;\n\n/**\n * @internal\n */\nexport type DecorateRouterRecord<TRecord extends RouterRecord> = {\n  [TKey in keyof TRecord]: TRecord[TKey] extends infer $Value\n    ? $Value extends AnyProcedure\n      ? DecorateProcedure<$Value>\n      : $Value extends RouterRecord\n        ? DecorateRouterRecord<$Value>\n        : never\n    : never;\n};\n\n/**\n * @internal\n */\n\nexport type RouterCallerErrorHandler<TContext> = (\n  opts: ErrorHandlerOptions<TContext>,\n) => void;\n\n/**\n * @internal\n */\nexport type RouterCaller<\n  TRoot extends AnyRootTypes,\n  TRecord extends RouterRecord,\n> = (\n  /**\n   * @note\n   * If passing a function, we recommend it's a cached function\n   * e.g. wrapped in `React.cache` to avoid unnecessary computations\n   */\n  ctx: TRoot['ctx'] | (() => MaybePromise<TRoot['ctx']>),\n  options?: {\n    onError?: RouterCallerErrorHandler<TRoot['ctx']>;\n    signal?: AbortSignal;\n  },\n) => DecorateRouterRecord<TRecord>;\n\nconst lazySymbol = Symbol('lazy');\nexport type Lazy<TAny> = (() => Promise<TAny>) & { [lazySymbol]: true };\n\ntype LazyLoader<TAny> = {\n  load: () => Promise<void>;\n  ref: Lazy<TAny>;\n};\n\nfunction once<T>(fn: () => T): () => T {\n  const uncalled = Symbol();\n  let result: T | typeof uncalled = uncalled;\n  return (): T => {\n    if (result === uncalled) {\n      result = fn();\n    }\n    return result;\n  };\n}\n\n/**\n * Lazy load a router\n * @see https://trpc.io/docs/server/merging-routers#lazy-load\n */\nexport function lazy<TRouter extends AnyRouter>(\n  importRouter: () => Promise<\n    | TRouter\n    | {\n        [key: string]: TRouter;\n      }\n  >,\n): Lazy<NoInfer<TRouter>> {\n  async function resolve(): Promise<TRouter> {\n    const mod = await importRouter();\n\n    // if the module is a router, return it\n    if (isRouter(mod)) {\n      return mod;\n    }\n\n    const routers = Object.values(mod);\n\n    if (routers.length !== 1 || !isRouter(routers[0])) {\n      throw new Error(\n        \"Invalid router module - either define exactly 1 export or return the router directly.\\nExample: `lazy(() => import('./slow.js').then((m) => m.slowRouter))`\",\n      );\n    }\n\n    return routers[0];\n  }\n  resolve[lazySymbol] = true as const;\n\n  return resolve;\n}\n\nfunction isLazy<TAny>(input: unknown): input is Lazy<TAny> {\n  return typeof input === 'function' && lazySymbol in input;\n}\n\n/**\n * @internal\n */\nexport interface RouterDef<\n  TRoot extends AnyRootTypes,\n  TRecord extends RouterRecord,\n> {\n  _config: RootConfig<TRoot>;\n  router: true;\n  procedure?: never;\n  procedures: TRecord;\n  record: TRecord;\n  lazy: Record<string, LazyLoader<AnyRouter>>;\n}\n\nexport interface Router<\n  TRoot extends AnyRootTypes,\n  TRecord extends RouterRecord,\n> {\n  _def: RouterDef<TRoot, TRecord>;\n  /**\n   * @see https://trpc.io/docs/v11/server/server-side-calls\n   */\n  createCaller: RouterCaller<TRoot, TRecord>;\n}\n\nexport type BuiltRouter<\n  TRoot extends AnyRootTypes,\n  TRecord extends RouterRecord,\n> = Router<TRoot, TRecord> & TRecord;\n\nexport interface RouterBuilder<TRoot extends AnyRootTypes> {\n  <TIn extends CreateRouterOptions>(\n    _: TIn,\n  ): BuiltRouter<TRoot, DecorateCreateRouterOptions<TIn>>;\n}\n\nexport type AnyRouter = Router<any, any>;\n\nexport type inferRouterRootTypes<TRouter extends AnyRouter> =\n  TRouter['_def']['_config']['$types'];\n\nexport type inferRouterContext<TRouter extends AnyRouter> =\n  inferRouterRootTypes<TRouter>['ctx'];\nexport type inferRouterError<TRouter extends AnyRouter> =\n  inferRouterRootTypes<TRouter>['errorShape'];\nexport type inferRouterMeta<TRouter extends AnyRouter> =\n  inferRouterRootTypes<TRouter>['meta'];\n\nfunction isRouter(value: unknown): value is AnyRouter {\n  return (\n    isObject(value) && isObject(value['_def']) && 'router' in value['_def']\n  );\n}\n\nconst emptyRouter = {\n  _ctx: null as any,\n  _errorShape: null as any,\n  _meta: null as any,\n  queries: {},\n  mutations: {},\n  subscriptions: {},\n  errorFormatter: defaultFormatter,\n  transformer: defaultTransformer,\n};\n\n/**\n * Reserved words that can't be used as router or procedure names\n */\nconst reservedWords = [\n  /**\n   * Then is a reserved word because otherwise we can't return a promise that returns a Proxy\n   * since JS will think that `.then` is something that exists\n   */\n  'then',\n  /**\n   * `fn.call()` and `fn.apply()` are reserved words because otherwise we can't call a function using `.call` or `.apply`\n   */\n  'call',\n  'apply',\n];\n\n/** @internal */\nexport type CreateRouterOptions = {\n  [key: string]:\n    | AnyProcedure\n    | AnyRouter\n    | CreateRouterOptions\n    | Lazy<AnyRouter>;\n};\n\n/** @internal */\nexport type DecorateCreateRouterOptions<\n  TRouterOptions extends CreateRouterOptions,\n> = {\n  [K in keyof TRouterOptions]: TRouterOptions[K] extends infer $Value\n    ? $Value extends AnyProcedure\n      ? $Value\n      : $Value extends Router<any, infer TRecord>\n        ? TRecord\n        : $Value extends Lazy<Router<any, infer TRecord>>\n          ? TRecord\n          : $Value extends CreateRouterOptions\n            ? DecorateCreateRouterOptions<$Value>\n            : never\n    : never;\n};\n\n/**\n * @internal\n */\nexport function createRouterFactory<TRoot extends AnyRootTypes>(\n  config: RootConfig<TRoot>,\n) {\n  function createRouterInner<TInput extends CreateRouterOptions>(\n    input: TInput,\n  ): BuiltRouter<TRoot, DecorateCreateRouterOptions<TInput>> {\n    const reservedWordsUsed = new Set(\n      Object.keys(input).filter((v) => reservedWords.includes(v)),\n    );\n    if (reservedWordsUsed.size > 0) {\n      throw new Error(\n        'Reserved words used in `router({})` call: ' +\n          Array.from(reservedWordsUsed).join(', '),\n      );\n    }\n\n    const procedures: Record<string, AnyProcedure> = omitPrototype({});\n    const lazy: Record<string, LazyLoader<AnyRouter>> = omitPrototype({});\n\n    function createLazyLoader(opts: {\n      ref: Lazy<AnyRouter>;\n      path: readonly string[];\n      key: string;\n      aggregate: RouterRecord;\n    }): LazyLoader<AnyRouter> {\n      return {\n        ref: opts.ref,\n        load: once(async () => {\n          const router = await opts.ref();\n          const lazyPath = [...opts.path, opts.key];\n          const lazyKey = lazyPath.join('.');\n\n          opts.aggregate[opts.key] = step(router._def.record, lazyPath);\n\n          delete lazy[lazyKey];\n\n          // add lazy loaders for nested routers\n          for (const [nestedKey, nestedItem] of Object.entries(\n            router._def.lazy,\n          )) {\n            const nestedRouterKey = [...lazyPath, nestedKey].join('.');\n\n            // console.log('adding lazy', nestedRouterKey);\n            lazy[nestedRouterKey] = createLazyLoader({\n              ref: nestedItem.ref,\n              path: lazyPath,\n              key: nestedKey,\n              aggregate: opts.aggregate[opts.key] as RouterRecord,\n            });\n          }\n        }),\n      };\n    }\n\n    function step(from: CreateRouterOptions, path: readonly string[] = []) {\n      const aggregate: RouterRecord = omitPrototype({});\n      for (const [key, item] of Object.entries(from ?? {})) {\n        if (isLazy(item)) {\n          lazy[[...path, key].join('.')] = createLazyLoader({\n            path,\n            ref: item,\n            key,\n            aggregate,\n          });\n          continue;\n        }\n        if (isRouter(item)) {\n          aggregate[key] = step(item._def.record, [...path, key]);\n          continue;\n        }\n        if (!isProcedure(item)) {\n          // RouterRecord\n          aggregate[key] = step(item, [...path, key]);\n          continue;\n        }\n\n        const newPath = [...path, key].join('.');\n\n        if (procedures[newPath]) {\n          throw new Error(`Duplicate key: ${newPath}`);\n        }\n\n        procedures[newPath] = item;\n        aggregate[key] = item;\n      }\n\n      return aggregate;\n    }\n    const record = step(input);\n\n    const _def: AnyRouter['_def'] = {\n      _config: config,\n      router: true,\n      procedures,\n      lazy,\n      ...emptyRouter,\n      record,\n    };\n\n    const router: BuiltRouter<TRoot, {}> = {\n      ...(record as {}),\n      _def,\n      createCaller: createCallerFactory<TRoot>()({\n        _def,\n      }),\n    };\n    return router as BuiltRouter<TRoot, DecorateCreateRouterOptions<TInput>>;\n  }\n\n  return createRouterInner;\n}\n\nfunction isProcedure(\n  procedureOrRouter: ValueOf<CreateRouterOptions>,\n): procedureOrRouter is AnyProcedure {\n  return typeof procedureOrRouter === 'function';\n}\n\n/**\n * @internal\n */\nexport async function getProcedureAtPath(\n  router: Pick<Router<any, any>, '_def'>,\n  path: string,\n): Promise<AnyProcedure | null> {\n  const { _def } = router;\n  let procedure = _def.procedures[path];\n\n  while (!procedure) {\n    const key = Object.keys(_def.lazy).find((key) => path.startsWith(key));\n    // console.log(`found lazy: ${key ?? 'NOPE'} (fullPath: ${fullPath})`);\n\n    if (!key) {\n      return null;\n    }\n    // console.log('loading', key, '.......');\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const lazyRouter = _def.lazy[key]!;\n    await lazyRouter.load();\n\n    procedure = _def.procedures[path];\n  }\n\n  return procedure;\n}\n\n/**\n * @internal\n */\nexport async function callProcedure(\n  opts: ProcedureCallOptions<unknown> & {\n    router: AnyRouter;\n    allowMethodOverride?: boolean;\n  },\n) {\n  const { type, path } = opts;\n  const proc = await getProcedureAtPath(opts.router, path);\n  if (\n    !proc ||\n    !isProcedure(proc) ||\n    (proc._def.type !== type && !opts.allowMethodOverride)\n  ) {\n    throw new TRPCError({\n      code: 'NOT_FOUND',\n      message: `No \"${type}\"-procedure on path \"${path}\"`,\n    });\n  }\n\n  /* istanbul ignore if -- @preserve */\n  if (\n    proc._def.type !== type &&\n    opts.allowMethodOverride &&\n    proc._def.type === 'subscription'\n  ) {\n    throw new TRPCError({\n      code: 'METHOD_NOT_SUPPORTED',\n      message: `Method override is not supported for subscriptions`,\n    });\n  }\n\n  return proc(opts);\n}\n\nexport interface RouterCallerFactory<TRoot extends AnyRootTypes> {\n  <TRecord extends RouterRecord>(\n    router: Pick<Router<TRoot, TRecord>, '_def'>,\n  ): RouterCaller<TRoot, TRecord>;\n}\n\nexport function createCallerFactory<\n  TRoot extends AnyRootTypes,\n>(): RouterCallerFactory<TRoot> {\n  return function createCallerInner<TRecord extends RouterRecord>(\n    router: Pick<Router<TRoot, TRecord>, '_def'>,\n  ): RouterCaller<TRoot, TRecord> {\n    const { _def } = router;\n    type Context = TRoot['ctx'];\n\n    return function createCaller(ctxOrCallback, opts) {\n      return createRecursiveProxy<ReturnType<RouterCaller<any, any>>>(\n        async ({ path, args }) => {\n          const fullPath = path.join('.');\n\n          if (path.length === 1 && path[0] === '_def') {\n            return _def;\n          }\n\n          const procedure = await getProcedureAtPath(router, fullPath);\n\n          let ctx: Context | undefined = undefined;\n          try {\n            if (!procedure) {\n              throw new TRPCError({\n                code: 'NOT_FOUND',\n                message: `No procedure found on path \"${path}\"`,\n              });\n            }\n            ctx = isFunction(ctxOrCallback)\n              ? await Promise.resolve(ctxOrCallback())\n              : ctxOrCallback;\n\n            return await procedure({\n              path: fullPath,\n              getRawInput: async () => args[0],\n              ctx,\n              type: procedure._def.type,\n              signal: opts?.signal,\n            });\n          } catch (cause) {\n            opts?.onError?.({\n              ctx,\n              error: getTRPCErrorFromUnknown(cause),\n              input: args[0],\n              path: fullPath,\n              type: procedure?._def.type ?? 'unknown',\n            });\n            throw cause;\n          }\n        },\n      );\n    };\n  };\n}\n\n/** @internal */\nexport type MergeRouters<\n  TRouters extends AnyRouter[],\n  TRoot extends AnyRootTypes = TRouters[0]['_def']['_config']['$types'],\n  TRecord extends RouterRecord = {},\n> = TRouters extends [\n  infer Head extends AnyRouter,\n  ...infer Tail extends AnyRouter[],\n]\n  ? MergeRouters<Tail, TRoot, Head['_def']['record'] & TRecord>\n  : BuiltRouter<TRoot, TRecord>;\n\nexport function mergeRouters<TRouters extends AnyRouter[]>(\n  ...routerList: [...TRouters]\n): MergeRouters<TRouters> {\n  const record = mergeWithoutOverrides(\n    {},\n    ...routerList.map((r) => r._def.record),\n  );\n  const errorFormatter = routerList.reduce(\n    (currentErrorFormatter, nextRouter) => {\n      if (\n        nextRouter._def._config.errorFormatter &&\n        nextRouter._def._config.errorFormatter !== defaultFormatter\n      ) {\n        if (\n          currentErrorFormatter !== defaultFormatter &&\n          currentErrorFormatter !== nextRouter._def._config.errorFormatter\n        ) {\n          throw new Error('You seem to have several error formatters');\n        }\n        return nextRouter._def._config.errorFormatter;\n      }\n      return currentErrorFormatter;\n    },\n    defaultFormatter,\n  );\n\n  const transformer = routerList.reduce((prev, current) => {\n    if (\n      current._def._config.transformer &&\n      current._def._config.transformer !== defaultTransformer\n    ) {\n      if (\n        prev !== defaultTransformer &&\n        prev !== current._def._config.transformer\n      ) {\n        throw new Error('You seem to have several transformers');\n      }\n      return current._def._config.transformer;\n    }\n    return prev;\n  }, defaultTransformer);\n\n  const router = createRouterFactory({\n    errorFormatter,\n    transformer,\n    isDev: routerList.every((r) => r._def._config.isDev),\n    allowOutsideOfServer: routerList.every(\n      (r) => r._def._config.allowOutsideOfServer,\n    ),\n    isServer: routerList.every((r) => r._def._config.isServer),\n    $types: routerList[0]?._def._config.$types,\n  })(record);\n\n  return router as MergeRouters<TRouters>;\n}\n", "const trackedSymbol = Symbol();\n\ntype TrackedId = string & {\n  __brand: 'TrackedId';\n};\nexport type TrackedEnvelope<TData> = [TrackedId, TData, typeof trackedSymbol];\n\nexport interface TrackedData<TData> {\n  /**\n   * The id of the message to keep track of in case the connection gets lost\n   */\n  id: string;\n  /**\n   * The data field of the message\n   */\n  data: TData;\n}\n/**\n * Produce a typed server-sent event message\n * @deprecated use `tracked(id, data)` instead\n */\nexport function sse<TData>(event: { id: string; data: TData }) {\n  return tracked(event.id, event.data);\n}\n\nexport function isTrackedEnvelope<TData>(\n  value: unknown,\n): value is TrackedEnvelope<TData> {\n  return Array.isArray(value) && value[2] === trackedSymbol;\n}\n\n/**\n * Automatically track an event so that it can be resumed from a given id if the connection is lost\n */\nexport function tracked<TData>(\n  id: string,\n  data: TData,\n): TrackedEnvelope<TData> {\n  if (id === '') {\n    // This limitation could be removed by using different SSE event names / channels for tracked event and non-tracked event\n    throw new Error(\n      '`id` must not be an empty string as empty string is the same as not setting the id at all',\n    );\n  }\n  return [id as TrackedId, data, trackedSymbol];\n}\n\nexport type inferTrackedOutput<TData> =\n  TData extends TrackedEnvelope<infer $Data> ? TrackedData<$Data> : TData;\n", "import type { Result } from '../unstable-core-do-not-import';\nimport type {\n  Observable,\n  Observer,\n  OperatorFunction,\n  TeardownLogic,\n  UnaryFunction,\n  Unsubscribable,\n} from './types';\n\n/** @public */\nexport type inferObservableValue<TObservable> =\n  TObservable extends Observable<infer TValue, unknown> ? TValue : never;\n\n/** @public */\nexport function isObservable(x: unknown): x is Observable<unknown, unknown> {\n  return typeof x === 'object' && x !== null && 'subscribe' in x;\n}\n\n/** @public */\nexport function observable<TValue, TError = unknown>(\n  subscribe: (observer: Observer<TValue, TError>) => TeardownLogic,\n): Observable<TValue, TError> {\n  const self: Observable<TValue, TError> = {\n    subscribe(observer) {\n      let teardownRef: TeardownLogic | null = null;\n      let isDone = false;\n      let unsubscribed = false;\n      let teardownImmediately = false;\n      function unsubscribe() {\n        if (teardownRef === null) {\n          teardownImmediately = true;\n          return;\n        }\n        if (unsubscribed) {\n          return;\n        }\n        unsubscribed = true;\n\n        if (typeof teardownRef === 'function') {\n          teardownRef();\n        } else if (teardownRef) {\n          teardownRef.unsubscribe();\n        }\n      }\n      teardownRef = subscribe({\n        next(value) {\n          if (isDone) {\n            return;\n          }\n          observer.next?.(value);\n        },\n        error(err) {\n          if (isDone) {\n            return;\n          }\n          isDone = true;\n          observer.error?.(err);\n          unsubscribe();\n        },\n        complete() {\n          if (isDone) {\n            return;\n          }\n          isDone = true;\n          observer.complete?.();\n          unsubscribe();\n        },\n      });\n      if (teardownImmediately) {\n        unsubscribe();\n      }\n      return {\n        unsubscribe,\n      };\n    },\n    pipe(\n      ...operations: OperatorFunction<any, any, any, any>[]\n    ): Observable<any, any> {\n      return operations.reduce(pipeReducer, self);\n    },\n  };\n  return self;\n}\n\nfunction pipeReducer(prev: any, fn: UnaryFunction<any, any>) {\n  return fn(prev);\n}\n\n/** @internal */\nexport function observableToPromise<TValue>(\n  observable: Observable<TValue, unknown>,\n) {\n  const ac = new AbortController();\n  const promise = new Promise<TValue>((resolve, reject) => {\n    let isDone = false;\n    function onDone() {\n      if (isDone) {\n        return;\n      }\n      isDone = true;\n      obs$.unsubscribe();\n    }\n    ac.signal.addEventListener('abort', () => {\n      reject(ac.signal.reason);\n    });\n    const obs$ = observable.subscribe({\n      next(data) {\n        isDone = true;\n        resolve(data);\n        onDone();\n      },\n      error(data) {\n        reject(data);\n      },\n      complete() {\n        ac.abort();\n        onDone();\n      },\n    });\n  });\n  return promise;\n}\n\n/**\n * @internal\n */\nfunction observableToReadableStream<TValue>(\n  observable: Observable<TValue, unknown>,\n  signal: AbortSignal,\n): ReadableStream<Result<TValue>> {\n  let unsub: Unsubscribable | null = null;\n\n  const onAbort = () => {\n    unsub?.unsubscribe();\n    unsub = null;\n    signal.removeEventListener('abort', onAbort);\n  };\n\n  return new ReadableStream<Result<TValue>>({\n    start(controller) {\n      unsub = observable.subscribe({\n        next(data) {\n          controller.enqueue({ ok: true, value: data });\n        },\n        error(error) {\n          controller.enqueue({ ok: false, error });\n          controller.close();\n        },\n        complete() {\n          controller.close();\n        },\n      });\n\n      if (signal.aborted) {\n        onAbort();\n      } else {\n        signal.addEventListener('abort', onAbort, { once: true });\n      }\n    },\n    cancel() {\n      onAbort();\n    },\n  });\n}\n\n/** @internal */\nexport function observableToAsyncIterable<TValue>(\n  observable: Observable<TValue, unknown>,\n  signal: AbortSignal,\n): AsyncIterable<TValue> {\n  const stream = observableToReadableStream(observable, signal);\n\n  const reader = stream.getReader();\n  const iterator: AsyncIterator<TValue> = {\n    async next() {\n      const value = await reader.read();\n      if (value.done) {\n        return {\n          value: undefined,\n          done: true,\n        };\n      }\n      const { value: result } = value;\n      if (!result.ok) {\n        throw result.error;\n      }\n      return {\n        value: result.value,\n        done: false,\n      };\n    },\n    async return() {\n      await reader.cancel();\n      return {\n        value: undefined,\n        done: true,\n      };\n    },\n  };\n  return {\n    [Symbol.asyncIterator]() {\n      return iterator;\n    },\n  };\n}\n", "function _objectWithoutPropertiesLoose(r, e) {\n  if (null == r) return {};\n  var t = {};\n  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {\n    if (e.includes(n)) continue;\n    t[n] = r[n];\n  }\n  return t;\n}\nmodule.exports = _objectWithoutPropertiesLoose, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "var objectWithoutPropertiesLoose = require(\"./objectWithoutPropertiesLoose.js\");\nfunction _objectWithoutProperties(e, t) {\n  if (null == e) return {};\n  var o,\n    r,\n    i = objectWithoutPropertiesLoose(e, t);\n  if (Object.getOwnPropertySymbols) {\n    var s = Object.getOwnPropertySymbols(e);\n    for (r = 0; r < s.length; r++) o = s[r], t.includes(o) || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);\n  }\n  return i;\n}\nmodule.exports = _objectWithoutProperties, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return module.exports = _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports, _typeof(o);\n}\nmodule.exports = _typeof, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "var _typeof = require(\"./typeof.js\")[\"default\"];\nfunction toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nmodule.exports = toPrimitive, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "var _typeof = require(\"./typeof.js\")[\"default\"];\nvar toPrimitive = require(\"./toPrimitive.js\");\nfunction toPropertyKey(t) {\n  var i = toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nmodule.exports = toPropertyKey, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "var toPropertyKey = require(\"./toPropertyKey.js\");\nfunction _defineProperty(e, r, t) {\n  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nmodule.exports = _defineProperty, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "var defineProperty = require(\"./defineProperty.js\");\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nmodule.exports = _objectSpread2, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "import { skipToken } from '@tanstack/react-query';\nimport {\n  isObject,\n  type DeepPartial,\n} from '@trpc/server/unstable-core-do-not-import';\nimport type { DecoratedMutation, DecoratedQuery } from '../createTRPCReact';\nimport type { DecorateRouterRecord } from '../shared';\n\nexport type QueryType = 'any' | 'infinite' | 'query';\n\nexport type TRPCQueryKey = [\n  readonly string[],\n  { input?: unknown; type?: Exclude<QueryType, 'any'> }?,\n];\n\nexport type TRPCMutationKey = [readonly string[]]; // = [TRPCQueryKey[0]]\n\ntype ProcedureOrRouter =\n  | DecoratedMutation<any>\n  | DecoratedQuery<any>\n  | DecorateRouterRecord<any, any>;\n\n/**\n * To allow easy interactions with groups of related queries, such as\n * invalidating all queries of a router, we use an array as the path when\n * storing in tanstack query.\n **/\nexport function getQueryKeyInternal(\n  path: readonly string[],\n  input: unknown,\n  type: QueryType,\n): TRPCQueryKey {\n  // Construct a query key that is easy to destructure and flexible for\n  // partial selecting etc.\n  // https://github.com/trpc/trpc/issues/3128\n\n  // some parts of the path may be dot-separated, split them up\n  const splitPath = path.flatMap((part) => part.split('.'));\n\n  if (!input && (!type || type === 'any')) {\n    // this matches also all mutations (see `getMutationKeyInternal`)\n\n    // for `utils.invalidate()` to match all queries (including vanilla react-query)\n    // we don't want nested array if path is empty, i.e. `[]` instead of `[[]]`\n    return splitPath.length ? [splitPath] : ([] as unknown as TRPCQueryKey);\n  }\n\n  if (\n    type === 'infinite' &&\n    isObject(input) &&\n    ('direction' in input || 'cursor' in input)\n  ) {\n    const {\n      cursor: _,\n      direction: __,\n      ...inputWithoutCursorAndDirection\n    } = input;\n    return [\n      splitPath,\n      {\n        input: inputWithoutCursorAndDirection,\n        type: 'infinite',\n      },\n    ];\n  }\n  return [\n    splitPath,\n    {\n      ...(typeof input !== 'undefined' &&\n        input !== skipToken && { input: input }),\n      ...(type && type !== 'any' && { type: type }),\n    },\n  ];\n}\n\nexport function getMutationKeyInternal(path: readonly string[]) {\n  return getQueryKeyInternal(path, undefined, 'any') as TRPCMutationKey;\n}\n\ntype GetInfiniteQueryInput<\n  TProcedureInput,\n  TInputWithoutCursorAndDirection = Omit<\n    TProcedureInput,\n    'cursor' | 'direction'\n  >,\n> = keyof TInputWithoutCursorAndDirection extends never\n  ? undefined\n  : DeepPartial<TInputWithoutCursorAndDirection> | undefined;\n\n/** @internal */\nexport type GetQueryProcedureInput<TProcedureInput> = TProcedureInput extends {\n  cursor?: any;\n}\n  ? GetInfiniteQueryInput<TProcedureInput>\n  : DeepPartial<TProcedureInput> | undefined;\n\ntype GetParams<TProcedureOrRouter extends ProcedureOrRouter> =\n  TProcedureOrRouter extends DecoratedQuery<infer $Def>\n    ? [input?: GetQueryProcedureInput<$Def['input']>, type?: QueryType]\n    : [];\n\n/**\n * Method to extract the query key for a procedure\n * @param procedureOrRouter - procedure or AnyRouter\n * @param input - input to procedureOrRouter\n * @param type - defaults to `any`\n * @see https://trpc.io/docs/v11/getQueryKey\n */\nexport function getQueryKey<TProcedureOrRouter extends ProcedureOrRouter>(\n  procedureOrRouter: TProcedureOrRouter,\n  ..._params: GetParams<TProcedureOrRouter>\n) {\n  const [input, type] = _params;\n\n  // @ts-expect-error - we don't expose _def on the type layer\n  const path = procedureOrRouter._def().path as string[];\n  const queryKey = getQueryKeyInternal(path, input, type ?? 'any');\n  return queryKey;\n}\n\n// TODO: look over if we can't use a single type\nexport type QueryKeyKnown<TInput, TType extends Exclude<QueryType, 'any'>> = [\n  string[],\n  { input?: GetQueryProcedureInput<TInput>; type: TType }?,\n];\n\n/**\n * Method to extract the mutation key for a procedure\n * @param procedure - procedure\n * @see https://trpc.io/docs/v11/getQueryKey#mutations\n */\nexport function getMutationKey<TProcedure extends DecoratedMutation<any>>(\n  procedure: TProcedure,\n) {\n  // @ts-expect-error - we don't expose _def on the type layer\n  const path = procedure._def().path as string[];\n  return getMutationKeyInternal(path);\n}\n", "function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return module.exports = _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports, _typeof(o);\n}\nmodule.exports = _typeof, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "var _typeof = require(\"./typeof.js\")[\"default\"];\nfunction toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nmodule.exports = toPrimitive, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "var _typeof = require(\"./typeof.js\")[\"default\"];\nvar toPrimitive = require(\"./toPrimitive.js\");\nfunction toPropertyKey(t) {\n  var i = toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nmodule.exports = toPropertyKey, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "var toPropertyKey = require(\"./toPropertyKey.js\");\nfunction _defineProperty(e, r, t) {\n  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nmodule.exports = _defineProperty, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "var defineProperty = require(\"./defineProperty.js\");\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nmodule.exports = _objectSpread2, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "import { observable } from './observable';\nimport type {\n  MonoTypeOperatorFunction,\n  Observer,\n  OperatorFunction,\n  Unsubscribable,\n} from './types';\n\nexport function map<TValueBefore, TError, TValueAfter>(\n  project: (value: TValueBefore, index: number) => TValueAfter,\n): OperatorFunction<TValueBefore, TError, TValueAfter, TError> {\n  return (source) => {\n    return observable((destination) => {\n      let index = 0;\n      const subscription = source.subscribe({\n        next(value) {\n          destination.next(project(value, index++));\n        },\n        error(error) {\n          destination.error(error);\n        },\n        complete() {\n          destination.complete();\n        },\n      });\n      return subscription;\n    });\n  };\n}\n\ninterface ShareConfig {}\nexport function share<TValue, TError>(\n  _opts?: ShareConfig,\n): MonoTypeOperatorFunction<TValue, TError> {\n  return (source) => {\n    let refCount = 0;\n\n    let subscription: Unsubscribable | null = null;\n    const observers: Partial<Observer<TValue, TError>>[] = [];\n\n    function startIfNeeded() {\n      if (subscription) {\n        return;\n      }\n      subscription = source.subscribe({\n        next(value) {\n          for (const observer of observers) {\n            observer.next?.(value);\n          }\n        },\n        error(error) {\n          for (const observer of observers) {\n            observer.error?.(error);\n          }\n        },\n        complete() {\n          for (const observer of observers) {\n            observer.complete?.();\n          }\n        },\n      });\n    }\n    function resetIfNeeded() {\n      // \"resetOnRefCountZero\"\n      if (refCount === 0 && subscription) {\n        const _sub = subscription;\n        subscription = null;\n        _sub.unsubscribe();\n      }\n    }\n\n    return observable((subscriber) => {\n      refCount++;\n\n      observers.push(subscriber);\n      startIfNeeded();\n      return {\n        unsubscribe() {\n          refCount--;\n          resetIfNeeded();\n\n          const index = observers.findIndex((v) => v === subscriber);\n\n          if (index > -1) {\n            observers.splice(index, 1);\n          }\n        },\n      };\n    });\n  };\n}\n\nexport function tap<TValue, TError>(\n  observer: Partial<Observer<TValue, TError>>,\n): MonoTypeOperatorFunction<TValue, TError> {\n  return (source) => {\n    return observable((destination) => {\n      return source.subscribe({\n        next(value) {\n          observer.next?.(value);\n          destination.next(value);\n        },\n        error(error) {\n          observer.error?.(error);\n          destination.error(error);\n        },\n        complete() {\n          observer.complete?.();\n          destination.complete();\n        },\n      });\n    });\n  };\n}\n\nconst distinctUnsetMarker = Symbol();\nexport function distinctUntilChanged<TValue, TError>(\n  compare: (a: TValue, b: TValue) => boolean = (a, b) => a === b,\n): MonoTypeOperatorFunction<TValue, TError> {\n  return (source) => {\n    return observable((destination) => {\n      let lastValue: TValue | typeof distinctUnsetMarker = distinctUnsetMarker;\n\n      return source.subscribe({\n        next(value) {\n          if (lastValue !== distinctUnsetMarker && compare(lastValue, value)) {\n            return;\n          }\n          lastValue = value;\n          destination.next(value);\n        },\n        error(error) {\n          destination.error(error);\n        },\n        complete() {\n          destination.complete();\n        },\n      });\n    });\n  };\n}\n\nconst isDeepEqual = <T>(a: T, b: T): boolean => {\n  if (a === b) {\n    return true;\n  }\n  const bothAreObjects =\n    a && b && typeof a === 'object' && typeof b === 'object';\n\n  return (\n    !!bothAreObjects &&\n    Object.keys(a).length === Object.keys(b).length &&\n    Object.entries(a).every(([k, v]) => isDeepEqual(v, b[k as keyof T]))\n  );\n};\nexport function distinctUntilDeepChanged<\n  TValue,\n  TError,\n>(): MonoTypeOperatorFunction<TValue, TError> {\n  return distinctUntilChanged(isDeepEqual);\n}\n", "import { observable } from './observable';\nimport type { Observable, Observer } from './types';\n\nexport interface BehaviorSubject<TValue> extends Observable<TValue, never> {\n  observable: Observable<TValue, never>;\n  next: (value: TValue) => void;\n  get: () => TValue;\n}\n\nexport interface ReadonlyBehaviorSubject<TValue>\n  extends Omit<BehaviorSubject<TValue>, 'next'> {}\n\n/**\n * @internal\n * An observable that maintains and provides a \"current value\" to subscribers\n * @see https://www.learnrxjs.io/learn-rxjs/subjects/behaviorsubject\n */\nexport function behaviorSubject<TValue>(\n  initialValue: TValue,\n): BehaviorSubject<TValue> {\n  let value: TValue = initialValue;\n\n  const observerList: Observer<TValue, never>[] = [];\n\n  const addObserver = (observer: Observer<TValue, never>) => {\n    if (value !== undefined) {\n      observer.next(value);\n    }\n    observerList.push(observer);\n  };\n  const removeObserver = (observer: Observer<TValue, never>) => {\n    observerList.splice(observerList.indexOf(observer), 1);\n  };\n\n  const obs = observable<TValue, never>((observer) => {\n    addObserver(observer);\n    return () => {\n      removeObserver(observer);\n    };\n  }) as BehaviorSubject<TValue>;\n\n  obs.next = (nextValue: TValue) => {\n    if (value === nextValue) {\n      return;\n    }\n    value = nextValue;\n    for (const observer of observerList) {\n      observer.next(nextValue);\n    }\n  };\n\n  obs.get = () => value;\n\n  return obs;\n}\n", "import { observable } from '@trpc/server/observable';\nimport type { AnyRouter } from '@trpc/server/unstable-core-do-not-import';\nimport type {\n  Operation,\n  OperationLink,\n  OperationResultObservable,\n} from '../types';\n\n/** @internal */\nexport function createChain<\n  TRouter extends AnyRouter,\n  TInput = unknown,\n  TOutput = unknown,\n>(opts: {\n  links: OperationLink<TRouter, TInput, TOutput>[];\n  op: Operation<TInput>;\n}): OperationResultObservable<TRouter, TOutput> {\n  return observable((observer) => {\n    function execute(index = 0, op = opts.op) {\n      const next = opts.links[index];\n      if (!next) {\n        throw new Error(\n          'No more links to execute - did you forget to add an ending link?',\n        );\n      }\n      const subscription = next({\n        op,\n        next(nextOp) {\n          const nextObserver = execute(index + 1, nextOp);\n\n          return nextObserver;\n        },\n      });\n      return subscription;\n    }\n\n    const obs$ = execute();\n    return obs$.subscribe(observer);\n  });\n}\n", "import { observable } from '@trpc/server/observable';\nimport type { AnyRouter } from '@trpc/server/unstable-core-do-not-import';\nimport { createChain } from './internals/createChain';\nimport type { Operation, TRPCLink } from './types';\n\nfunction asArray<TType>(value: TType | TType[]) {\n  return Array.isArray(value) ? value : [value];\n}\nexport function splitLink<TRouter extends AnyRouter = AnyRouter>(opts: {\n  condition: (op: Operation) => boolean;\n  /**\n   * The link to execute next if the test function returns `true`.\n   */\n  true: TRPCLink<TRouter> | TRPCLink<TRouter>[];\n  /**\n   * The link to execute next if the test function returns `false`.\n   */\n  false: TRPCLink<TRouter> | TRPCLink<TRouter>[];\n}): TRPCLink<TRouter> {\n  return (runtime) => {\n    const yes = asArray(opts.true).map((link) => link(runtime));\n    const no = asArray(opts.false).map((link) => link(runtime));\n    return (props) => {\n      return observable((observer) => {\n        const links = opts.condition(props.op) ? yes : no;\n        return createChain({ op: props.op, links }).subscribe(observer);\n      });\n    };\n  };\n}\n", "import type {\n  inferClientTypes,\n  InferrableClientTypes,\n  Maybe,\n  TRPCErrorResponse,\n} from '@trpc/server/unstable-core-do-not-import';\nimport {\n  isObject,\n  type DefaultErrorShape,\n} from '@trpc/server/unstable-core-do-not-import';\n\ntype inferErrorShape<TInferrable extends InferrableClientTypes> =\n  inferClientTypes<TInferrable>['errorShape'];\nexport interface TRPCClientErrorBase<TShape extends DefaultErrorShape> {\n  readonly message: string;\n  readonly shape: Maybe<TShape>;\n  readonly data: Maybe<TShape['data']>;\n}\nexport type TRPCClientErrorLike<TInferrable extends InferrableClientTypes> =\n  TRPCClientErrorBase<inferErrorShape<TInferrable>>;\n\nexport function isTRPCClientError<TInferrable extends InferrableClientTypes>(\n  cause: unknown,\n): cause is TRPCClientError<TInferrable> {\n  return cause instanceof TRPCClientError;\n}\n\nfunction isTRPCErrorResponse(obj: unknown): obj is TRPCErrorResponse<any> {\n  return (\n    isObject(obj) &&\n    isObject(obj['error']) &&\n    typeof obj['error']['code'] === 'number' &&\n    typeof obj['error']['message'] === 'string'\n  );\n}\n\nfunction getMessageFromUnknownError(err: unknown, fallback: string): string {\n  if (typeof err === 'string') {\n    return err;\n  }\n  if (isObject(err) && typeof err['message'] === 'string') {\n    return err['message'];\n  }\n  return fallback;\n}\n\nexport class TRPCClientError<TRouterOrProcedure extends InferrableClientTypes>\n  extends Error\n  implements TRPCClientErrorBase<inferErrorShape<TRouterOrProcedure>>\n{\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore override doesn't work in all environments due to \"This member cannot have an 'override' modifier because it is not declared in the base class 'Error'\"\n  public override readonly cause;\n  public readonly shape: Maybe<inferErrorShape<TRouterOrProcedure>>;\n  public readonly data: Maybe<inferErrorShape<TRouterOrProcedure>['data']>;\n\n  /**\n   * Additional meta data about the error\n   * In the case of HTTP-errors, we'll have `response` and potentially `responseJSON` here\n   */\n  public meta;\n\n  constructor(\n    message: string,\n    opts?: {\n      result?: Maybe<TRPCErrorResponse<inferErrorShape<TRouterOrProcedure>>>;\n      cause?: Error;\n      meta?: Record<string, unknown>;\n    },\n  ) {\n    const cause = opts?.cause;\n\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore https://github.com/tc39/proposal-error-cause\n    super(message, { cause });\n\n    this.meta = opts?.meta;\n\n    this.cause = cause;\n    this.shape = opts?.result?.error;\n    this.data = opts?.result?.error.data;\n    this.name = 'TRPCClientError';\n\n    Object.setPrototypeOf(this, TRPCClientError.prototype);\n  }\n\n  public static from<TRouterOrProcedure extends InferrableClientTypes>(\n    _cause: Error | TRPCErrorResponse<any> | object,\n    opts: { meta?: Record<string, unknown> } = {},\n  ): TRPCClientError<TRouterOrProcedure> {\n    const cause = _cause as unknown;\n\n    if (isTRPCClientError(cause)) {\n      if (opts.meta) {\n        // Decorate with meta error data\n        cause.meta = {\n          ...cause.meta,\n          ...opts.meta,\n        };\n      }\n      return cause;\n    }\n    if (isTRPCErrorResponse(cause)) {\n      return new TRPCClientError(cause.error.message, {\n        ...opts,\n        result: cause,\n      });\n    }\n    return new TRPCClientError(\n      getMessageFromUnknownError(cause, 'Unknown error'),\n      {\n        ...opts,\n        cause: cause as any,\n      },\n    );\n  }\n}\n", "import type {\n  AnyClientTypes,\n  CombinedDataTransformer,\n  DataTransformerOptions,\n  TypeError,\n} from '@trpc/server/unstable-core-do-not-import';\n\n/**\n * @internal\n */\nexport type CoercedTransformerParameters = {\n  transformer?: DataTransformerOptions;\n};\n\ntype TransformerOptionYes = {\n  /**\n   * Data transformer\n   *\n   * You must use the same transformer on the backend and frontend\n   * @see https://trpc.io/docs/v11/data-transformers\n   **/\n  transformer: DataTransformerOptions;\n};\ntype TransformerOptionNo = {\n  /**\n   * Data transformer\n   *\n   * You must use the same transformer on the backend and frontend\n   * @see https://trpc.io/docs/v11/data-transformers\n   **/\n  transformer?: TypeError<'You must define a transformer on your your `initTRPC`-object first'>;\n};\n\n/**\n * @internal\n */\nexport type TransformerOptions<\n  TRoot extends Pick<AnyClientTypes, 'transformer'>,\n> = TRoot['transformer'] extends true\n  ? TransformerOptionYes\n  : TransformerOptionNo;\n/**\n * @internal\n */\n\n/**\n * @internal\n */\nexport function getTransformer(\n  transformer:\n    | TransformerOptions<{ transformer: false }>['transformer']\n    | TransformerOptions<{ transformer: true }>['transformer']\n    | undefined,\n): CombinedDataTransformer {\n  const _transformer =\n    transformer as CoercedTransformerParameters['transformer'];\n  if (!_transformer) {\n    return {\n      input: {\n        serialize: (data) => data,\n        deserialize: (data) => data,\n      },\n      output: {\n        serialize: (data) => data,\n        deserialize: (data) => data,\n      },\n    };\n  }\n  if ('input' in _transformer) {\n    return _transformer;\n  }\n  return {\n    input: _transformer,\n    output: _transformer,\n  };\n}\n", "import type { FetchEsque, NativeFetchEsque } from './internals/types';\n\ntype AnyFn = (...args: any[]) => unknown;\n\nconst isFunction = (fn: unknown): fn is AnyFn => typeof fn === 'function';\n\nexport function getFetch(\n  customFetchImpl?: FetchEsque | NativeFetchEsque,\n): FetchEsque {\n  if (customFetchImpl) {\n    return customFetchImpl as FetchEsque;\n  }\n\n  if (typeof window !== 'undefined' && isFunction(window.fetch)) {\n    return window.fetch as FetchEsque;\n  }\n\n  if (typeof globalThis !== 'undefined' && isFunction(globalThis.fetch)) {\n    return globalThis.fetch as FetchEsque;\n  }\n\n  throw new Error('No fetch implementation found');\n}\n", "import type {\n  AnyClientTypes,\n  CombinedDataTransformer,\n  Maybe,\n  ProcedureType,\n  TRPCAcceptHeader,\n  TRPCResponse,\n} from '@trpc/server/unstable-core-do-not-import';\nimport { getFetch } from '../../getFetch';\nimport type {\n  FetchEsque,\n  RequestInitEsque,\n  ResponseEsque,\n} from '../../internals/types';\nimport type { TransformerOptions } from '../../unstable-internals';\nimport { getTransformer } from '../../unstable-internals';\nimport type { HTTPHeaders } from '../types';\n\n/**\n * @internal\n */\nexport type HTTPLinkBaseOptions<\n  TRoot extends Pick<AnyClientTypes, 'transformer'>,\n> = {\n  url: string | URL;\n  /**\n   * Add ponyfill for fetch\n   */\n  fetch?: FetchEsque;\n  /**\n   * Send all requests `as POST`s requests regardless of the procedure type\n   * The HTTP handler must separately allow overriding the method. See:\n   * @see https://trpc.io/docs/rpc\n   */\n  methodOverride?: 'POST';\n} & TransformerOptions<TRoot>;\n\nexport interface ResolvedHTTPLinkOptions {\n  url: string;\n  fetch?: FetchEsque;\n  transformer: CombinedDataTransformer;\n  methodOverride?: 'POST';\n}\n\nexport function resolveHTTPLinkOptions(\n  opts: HTTPLinkBaseOptions<AnyClientTypes>,\n): ResolvedHTTPLinkOptions {\n  return {\n    url: opts.url.toString(),\n    fetch: opts.fetch,\n    transformer: getTransformer(opts.transformer),\n    methodOverride: opts.methodOverride,\n  };\n}\n\n// https://github.com/trpc/trpc/pull/669\nfunction arrayToDict(array: unknown[]) {\n  const dict: Record<number, unknown> = {};\n  for (let index = 0; index < array.length; index++) {\n    const element = array[index];\n    dict[index] = element;\n  }\n  return dict;\n}\n\nconst METHOD = {\n  query: 'GET',\n  mutation: 'POST',\n  subscription: 'PATCH',\n} as const;\n\nexport interface HTTPResult {\n  json: TRPCResponse;\n  meta: {\n    response: ResponseEsque;\n    responseJSON?: unknown;\n  };\n}\n\ntype GetInputOptions = {\n  transformer: CombinedDataTransformer;\n} & ({ input: unknown } | { inputs: unknown[] });\n\nexport function getInput(opts: GetInputOptions) {\n  return 'input' in opts\n    ? opts.transformer.input.serialize(opts.input)\n    : arrayToDict(\n        opts.inputs.map((_input) => opts.transformer.input.serialize(_input)),\n      );\n}\n\nexport type HTTPBaseRequestOptions = GetInputOptions &\n  ResolvedHTTPLinkOptions & {\n    type: ProcedureType;\n    path: string;\n    signal: Maybe<AbortSignal>;\n  };\n\ntype GetUrl = (opts: HTTPBaseRequestOptions) => string;\ntype GetBody = (opts: HTTPBaseRequestOptions) => RequestInitEsque['body'];\n\nexport type ContentOptions = {\n  trpcAcceptHeader?: TRPCAcceptHeader;\n  contentTypeHeader?: string;\n  getUrl: GetUrl;\n  getBody: GetBody;\n};\n\nexport const getUrl: GetUrl = (opts) => {\n  const parts = opts.url.split('?') as [string, string?];\n  const base = parts[0].replace(/\\/$/, ''); // Remove any trailing slashes\n\n  let url = base + '/' + opts.path;\n  const queryParts: string[] = [];\n\n  if (parts[1]) {\n    queryParts.push(parts[1]);\n  }\n  if ('inputs' in opts) {\n    queryParts.push('batch=1');\n  }\n  if (opts.type === 'query' || opts.type === 'subscription') {\n    const input = getInput(opts);\n    if (input !== undefined && opts.methodOverride !== 'POST') {\n      queryParts.push(`input=${encodeURIComponent(JSON.stringify(input))}`);\n    }\n  }\n  if (queryParts.length) {\n    url += '?' + queryParts.join('&');\n  }\n  return url;\n};\n\nexport const getBody: GetBody = (opts) => {\n  if (opts.type === 'query' && opts.methodOverride !== 'POST') {\n    return undefined;\n  }\n  const input = getInput(opts);\n  return input !== undefined ? JSON.stringify(input) : undefined;\n};\n\nexport type Requester = (\n  opts: HTTPBaseRequestOptions & {\n    headers: () => HTTPHeaders | Promise<HTTPHeaders>;\n  },\n) => Promise<HTTPResult>;\n\nexport const jsonHttpRequester: Requester = (opts) => {\n  return httpRequest({\n    ...opts,\n    contentTypeHeader: 'application/json',\n    getUrl,\n    getBody,\n  });\n};\n\n/**\n * Polyfill for DOMException with AbortError name\n */\nclass AbortError extends Error {\n  constructor() {\n    const name = 'AbortError';\n    super(name);\n    this.name = name;\n    this.message = name;\n  }\n}\n\nexport type HTTPRequestOptions = ContentOptions &\n  HTTPBaseRequestOptions & {\n    headers: () => HTTPHeaders | Promise<HTTPHeaders>;\n  };\n\n/**\n * Polyfill for `signal.throwIfAborted()`\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/throwIfAborted\n */\nconst throwIfAborted = (signal: Maybe<AbortSignal>) => {\n  if (!signal?.aborted) {\n    return;\n  }\n  // If available, use the native implementation\n  signal.throwIfAborted?.();\n\n  // If we have `DOMException`, use it\n  if (typeof DOMException !== 'undefined') {\n    throw new DOMException('AbortError', 'AbortError');\n  }\n\n  // Otherwise, use our own implementation\n  throw new AbortError();\n};\n\nexport async function fetchHTTPResponse(opts: HTTPRequestOptions) {\n  throwIfAborted(opts.signal);\n\n  const url = opts.getUrl(opts);\n  const body = opts.getBody(opts);\n  const { type } = opts;\n  const resolvedHeaders = await (async () => {\n    const heads = await opts.headers();\n    if (Symbol.iterator in heads) {\n      return Object.fromEntries(heads);\n    }\n    return heads;\n  })();\n  const headers = {\n    ...(opts.contentTypeHeader\n      ? { 'content-type': opts.contentTypeHeader }\n      : {}),\n    ...(opts.trpcAcceptHeader\n      ? { 'trpc-accept': opts.trpcAcceptHeader }\n      : undefined),\n    ...resolvedHeaders,\n  };\n\n  return getFetch(opts.fetch)(url, {\n    method: opts.methodOverride ?? METHOD[type],\n    signal: opts.signal,\n    body,\n    headers,\n  });\n}\n\nexport async function httpRequest(\n  opts: HTTPRequestOptions,\n): Promise<HTTPResult> {\n  const meta = {} as HTTPResult['meta'];\n\n  const res = await fetchHTTPResponse(opts);\n  meta.response = res;\n\n  const json = await res.json();\n\n  meta.responseJSON = json;\n\n  return {\n    json: json as TRPCResponse,\n    meta,\n  };\n}\n", "export function isOctetType(input: unknown) {\n  return (\n    input instanceof Uint8Array ||\n    // File extends from Blob but is only available in nodejs from v20\n    input instanceof Blob\n  );\n}\n\nexport function isFormData(input: unknown) {\n  return input instanceof FormData;\n}\n\nexport function isNonJsonSerializable(input: unknown) {\n  return isOctetType(input) || isFormData(input);\n}\n", "import { observable } from '@trpc/server/observable';\nimport type {\n  AnyClientTypes,\n  AnyRouter,\n} from '@trpc/server/unstable-core-do-not-import';\nimport { transformResult } from '@trpc/server/unstable-core-do-not-import';\nimport { TRPCClientError } from '../TRPCClientError';\nimport type {\n  HTTPLinkBaseOptions,\n  HTTPResult,\n  Requester,\n} from './internals/httpUtils';\nimport {\n  getUrl,\n  httpRequest,\n  jsonHttpRequester,\n  resolveHTTPLinkOptions,\n} from './internals/httpUtils';\nimport {\n  isFormData,\n  isOctetType,\n  type HTTPHeaders,\n  type Operation,\n  type TRPCLink,\n} from './types';\n\nexport type HTTPLinkOptions<TRoot extends AnyClientTypes> =\n  HTTPLinkBaseOptions<TRoot> & {\n    /**\n     * Headers to be set on outgoing requests or a callback that of said headers\n     * @see http://trpc.io/docs/client/headers\n     */\n    headers?:\n      | HTTPHeaders\n      | ((opts: { op: Operation }) => HTTPHeaders | Promise<HTTPHeaders>);\n  };\n\nconst universalRequester: Requester = (opts) => {\n  if ('input' in opts) {\n    const { input } = opts;\n    if (isFormData(input)) {\n      if (opts.type !== 'mutation' && opts.methodOverride !== 'POST') {\n        throw new Error('FormData is only supported for mutations');\n      }\n\n      return httpRequest({\n        ...opts,\n        // The browser will set this automatically and include the boundary= in it\n        contentTypeHeader: undefined,\n        getUrl,\n        getBody: () => input,\n      });\n    }\n\n    if (isOctetType(input)) {\n      if (opts.type !== 'mutation' && opts.methodOverride !== 'POST') {\n        throw new Error('Octet type input is only supported for mutations');\n      }\n\n      return httpRequest({\n        ...opts,\n        contentTypeHeader: 'application/octet-stream',\n        getUrl,\n        getBody: () => input,\n      });\n    }\n  }\n\n  return jsonHttpRequester(opts);\n};\n\n/**\n * @see https://trpc.io/docs/client/links/httpLink\n */\nexport function httpLink<TRouter extends AnyRouter = AnyRouter>(\n  opts: HTTPLinkOptions<TRouter['_def']['_config']['$types']>,\n): TRPCLink<TRouter> {\n  const resolvedOpts = resolveHTTPLinkOptions(opts);\n  return () => {\n    return ({ op }) => {\n      return observable((observer) => {\n        const { path, input, type } = op;\n        /* istanbul ignore if -- @preserve */\n        if (type === 'subscription') {\n          throw new Error(\n            'Subscriptions are unsupported by `httpLink` - use `httpSubscriptionLink` or `wsLink`',\n          );\n        }\n\n        const request = universalRequester({\n          ...resolvedOpts,\n          type,\n          path,\n          input,\n          signal: op.signal,\n          headers() {\n            if (!opts.headers) {\n              return {};\n            }\n            if (typeof opts.headers === 'function') {\n              return opts.headers({\n                op,\n              });\n            }\n            return opts.headers;\n          },\n        });\n        let meta: HTTPResult['meta'] | undefined = undefined;\n        request\n          .then((res) => {\n            meta = res.meta;\n            const transformed = transformResult(\n              res.json,\n              resolvedOpts.transformer.output,\n            );\n\n            if (!transformed.ok) {\n              observer.error(\n                TRPCClientError.from(transformed.error, {\n                  meta,\n                }),\n              );\n              return;\n            }\n            observer.next({\n              context: res.meta,\n              result: transformed.result,\n            });\n            observer.complete();\n          })\n          .catch((cause) => {\n            observer.error(TRPCClientError.from(cause, { meta }));\n          });\n\n        return () => {\n          // noop\n        };\n      });\n    };\n  };\n}\n", "/// <reference lib=\"dom.iterable\" />\n\n// `dom.iterable` types are explicitly required for extracting `FormData` values,\n// as all implementations of `Symbol.iterable` are separated from the main `dom` types.\n// Using triple-slash directive makes sure that it will be available,\n// even if end-user `tsconfig.json` omits it in the `lib` array.\n\nimport { observable, tap } from '@trpc/server/observable';\nimport type {\n  AnyRouter,\n  InferrableClientTypes,\n} from '@trpc/server/unstable-core-do-not-import';\nimport type { TRPCClientError } from '../TRPCClientError';\nimport type { Operation, OperationResultEnvelope, TRPCLink } from './types';\n\ntype ConsoleEsque = {\n  log: (...args: any[]) => void;\n  error: (...args: any[]) => void;\n};\n\ntype EnableFnOptions<TRouter extends InferrableClientTypes> =\n  | {\n      direction: 'down';\n      result:\n        | OperationResultEnvelope<unknown, TRPCClientError<TRouter>>\n        | TRPCClientError<TRouter>;\n    }\n  | (Operation & {\n      direction: 'up';\n    });\ntype EnabledFn<TRouter extends AnyRouter> = (\n  opts: EnableFnOptions<TRouter>,\n) => boolean;\n\ntype LoggerLinkFnOptions<TRouter extends AnyRouter> = Operation &\n  (\n    | {\n        /**\n         * Request result\n         */\n        direction: 'down';\n        result:\n          | OperationResultEnvelope<unknown, TRPCClientError<TRouter>>\n          | TRPCClientError<TRouter>;\n        elapsedMs: number;\n      }\n    | {\n        /**\n         * Request was just initialized\n         */\n        direction: 'up';\n      }\n  );\n\ntype LoggerLinkFn<TRouter extends AnyRouter> = (\n  opts: LoggerLinkFnOptions<TRouter>,\n) => void;\n\ntype ColorMode = 'ansi' | 'css' | 'none';\n\nexport interface LoggerLinkOptions<TRouter extends AnyRouter> {\n  logger?: LoggerLinkFn<TRouter>;\n  enabled?: EnabledFn<TRouter>;\n  /**\n   * Used in the built-in defaultLogger\n   */\n  console?: ConsoleEsque;\n  /**\n   * Color mode\n   * @default typeof window === 'undefined' ? 'ansi' : 'css'\n   */\n  colorMode?: ColorMode;\n\n  /**\n   * Include context in the log - defaults to false unless `colorMode` is 'css'\n   */\n  withContext?: boolean;\n}\n\nfunction isFormData(value: unknown): value is FormData {\n  if (typeof FormData === 'undefined') {\n    // FormData is not supported\n    return false;\n  }\n  return value instanceof FormData;\n}\n\nconst palettes = {\n  css: {\n    query: ['72e3ff', '3fb0d8'],\n    mutation: ['c5a3fc', '904dfc'],\n    subscription: ['ff49e1', 'd83fbe'],\n  },\n  ansi: {\n    regular: {\n      // Cyan background, black and white text respectively\n      query: ['\\x1b[30;46m', '\\x1b[97;46m'],\n      // Magenta background, black and white text respectively\n      mutation: ['\\x1b[30;45m', '\\x1b[97;45m'],\n      // Green background, black and white text respectively\n      subscription: ['\\x1b[30;42m', '\\x1b[97;42m'],\n    },\n    bold: {\n      query: ['\\x1b[1;30;46m', '\\x1b[1;97;46m'],\n      mutation: ['\\x1b[1;30;45m', '\\x1b[1;97;45m'],\n      subscription: ['\\x1b[1;30;42m', '\\x1b[1;97;42m'],\n    },\n  },\n} as const;\n\nfunction constructPartsAndArgs(\n  opts: LoggerLinkFnOptions<any> & {\n    colorMode: ColorMode;\n    withContext?: boolean;\n  },\n) {\n  const { direction, type, withContext, path, id, input } = opts;\n\n  const parts: string[] = [];\n  const args: any[] = [];\n\n  if (opts.colorMode === 'none') {\n    parts.push(direction === 'up' ? '>>' : '<<', type, `#${id}`, path);\n  } else if (opts.colorMode === 'ansi') {\n    const [lightRegular, darkRegular] = palettes.ansi.regular[type];\n    const [lightBold, darkBold] = palettes.ansi.bold[type];\n    const reset = '\\x1b[0m';\n\n    parts.push(\n      direction === 'up' ? lightRegular : darkRegular,\n      direction === 'up' ? '>>' : '<<',\n      type,\n      direction === 'up' ? lightBold : darkBold,\n      `#${id}`,\n      path,\n      reset,\n    );\n  } else {\n    // css color mode\n    const [light, dark] = palettes.css[type];\n    const css = `\n    background-color: #${direction === 'up' ? light : dark};\n    color: ${direction === 'up' ? 'black' : 'white'};\n    padding: 2px;\n  `;\n\n    parts.push(\n      '%c',\n      direction === 'up' ? '>>' : '<<',\n      type,\n      `#${id}`,\n      `%c${path}%c`,\n      '%O',\n    );\n    args.push(\n      css,\n      `${css}; font-weight: bold;`,\n      `${css}; font-weight: normal;`,\n    );\n  }\n\n  if (direction === 'up') {\n    args.push(withContext ? { input, context: opts.context } : { input });\n  } else {\n    args.push({\n      input,\n      result: opts.result,\n      elapsedMs: opts.elapsedMs,\n      ...(withContext && { context: opts.context }),\n    });\n  }\n\n  return { parts, args };\n}\n\n// maybe this should be moved to it's own package\nconst defaultLogger =\n  <TRouter extends AnyRouter>({\n    c = console,\n    colorMode = 'css',\n    withContext,\n  }: {\n    c?: ConsoleEsque;\n    colorMode?: ColorMode;\n    withContext?: boolean;\n  }): LoggerLinkFn<TRouter> =>\n  (props) => {\n    const rawInput = props.input;\n    const input = isFormData(rawInput)\n      ? Object.fromEntries(rawInput)\n      : rawInput;\n\n    const { parts, args } = constructPartsAndArgs({\n      ...props,\n      colorMode,\n      input,\n      withContext,\n    });\n\n    const fn: 'error' | 'log' =\n      props.direction === 'down' &&\n      props.result &&\n      (props.result instanceof Error ||\n        ('error' in props.result.result && props.result.result.error))\n        ? 'error'\n        : 'log';\n\n    c[fn].apply(null, [parts.join(' ')].concat(args));\n  };\n\n/**\n * @see https://trpc.io/docs/v11/client/links/loggerLink\n */\nexport function loggerLink<TRouter extends AnyRouter = AnyRouter>(\n  opts: LoggerLinkOptions<TRouter> = {},\n): TRPCLink<TRouter> {\n  const { enabled = () => true } = opts;\n\n  const colorMode =\n    opts.colorMode ?? (typeof window === 'undefined' ? 'ansi' : 'css');\n  const withContext = opts.withContext ?? colorMode === 'css';\n  const {\n    logger = defaultLogger({ c: opts.console, colorMode, withContext }),\n  } = opts;\n\n  return () => {\n    return ({ op, next }) => {\n      return observable((observer) => {\n        // ->\n        if (enabled({ ...op, direction: 'up' })) {\n          logger({\n            ...op,\n            direction: 'up',\n          });\n        }\n        const requestStartTime = Date.now();\n        function logResult(\n          result:\n            | OperationResultEnvelope<unknown, TRPCClientError<TRouter>>\n            | TRPCClientError<TRouter>,\n        ) {\n          const elapsedMs = Date.now() - requestStartTime;\n\n          if (enabled({ ...op, direction: 'down', result })) {\n            logger({\n              ...op,\n              direction: 'down',\n              elapsedMs,\n              result,\n            });\n          }\n        }\n        return next(op)\n          .pipe(\n            tap({\n              next(result) {\n                logResult(result);\n              },\n              error(result) {\n                logResult(result);\n              },\n            }),\n          )\n          .subscribe(observer);\n      });\n    };\n  };\n}\n", "import type { UrlOptionsWithConnectionParams } from '../../internals/urlWithConnectionParams';\n\nexport interface WebSocketClientOptions extends UrlOptionsWithConnectionParams {\n  /**\n   * Ponyfill which WebSocket implementation to use\n   */\n  WebSocket?: typeof WebSocket;\n  /**\n   * The number of milliseconds before a reconnect is attempted.\n   * @default {@link exponentialBackoff}\n   */\n  retryDelayMs?: (attemptIndex: number) => number;\n  /**\n   * Triggered when a WebSocket connection is established\n   */\n  onOpen?: () => void;\n  /**\n   * Triggered when a WebSocket connection encounters an error\n   */\n  onError?: (evt?: Event) => void;\n  /**\n   * Triggered when a WebSocket connection is closed\n   */\n  onClose?: (cause?: { code?: number }) => void;\n  /**\n   * Lazy mode will close the WebSocket automatically after a period of inactivity (no messages sent or received and no pending requests)\n   */\n  lazy?: {\n    /**\n     * Enable lazy mode\n     * @default false\n     */\n    enabled: boolean;\n    /**\n     * Close the WebSocket after this many milliseconds\n     * @default 0\n     */\n    closeMs: number;\n  };\n  /**\n   * Send ping messages to the server and kill the connection if no pong message is returned\n   */\n  keepAlive?: {\n    /**\n     * @default false\n     */\n    enabled: boolean;\n    /**\n     * Send a ping message every this many milliseconds\n     * @default 5_000\n     */\n    intervalMs?: number;\n    /**\n     * Close the WebSocket after this many milliseconds if the server does not respond\n     * @default 1_000\n     */\n    pongTimeoutMs?: number;\n  };\n}\n\n/**\n * Default options for lazy WebSocket connections.\n * Determines whether the connection should be established lazily and defines the delay before closure.\n */\nexport type LazyOptions = Required<NonNullable<WebSocketClientOptions['lazy']>>;\nexport const lazyDefaults: LazyOptions = {\n  enabled: false,\n  closeMs: 0,\n};\n\n/**\n * Default options for the WebSocket keep-alive mechanism.\n * Configures whether keep-alive is enabled and specifies the timeout and interval for ping-pong messages.\n */\nexport type KeepAliveOptions = Required<\n  NonNullable<WebSocketClientOptions['keepAlive']>\n>;\nexport const keepAliveDefaults: KeepAliveOptions = {\n  enabled: false,\n  pongTimeoutMs: 1_000,\n  intervalMs: 5_000,\n};\n\n/**\n * Calculates a delay for exponential backoff based on the retry attempt index.\n * The delay starts at 0 for the first attempt and doubles for each subsequent attempt,\n * capped at 30 seconds.\n */\nexport const exponentialBackoff = (attemptIndex: number) => {\n  return attemptIndex === 0 ? 0 : Math.min(1000 * 2 ** attemptIndex, 30000);\n};\n", "import { type TRPCRequestInfo } from '@trpc/server/http';\n\n/**\n * Get the result of a value or function that returns a value\n * It also optionally accepts typesafe arguments for the function\n */\nexport const resultOf = <T, TArgs extends any[]>(\n  value: T | ((...args: TArgs) => T),\n  ...args: TArgs\n): T => {\n  return typeof value === 'function'\n    ? (value as (...args: TArgs) => T)(...args)\n    : value;\n};\n\n/**\n * A value that can be wrapped in callback\n */\nexport type CallbackOrValue<T> = T | (() => T | Promise<T>);\n\nexport interface UrlOptionsWithConnectionParams {\n  /**\n   * The URL to connect to (can be a function that returns a URL)\n   */\n  url: CallbackOrValue<string>;\n\n  /**\n   * Connection params that are available in `createContext()`\n   * - For `wsLink`/`wsClient`, these are sent as the first message\n   * - For `httpSubscriptionLink`, these are serialized as part of the URL under the `connectionParams` query\n   */\n  connectionParams?: CallbackOrValue<TRPCRequestInfo['connectionParams']>;\n}\n", "import type {\n  TRPCConnectionParamsMessage,\n  TRPCRequestInfo,\n} from '@trpc/server/unstable-core-do-not-import';\nimport type {\n  CallbackOrValue,\n  UrlOptionsWithConnectionParams,\n} from '../../internals/urlWithConnectionParams';\nimport { resultOf } from '../../internals/urlWithConnectionParams';\n\nexport class TRPCWebSocketClosedError extends Error {\n  constructor(opts: { message: string; cause?: unknown }) {\n    super(opts.message, {\n      cause: opts.cause,\n    });\n    this.name = 'TRPCWebSocketClosedError';\n    Object.setPrototypeOf(this, TRPCWebSocketClosedError.prototype);\n  }\n}\n\n/**\n * Utility class for managing a timeout that can be started, stopped, and reset.\n * Useful for scenarios where the timeout duration is reset dynamically based on events.\n */\nexport class ResettableTimeout {\n  private timeout: ReturnType<typeof setTimeout> | undefined;\n\n  constructor(\n    private readonly onTimeout: () => void,\n    private readonly timeoutMs: number,\n  ) {}\n\n  /**\n   * Resets the current timeout, restarting it with the same duration.\n   * Does nothing if no timeout is active.\n   */\n  public reset() {\n    if (!this.timeout) return;\n\n    clearTimeout(this.timeout);\n    this.timeout = setTimeout(this.onTimeout, this.timeoutMs);\n  }\n\n  public start() {\n    clearTimeout(this.timeout);\n    this.timeout = setTimeout(this.onTimeout, this.timeoutMs);\n  }\n\n  public stop() {\n    clearTimeout(this.timeout);\n    this.timeout = undefined;\n  }\n}\n\n// Ponyfill for Promise.withResolvers https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/withResolvers\nexport function withResolvers<T>() {\n  let resolve: (value: T | PromiseLike<T>) => void;\n  let reject: (reason?: any) => void;\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  return { promise, resolve: resolve!, reject: reject! };\n}\n\n/**\n * Resolves a WebSocket URL and optionally appends connection parameters.\n *\n * If connectionParams are provided, appends 'connectionParams=1' query parameter.\n */\nexport async function prepareUrl(urlOptions: UrlOptionsWithConnectionParams) {\n  const url = await resultOf(urlOptions.url);\n\n  if (!urlOptions.connectionParams) return url;\n\n  // append `?connectionParams=1` when connection params are used\n  const prefix = url.includes('?') ? '&' : '?';\n  const connectionParams = `${prefix}connectionParams=1`;\n\n  return url + connectionParams;\n}\n\nexport async function buildConnectionMessage(\n  connectionParams: CallbackOrValue<TRPCRequestInfo['connectionParams']>,\n) {\n  const message: TRPCConnectionParamsMessage = {\n    method: 'connectionParams',\n    data: await resultOf(connectionParams),\n  };\n\n  return JSON.stringify(message);\n}\n", "import type { AnyTRPCRouter, inferRouterError } from '@trpc/server';\nimport type { Observer } from '@trpc/server/observable';\nimport type {\n  TRPCClientOutgoingMessage,\n  TRPCResponseMessage,\n} from '@trpc/server/unstable-core-do-not-import';\nimport type { TRPCClientError } from '../../../TRPCClientError';\nimport { withResolvers } from './utils';\n\nexport type TCallbacks = Observer<\n  TRPCResponseMessage<unknown, inferRouterError<AnyTRPCRouter>>,\n  TRPCClientError<AnyTRPCRouter>\n>;\n\ntype MessageId = string;\ntype MessageIdLike = string | number | null;\n\n/**\n * Represents a WebSocket request managed by the RequestManager.\n * Combines the network message, a utility promise (`end`) that mirrors the lifecycle\n * handled by `callbacks`, and a set of state monitoring callbacks.\n */\ninterface Request {\n  message: TRPCClientOutgoingMessage;\n  end: Promise<void>;\n  callbacks: TCallbacks;\n}\n\n/**\n * Manages WebSocket requests, tracking their lifecycle and providing utility methods\n * for handling outgoing and pending requests.\n *\n * - **Outgoing requests**: Requests that are queued and waiting to be sent.\n * - **Pending requests**: Requests that have been sent and are in flight awaiting a response.\n *   For subscriptions, multiple responses may be received until the subscription is closed.\n */\nexport class RequestManager {\n  /**\n   * Stores requests that are outgoing, meaning they are registered but not yet sent over the WebSocket.\n   */\n  private outgoingRequests = new Array<Request & { id: MessageId }>();\n\n  /**\n   * Stores requests that are pending (in flight), meaning they have been sent over the WebSocket\n   * and are awaiting responses. For subscriptions, this includes requests\n   * that may receive multiple responses.\n   */\n  private pendingRequests: Record<MessageId, Request> = {};\n\n  /**\n   * Registers a new request by adding it to the outgoing queue and setting up\n   * callbacks for lifecycle events such as completion or error.\n   *\n   * @param message - The outgoing message to be sent.\n   * @param callbacks - Callback functions to observe the request's state.\n   * @returns A cleanup function to manually remove the request.\n   */\n  public register(message: TRPCClientOutgoingMessage, callbacks: TCallbacks) {\n    const { promise: end, resolve } = withResolvers<void>();\n\n    this.outgoingRequests.push({\n      id: String(message.id),\n      message,\n      end,\n      callbacks: {\n        next: callbacks.next,\n        complete: () => {\n          callbacks.complete();\n          resolve();\n        },\n        error: (e) => {\n          callbacks.error(e);\n          resolve();\n        },\n      },\n    });\n\n    return () => {\n      this.delete(message.id);\n      callbacks.complete();\n      resolve();\n    };\n  }\n\n  /**\n   * Deletes a request from both the outgoing and pending collections, if it exists.\n   */\n  public delete(messageId: MessageIdLike) {\n    if (messageId === null) return;\n\n    this.outgoingRequests = this.outgoingRequests.filter(\n      ({ id }) => id !== String(messageId),\n    );\n    delete this.pendingRequests[String(messageId)];\n  }\n\n  /**\n   * Moves all outgoing requests to the pending state and clears the outgoing queue.\n   *\n   * The caller is expected to handle the actual sending of the requests\n   * (e.g., sending them over the network) after this method is called.\n   *\n   * @returns The list of requests that were transitioned to the pending state.\n   */\n  public flush() {\n    const requests = this.outgoingRequests;\n    this.outgoingRequests = [];\n\n    for (const request of requests) {\n      this.pendingRequests[request.id] = request;\n    }\n    return requests;\n  }\n\n  /**\n   * Retrieves all currently pending requests, which are in flight awaiting responses\n   * or handling ongoing subscriptions.\n   */\n  public getPendingRequests() {\n    return Object.values(this.pendingRequests);\n  }\n\n  /**\n   * Retrieves a specific pending request by its message ID.\n   */\n  public getPendingRequest(messageId: MessageIdLike) {\n    if (messageId === null) return null;\n\n    return this.pendingRequests[String(messageId)];\n  }\n\n  /**\n   * Retrieves all outgoing requests, which are waiting to be sent.\n   */\n  public getOutgoingRequests() {\n    return this.outgoingRequests;\n  }\n\n  /**\n   * Retrieves all requests, both outgoing and pending, with their respective states.\n   *\n   * @returns An array of all requests with their state (\"outgoing\" or \"pending\").\n   */\n  public getRequests() {\n    return [\n      ...this.getOutgoingRequests().map((request) => ({\n        state: 'outgoing' as const,\n        message: request.message,\n        end: request.end,\n        callbacks: request.callbacks,\n      })),\n      ...this.getPendingRequests().map((request) => ({\n        state: 'pending' as const,\n        message: request.message,\n        end: request.end,\n        callbacks: request.callbacks,\n      })),\n    ];\n  }\n\n  /**\n   * Checks if there are any pending requests, including ongoing subscriptions.\n   */\n  public hasPendingRequests() {\n    return this.getPendingRequests().length > 0;\n  }\n\n  /**\n   * Checks if there are any pending subscriptions\n   */\n  public hasPendingSubscriptions() {\n    return this.getPendingRequests().some(\n      (request) => request.message.method === 'subscription',\n    );\n  }\n\n  /**\n   * Checks if there are any outgoing requests waiting to be sent.\n   */\n  public hasOutgoingRequests() {\n    return this.outgoingRequests.length > 0;\n  }\n}\n", "import { behaviorSubject } from '@trpc/server/observable';\nimport type { UrlOptionsWithConnectionParams } from '../../internals/urlWithConnectionParams';\nimport { buildConnectionMessage, prepareUrl, withResolvers } from './utils';\n\n/**\n * Opens a WebSocket connection asynchronously and returns a promise\n * that resolves when the connection is successfully established.\n * The promise rejects if an error occurs during the connection attempt.\n */\nfunction asyncWsOpen(ws: WebSocket) {\n  const { promise, resolve, reject } = withResolvers<void>();\n\n  ws.addEventListener('open', () => {\n    ws.removeEventListener('error', reject);\n    resolve();\n  });\n  ws.addEventListener('error', reject);\n\n  return promise;\n}\n\ninterface PingPongOptions {\n  /**\n   * The interval (in milliseconds) between \"PING\" messages.\n   */\n  intervalMs: number;\n\n  /**\n   * The timeout (in milliseconds) to wait for a \"PONG\" response before closing the connection.\n   */\n  pongTimeoutMs: number;\n}\n\n/**\n * Sets up a periodic ping-pong mechanism to keep the WebSocket connection alive.\n *\n * - Sends \"PING\" messages at regular intervals defined by `intervalMs`.\n * - If a \"PONG\" response is not received within the `pongTimeoutMs`, the WebSocket is closed.\n * - The ping timer resets upon receiving any message to maintain activity.\n * - Automatically starts the ping process when the WebSocket connection is opened.\n * - Cleans up timers when the WebSocket is closed.\n *\n * @param ws - The WebSocket instance to manage.\n * @param options - Configuration options for ping-pong intervals and timeouts.\n */\nfunction setupPingInterval(\n  ws: WebSocket,\n  { intervalMs, pongTimeoutMs }: PingPongOptions,\n) {\n  let pingTimeout: ReturnType<typeof setTimeout> | undefined;\n  let pongTimeout: ReturnType<typeof setTimeout> | undefined;\n\n  function start() {\n    pingTimeout = setTimeout(() => {\n      ws.send('PING');\n      pongTimeout = setTimeout(() => {\n        ws.close();\n      }, pongTimeoutMs);\n    }, intervalMs);\n  }\n\n  function reset() {\n    clearTimeout(pingTimeout);\n    start();\n  }\n\n  function pong() {\n    clearTimeout(pongTimeout);\n    reset();\n  }\n\n  ws.addEventListener('open', start);\n  ws.addEventListener('message', ({ data }) => {\n    clearTimeout(pingTimeout);\n    start();\n\n    if (data === 'PONG') {\n      pong();\n    }\n  });\n  ws.addEventListener('close', () => {\n    clearTimeout(pingTimeout);\n    clearTimeout(pongTimeout);\n  });\n}\n\nexport interface WebSocketConnectionOptions {\n  WebSocketPonyfill?: typeof WebSocket;\n  urlOptions: UrlOptionsWithConnectionParams;\n  keepAlive: PingPongOptions & {\n    enabled: boolean;\n  };\n}\n\n/**\n * Manages a WebSocket connection with support for reconnection, keep-alive mechanisms,\n * and observable state tracking.\n */\nexport class WsConnection {\n  static connectCount = 0;\n  public id = ++WsConnection.connectCount;\n\n  private readonly WebSocketPonyfill: typeof WebSocket;\n  private readonly urlOptions: UrlOptionsWithConnectionParams;\n  private readonly keepAliveOpts: WebSocketConnectionOptions['keepAlive'];\n  public readonly wsObservable = behaviorSubject<WebSocket | null>(null);\n\n  constructor(opts: WebSocketConnectionOptions) {\n    this.WebSocketPonyfill = opts.WebSocketPonyfill ?? WebSocket;\n    if (!this.WebSocketPonyfill) {\n      throw new Error(\n        \"No WebSocket implementation found - you probably don't want to use this on the server, but if you do you need to pass a `WebSocket`-ponyfill\",\n      );\n    }\n\n    this.urlOptions = opts.urlOptions;\n    this.keepAliveOpts = opts.keepAlive;\n  }\n\n  public get ws() {\n    return this.wsObservable.get();\n  }\n\n  private set ws(ws) {\n    this.wsObservable.next(ws);\n  }\n\n  /**\n   * Checks if the WebSocket connection is open and ready to communicate.\n   */\n  public isOpen(): this is { ws: WebSocket } {\n    return (\n      !!this.ws &&\n      this.ws.readyState === this.WebSocketPonyfill.OPEN &&\n      !this.openPromise\n    );\n  }\n\n  /**\n   * Checks if the WebSocket connection is closed or in the process of closing.\n   */\n  public isClosed(): this is { ws: WebSocket } {\n    return (\n      !!this.ws &&\n      (this.ws.readyState === this.WebSocketPonyfill.CLOSING ||\n        this.ws.readyState === this.WebSocketPonyfill.CLOSED)\n    );\n  }\n\n  /**\n   * Manages the WebSocket opening process, ensuring that only one open operation\n   * occurs at a time. Tracks the ongoing operation with `openPromise` to avoid\n   * redundant calls and ensure proper synchronization.\n   *\n   * Sets up the keep-alive mechanism and necessary event listeners for the connection.\n   *\n   * @returns A promise that resolves once the WebSocket connection is successfully opened.\n   */\n  private openPromise: Promise<void> | null = null;\n  public async open() {\n    if (this.openPromise) return this.openPromise;\n\n    this.id = ++WsConnection.connectCount;\n    const wsPromise = prepareUrl(this.urlOptions).then(\n      (url) => new this.WebSocketPonyfill(url),\n    );\n    this.openPromise = wsPromise.then(async (ws) => {\n      this.ws = ws;\n\n      // Setup ping listener\n      ws.addEventListener('message', function ({ data }) {\n        if (data === 'PING') {\n          this.send('PONG');\n        }\n      });\n\n      if (this.keepAliveOpts.enabled) {\n        setupPingInterval(ws, this.keepAliveOpts);\n      }\n\n      ws.addEventListener('close', () => {\n        if (this.ws === ws) {\n          this.ws = null;\n        }\n      });\n\n      await asyncWsOpen(ws);\n\n      if (this.urlOptions.connectionParams) {\n        ws.send(await buildConnectionMessage(this.urlOptions.connectionParams));\n      }\n    });\n\n    try {\n      await this.openPromise;\n    } finally {\n      this.openPromise = null;\n    }\n  }\n\n  /**\n   * Closes the WebSocket connection gracefully.\n   * Waits for any ongoing open operation to complete before closing.\n   */\n  public async close() {\n    try {\n      await this.openPromise;\n    } finally {\n      this.ws?.close();\n    }\n  }\n}\n\n/**\n * Provides a backward-compatible representation of the connection state.\n */\nexport function backwardCompatibility(connection: WsConnection) {\n  if (connection.isOpen()) {\n    return {\n      id: connection.id,\n      state: 'open',\n      ws: connection.ws,\n    } as const;\n  }\n\n  if (connection.isClosed()) {\n    return {\n      id: connection.id,\n      state: 'closed',\n      ws: connection.ws,\n    } as const;\n  }\n\n  if (!connection.ws) {\n    return null;\n  }\n\n  return {\n    id: connection.id,\n    state: 'connecting',\n    ws: connection.ws,\n  } as const;\n}\n", "import type { AnyTRPCRouter } from '@trpc/server';\nimport type { BehaviorSubject } from '@trpc/server/observable';\nimport { behaviorSubject, observable } from '@trpc/server/observable';\nimport type {\n  CombinedDataTransformer,\n  TRPCClientIncomingMessage,\n  TRPCClientIncomingRequest,\n  TRPCClientOutgoingMessage,\n  TRPCResponseMessage,\n} from '@trpc/server/unstable-core-do-not-import';\nimport {\n  run,\n  sleep,\n  transformResult,\n} from '@trpc/server/unstable-core-do-not-import';\nimport { TRPCClientError } from '../../../TRPCClientError';\nimport type { TRPCConnectionState } from '../../internals/subscriptions';\nimport type { Operation, OperationResultEnvelope } from '../../types';\nimport type { WebSocketClientOptions } from './options';\nimport { exponentialBackoff, keepAliveDefaults, lazyDefaults } from './options';\nimport type { TCallbacks } from './requestManager';\nimport { RequestManager } from './requestManager';\nimport { ResettableTimeout, TRPCWebSocketClosedError } from './utils';\nimport { backwardCompatibility, WsConnection } from './wsConnection';\n\n/**\n * A WebSocket client for managing TRPC operations, supporting lazy initialization,\n * reconnection, keep-alive, and request management.\n */\nexport class WsClient {\n  /**\n   * Observable tracking the current connection state, including errors.\n   */\n  public readonly connectionState: BehaviorSubject<\n    TRPCConnectionState<TRPCClientError<AnyTRPCRouter>>\n  >;\n\n  private allowReconnect = false;\n  private requestManager = new RequestManager();\n  private readonly activeConnection: WsConnection;\n  private readonly reconnectRetryDelay: (attemptIndex: number) => number;\n  private inactivityTimeout: ResettableTimeout;\n  private readonly callbacks: Pick<\n    WebSocketClientOptions,\n    'onOpen' | 'onClose' | 'onError'\n  >;\n  private readonly lazyMode: boolean;\n\n  constructor(opts: WebSocketClientOptions) {\n    // Initialize callbacks, connection parameters, and options.\n    this.callbacks = {\n      onOpen: opts.onOpen,\n      onClose: opts.onClose,\n      onError: opts.onError,\n    };\n\n    const lazyOptions = {\n      ...lazyDefaults,\n      ...opts.lazy,\n    };\n\n    // Set up inactivity timeout for lazy connections.\n    this.inactivityTimeout = new ResettableTimeout(() => {\n      if (\n        this.requestManager.hasOutgoingRequests() ||\n        this.requestManager.hasPendingRequests()\n      ) {\n        this.inactivityTimeout.reset();\n        return;\n      }\n\n      this.close().catch(() => null);\n    }, lazyOptions.closeMs);\n\n    // Initialize the WebSocket connection.\n    this.activeConnection = new WsConnection({\n      WebSocketPonyfill: opts.WebSocket,\n      urlOptions: opts,\n      keepAlive: {\n        ...keepAliveDefaults,\n        ...opts.keepAlive,\n      },\n    });\n    this.activeConnection.wsObservable.subscribe({\n      next: (ws) => {\n        if (!ws) return;\n        this.setupWebSocketListeners(ws);\n      },\n    });\n    this.reconnectRetryDelay = opts.retryDelayMs ?? exponentialBackoff;\n\n    this.lazyMode = lazyOptions.enabled;\n\n    this.connectionState = behaviorSubject<\n      TRPCConnectionState<TRPCClientError<AnyTRPCRouter>>\n    >({\n      type: 'state',\n      state: lazyOptions.enabled ? 'idle' : 'connecting',\n      error: null,\n    });\n\n    // Automatically open the connection if lazy mode is disabled.\n    if (!this.lazyMode) {\n      this.open().catch(() => null);\n    }\n  }\n\n  /**\n   * Opens the WebSocket connection. Handles reconnection attempts and updates\n   * the connection state accordingly.\n   */\n  private async open() {\n    this.allowReconnect = true;\n    if (this.connectionState.get().state !== 'connecting') {\n      this.connectionState.next({\n        type: 'state',\n        state: 'connecting',\n        error: null,\n      });\n    }\n\n    try {\n      await this.activeConnection.open();\n    } catch (error) {\n      this.reconnect(\n        new TRPCWebSocketClosedError({\n          message: 'Initialization error',\n          cause: error,\n        }),\n      );\n      return this.reconnecting;\n    }\n  }\n\n  /**\n   * Closes the WebSocket connection and stops managing requests.\n   * Ensures all outgoing and pending requests are properly finalized.\n   */\n  public async close() {\n    this.allowReconnect = false;\n    this.inactivityTimeout.stop();\n\n    const requestsToAwait: Promise<void>[] = [];\n    for (const request of this.requestManager.getRequests()) {\n      if (request.message.method === 'subscription') {\n        request.callbacks.complete();\n      } else if (request.state === 'outgoing') {\n        request.callbacks.error(\n          TRPCClientError.from(\n            new TRPCWebSocketClosedError({\n              message: 'Closed before connection was established',\n            }),\n          ),\n        );\n      } else {\n        requestsToAwait.push(request.end);\n      }\n    }\n\n    await Promise.all(requestsToAwait).catch(() => null);\n    await this.activeConnection.close().catch(() => null);\n\n    this.connectionState.next({\n      type: 'state',\n      state: 'idle',\n      error: null,\n    });\n  }\n\n  /**\n   * Method to request the server.\n   * Handles data transformation, batching of requests, and subscription lifecycle.\n   *\n   * @param op - The operation details including id, type, path, input and signal\n   * @param transformer - Data transformer for serializing requests and deserializing responses\n   * @param lastEventId - Optional ID of the last received event for subscriptions\n   *\n   * @returns An observable that emits operation results and handles cleanup\n   */\n  public request({\n    op: { id, type, path, input, signal },\n    transformer,\n    lastEventId,\n  }: {\n    op: Pick<Operation, 'id' | 'type' | 'path' | 'input' | 'signal'>;\n    transformer: CombinedDataTransformer;\n    lastEventId?: string;\n  }) {\n    return observable<\n      OperationResultEnvelope<unknown, TRPCClientError<AnyTRPCRouter>>,\n      TRPCClientError<AnyTRPCRouter>\n    >((observer) => {\n      const abort = this.batchSend(\n        {\n          id,\n          method: type,\n          params: {\n            input: transformer.input.serialize(input),\n            path,\n            lastEventId,\n          },\n        },\n        {\n          ...observer,\n          next(event) {\n            const transformed = transformResult(event, transformer.output);\n\n            if (!transformed.ok) {\n              observer.error(TRPCClientError.from(transformed.error));\n              return;\n            }\n\n            observer.next({\n              result: transformed.result,\n            });\n          },\n        },\n      );\n\n      return () => {\n        abort();\n\n        if (type === 'subscription' && this.activeConnection.isOpen()) {\n          this.send({\n            id,\n            method: 'subscription.stop',\n          });\n        }\n\n        signal?.removeEventListener('abort', abort);\n      };\n    });\n  }\n\n  public get connection() {\n    return backwardCompatibility(this.activeConnection);\n  }\n\n  /**\n   * Manages the reconnection process for the WebSocket using retry logic.\n   * Ensures that only one reconnection attempt is active at a time by tracking the current\n   * reconnection state in the `reconnecting` promise.\n   */\n  private reconnecting: Promise<void> | null = null;\n  private reconnect(closedError: TRPCWebSocketClosedError) {\n    this.connectionState.next({\n      type: 'state',\n      state: 'connecting',\n      error: TRPCClientError.from(closedError),\n    });\n    if (this.reconnecting) return;\n\n    const tryReconnect = async (attemptIndex: number) => {\n      try {\n        await sleep(this.reconnectRetryDelay(attemptIndex));\n        if (this.allowReconnect) {\n          await this.activeConnection.close();\n          await this.activeConnection.open();\n\n          if (this.requestManager.hasPendingRequests()) {\n            this.send(\n              this.requestManager\n                .getPendingRequests()\n                .map(({ message }) => message),\n            );\n          }\n        }\n        this.reconnecting = null;\n      } catch {\n        await tryReconnect(attemptIndex + 1);\n      }\n    };\n\n    this.reconnecting = tryReconnect(0);\n  }\n\n  private setupWebSocketListeners(ws: WebSocket) {\n    const handleCloseOrError = (cause: unknown) => {\n      const reqs = this.requestManager.getPendingRequests();\n      for (const { message, callbacks } of reqs) {\n        if (message.method === 'subscription') continue;\n\n        callbacks.error(\n          TRPCClientError.from(\n            cause ??\n              new TRPCWebSocketClosedError({\n                message: 'WebSocket closed',\n                cause,\n              }),\n          ),\n        );\n        this.requestManager.delete(message.id);\n      }\n    };\n\n    ws.addEventListener('open', () => {\n      run(async () => {\n        if (this.lazyMode) {\n          this.inactivityTimeout.start();\n        }\n\n        this.callbacks.onOpen?.();\n\n        this.connectionState.next({\n          type: 'state',\n          state: 'pending',\n          error: null,\n        });\n      }).catch((error) => {\n        ws.close(3000);\n        handleCloseOrError(error);\n      });\n    });\n\n    ws.addEventListener('message', ({ data }) => {\n      this.inactivityTimeout.reset();\n\n      if (typeof data !== 'string' || ['PING', 'PONG'].includes(data)) return;\n\n      const incomingMessage = JSON.parse(data) as TRPCClientIncomingMessage;\n      if ('method' in incomingMessage) {\n        this.handleIncomingRequest(incomingMessage);\n        return;\n      }\n\n      this.handleResponseMessage(incomingMessage);\n    });\n\n    ws.addEventListener('close', (event) => {\n      handleCloseOrError(event);\n      this.callbacks.onClose?.(event);\n\n      if (!this.lazyMode || this.requestManager.hasPendingSubscriptions()) {\n        this.reconnect(\n          new TRPCWebSocketClosedError({\n            message: 'WebSocket closed',\n            cause: event,\n          }),\n        );\n      }\n    });\n\n    ws.addEventListener('error', (event) => {\n      handleCloseOrError(event);\n      this.callbacks.onError?.(event);\n\n      this.reconnect(\n        new TRPCWebSocketClosedError({\n          message: 'WebSocket closed',\n          cause: event,\n        }),\n      );\n    });\n  }\n\n  private handleResponseMessage(message: TRPCResponseMessage) {\n    const request = this.requestManager.getPendingRequest(message.id);\n    if (!request) return;\n\n    request.callbacks.next(message);\n\n    let completed = true;\n    if ('result' in message && request.message.method === 'subscription') {\n      if (message.result.type === 'data') {\n        request.message.params.lastEventId = message.result.id;\n      }\n\n      if (message.result.type !== 'stopped') {\n        completed = false;\n      }\n    }\n\n    if (completed) {\n      request.callbacks.complete();\n      this.requestManager.delete(message.id);\n    }\n  }\n\n  private handleIncomingRequest(message: TRPCClientIncomingRequest) {\n    if (message.method === 'reconnect') {\n      this.reconnect(\n        new TRPCWebSocketClosedError({\n          message: 'Server requested reconnect',\n        }),\n      );\n    }\n  }\n\n  /**\n   * Sends a message or batch of messages directly to the server.\n   */\n  private send(\n    messageOrMessages: TRPCClientOutgoingMessage | TRPCClientOutgoingMessage[],\n  ) {\n    if (!this.activeConnection.isOpen()) {\n      throw new Error('Active connection is not open');\n    }\n\n    const messages =\n      messageOrMessages instanceof Array\n        ? messageOrMessages\n        : [messageOrMessages];\n    this.activeConnection.ws.send(\n      JSON.stringify(messages.length === 1 ? messages[0] : messages),\n    );\n  }\n\n  /**\n   * Groups requests for batch sending.\n   *\n   * @returns A function to abort the batched request.\n   */\n  private batchSend(message: TRPCClientOutgoingMessage, callbacks: TCallbacks) {\n    this.inactivityTimeout.reset();\n\n    run(async () => {\n      if (!this.activeConnection.isOpen()) {\n        await this.open();\n      }\n      await sleep(0);\n\n      if (!this.requestManager.hasOutgoingRequests()) return;\n\n      this.send(this.requestManager.flush().map(({ message }) => message));\n    }).catch((err) => {\n      this.requestManager.delete(message.id);\n      callbacks.error(TRPCClientError.from(err));\n    });\n\n    return this.requestManager.register(message, callbacks);\n  }\n}\n", "import type { WebSocketClientOptions } from './wsClient/options';\nimport { WsClient } from './wsClient/wsClient';\n\nexport function createWSClient(opts: WebSocketClientOptions) {\n  return new WsClient(opts);\n}\n\nexport type TRPCWebSocketClient = ReturnType<typeof createWSClient>;\n\nexport { WebSocketClientOptions };\n", "import { observable } from '@trpc/server/observable';\nimport type {\n  AnyRouter,\n  inferClientTypes,\n} from '@trpc/server/unstable-core-do-not-import';\nimport type { TransformerOptions } from '../../unstable-internals';\nimport { getTransformer } from '../../unstable-internals';\nimport type { TRPCLink } from '../types';\nimport type {\n  TRPCWebSocketClient,\n  WebSocketClientOptions,\n} from './createWsClient';\nimport { createWSClient } from './createWsClient';\n\nexport type WebSocketLinkOptions<TRouter extends AnyRouter> = {\n  client: TRPCWebSocketClient;\n} & TransformerOptions<inferClientTypes<TRouter>>;\n\nexport function wsLink<TRouter extends AnyRouter>(\n  opts: WebSocketLinkOptions<TRouter>,\n): TRPCLink<TRouter> {\n  const { client } = opts;\n  const transformer = getTransformer(opts.transformer);\n  return () => {\n    return ({ op }) => {\n      return observable((observer) => {\n        const connStateSubscription =\n          op.type === 'subscription'\n            ? client.connectionState.subscribe({\n                next(result) {\n                  observer.next({\n                    result,\n                    context: op.context,\n                  });\n                },\n              })\n            : null;\n\n        const requestSubscription = client\n          .request({\n            op,\n            transformer,\n          })\n          .subscribe(observer);\n\n        return () => {\n          requestSubscription.unsubscribe();\n          connStateSubscription?.unsubscribe();\n        };\n      });\n    };\n  };\n}\n\nexport { TRPCWebSocketClient, WebSocketClientOptions, createWSClient };\n", "import type {\n  inferObservableValue,\n  Unsubscribable,\n} from '@trpc/server/observable';\nimport { observableToPromise, share } from '@trpc/server/observable';\nimport type {\n  AnyRouter,\n  inferAsyncIterableYield,\n  InferrableClientTypes,\n  Maybe,\n  TypeError,\n} from '@trpc/server/unstable-core-do-not-import';\nimport { createChain } from '../links/internals/createChain';\nimport type { TRPCConnectionState } from '../links/internals/subscriptions';\nimport type {\n  OperationContext,\n  OperationLink,\n  TRPCClientRuntime,\n  TRPCLink,\n} from '../links/types';\nimport { TRPCClientError } from '../TRPCClientError';\n\ntype TRPCType = 'mutation' | 'query' | 'subscription';\nexport interface TRPCRequestOptions {\n  /**\n   * Pass additional context to links\n   */\n  context?: OperationContext;\n  signal?: AbortSignal;\n}\n\nexport interface TRPCSubscriptionObserver<TValue, TError> {\n  onStarted: (opts: { context: OperationContext | undefined }) => void;\n  onData: (value: inferAsyncIterableYield<TValue>) => void;\n  onError: (err: TError) => void;\n  onStopped: () => void;\n  onComplete: () => void;\n  onConnectionStateChange: (state: TRPCConnectionState<TError>) => void;\n}\n\n/** @internal */\nexport type CreateTRPCClientOptions<TRouter extends InferrableClientTypes> = {\n  links: TRPCLink<TRouter>[];\n  transformer?: TypeError<'The transformer property has moved to httpLink/httpBatchLink/wsLink'>;\n};\n\nexport class TRPCUntypedClient<TInferrable extends InferrableClientTypes> {\n  private readonly links: OperationLink<TInferrable>[];\n  public readonly runtime: TRPCClientRuntime;\n  private requestId: number;\n\n  constructor(opts: CreateTRPCClientOptions<TInferrable>) {\n    this.requestId = 0;\n\n    this.runtime = {};\n\n    // Initialize the links\n    this.links = opts.links.map((link) => link(this.runtime));\n  }\n\n  private $request<TInput = unknown, TOutput = unknown>(opts: {\n    type: TRPCType;\n    input: TInput;\n    path: string;\n    context?: OperationContext;\n    signal: Maybe<AbortSignal>;\n  }) {\n    const chain$ = createChain<AnyRouter, TInput, TOutput>({\n      links: this.links as OperationLink<any, any, any>[],\n      op: {\n        ...opts,\n        context: opts.context ?? {},\n        id: ++this.requestId,\n      },\n    });\n    return chain$.pipe(share());\n  }\n\n  private async requestAsPromise<TInput = unknown, TOutput = unknown>(opts: {\n    type: TRPCType;\n    input: TInput;\n    path: string;\n    context?: OperationContext;\n    signal: Maybe<AbortSignal>;\n  }): Promise<TOutput> {\n    try {\n      const req$ = this.$request<TInput, TOutput>(opts);\n      type TValue = inferObservableValue<typeof req$>;\n\n      const envelope = await observableToPromise<TValue>(req$);\n      const data = (envelope.result as any).data;\n      return data;\n    } catch (err) {\n      throw TRPCClientError.from(err as Error);\n    }\n  }\n  public query(path: string, input?: unknown, opts?: TRPCRequestOptions) {\n    return this.requestAsPromise<unknown, unknown>({\n      type: 'query',\n      path,\n      input,\n      context: opts?.context,\n      signal: opts?.signal,\n    });\n  }\n  public mutation(path: string, input?: unknown, opts?: TRPCRequestOptions) {\n    return this.requestAsPromise<unknown, unknown>({\n      type: 'mutation',\n      path,\n      input,\n      context: opts?.context,\n      signal: opts?.signal,\n    });\n  }\n  public subscription(\n    path: string,\n    input: unknown,\n    opts: Partial<\n      TRPCSubscriptionObserver<unknown, TRPCClientError<AnyRouter>>\n    > &\n      TRPCRequestOptions,\n  ): Unsubscribable {\n    const observable$ = this.$request({\n      type: 'subscription',\n      path,\n      input,\n      context: opts.context,\n      signal: opts.signal,\n    });\n    return observable$.subscribe({\n      next(envelope) {\n        switch (envelope.result.type) {\n          case 'state': {\n            opts.onConnectionStateChange?.(envelope.result);\n            break;\n          }\n          case 'started': {\n            opts.onStarted?.({\n              context: envelope.context,\n            });\n            break;\n          }\n          case 'stopped': {\n            opts.onStopped?.();\n            break;\n          }\n          case 'data':\n          case undefined: {\n            opts.onData?.(envelope.result.data);\n            break;\n          }\n        }\n      },\n      error(err) {\n        opts.onError?.(err);\n      },\n      complete() {\n        opts.onComplete?.();\n      },\n    });\n  }\n}\n", "import type { AnyRouter } from '@trpc/server/unstable-core-do-not-import';\nimport type { CreateTRPCClientOptions } from './internals/TRPCUntypedClient';\nimport { TRPCUntypedClient } from './internals/TRPCUntypedClient';\n\nexport function createTRPCUntypedClient<TRouter extends AnyRouter>(\n  opts: CreateTRPCClientOptions<TRouter>,\n): TRPCUntypedClient<TRouter> {\n  return new TRPCUntypedClient(opts);\n}\n\nexport type {\n  CreateTRPCClientOptions,\n  TRPCRequestOptions,\n} from './internals/TRPCUntypedClient';\nexport { TRPCUntypedClient } from './internals/TRPCUntypedClient';\n", "/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport type { Unsubscribable } from '@trpc/server/observable';\nimport type {\n  AnyProcedure,\n  AnyRouter,\n  inferClientTypes,\n  inferProcedureInput,\n  InferrableClientTypes,\n  inferTransformedProcedureOutput,\n  ProcedureType,\n  RouterRecord,\n} from '@trpc/server/unstable-core-do-not-import';\nimport {\n  createFlatProxy,\n  createRecursiveProxy,\n} from '@trpc/server/unstable-core-do-not-import';\nimport type { CreateTRPCClientOptions } from './createTRPCUntypedClient';\nimport type { TRPCSubscriptionObserver } from './internals/TRPCUntypedClient';\nimport { TRPCUntypedClient } from './internals/TRPCUntypedClient';\nimport type { TRPCProcedureOptions } from './internals/types';\nimport type { TRPCClientError } from './TRPCClientError';\n\n/**\n * @public\n * @deprecated use {@link TRPCClient} instead, will be removed in v12\n **/\nexport type inferRouterClient<TRouter extends AnyRouter> = TRPCClient<TRouter>;\n\n/**\n * @public\n * @deprecated use {@link TRPCClient} instead, will be removed in v12\n **/\nexport type CreateTRPCClient<TRouter extends AnyRouter> = TRPCClient<TRouter>;\n\nconst untypedClientSymbol = Symbol.for('trpc_untypedClient');\n\n/**\n * @public\n **/\nexport type TRPCClient<TRouter extends AnyRouter> = DecoratedProcedureRecord<\n  {\n    transformer: TRouter['_def']['_config']['$types']['transformer'];\n    errorShape: TRouter['_def']['_config']['$types']['errorShape'];\n  },\n  TRouter['_def']['record']\n> & {\n  [untypedClientSymbol]: TRPCUntypedClient<TRouter>;\n};\n\ntype ResolverDef = {\n  input: any;\n  output: any;\n  transformer: boolean;\n  errorShape: any;\n};\n\ntype coerceAsyncGeneratorToIterable<T> =\n  T extends AsyncGenerator<infer $T, infer $Return, infer $Next>\n    ? AsyncIterable<$T, $Return, $Next>\n    : T;\n\n/** @internal */\nexport type Resolver<TDef extends ResolverDef> = (\n  input: TDef['input'],\n  opts?: TRPCProcedureOptions,\n) => Promise<coerceAsyncGeneratorToIterable<TDef['output']>>;\n\ntype SubscriptionResolver<TDef extends ResolverDef> = (\n  input: TDef['input'],\n  opts: Partial<\n    TRPCSubscriptionObserver<TDef['output'], TRPCClientError<TDef>>\n  > &\n    TRPCProcedureOptions,\n) => Unsubscribable;\n\ntype DecorateProcedure<\n  TType extends ProcedureType,\n  TDef extends ResolverDef,\n> = TType extends 'query'\n  ? {\n      query: Resolver<TDef>;\n    }\n  : TType extends 'mutation'\n    ? {\n        mutate: Resolver<TDef>;\n      }\n    : TType extends 'subscription'\n      ? {\n          subscribe: SubscriptionResolver<TDef>;\n        }\n      : never;\n\n/**\n * @internal\n */\ntype DecoratedProcedureRecord<\n  TRoot extends InferrableClientTypes,\n  TRecord extends RouterRecord,\n> = {\n  [TKey in keyof TRecord]: TRecord[TKey] extends infer $Value\n    ? $Value extends AnyProcedure\n      ? DecorateProcedure<\n          $Value['_def']['type'],\n          {\n            input: inferProcedureInput<$Value>;\n            output: inferTransformedProcedureOutput<\n              inferClientTypes<TRoot>,\n              $Value\n            >;\n            errorShape: inferClientTypes<TRoot>['errorShape'];\n            transformer: inferClientTypes<TRoot>['transformer'];\n          }\n        >\n      : $Value extends RouterRecord\n        ? DecoratedProcedureRecord<TRoot, $Value>\n        : never\n    : never;\n};\n\nconst clientCallTypeMap: Record<\n  keyof DecorateProcedure<any, any>,\n  ProcedureType\n> = {\n  query: 'query',\n  mutate: 'mutation',\n  subscribe: 'subscription',\n};\n\n/** @internal */\nexport const clientCallTypeToProcedureType = (\n  clientCallType: string,\n): ProcedureType => {\n  return clientCallTypeMap[clientCallType as keyof typeof clientCallTypeMap];\n};\n\n/**\n * @internal\n */\nexport function createTRPCClientProxy<TRouter extends AnyRouter>(\n  client: TRPCUntypedClient<TRouter>,\n): TRPCClient<TRouter> {\n  const proxy = createRecursiveProxy<TRPCClient<TRouter>>(({ path, args }) => {\n    const pathCopy = [...path];\n    const procedureType = clientCallTypeToProcedureType(pathCopy.pop()!);\n\n    const fullPath = pathCopy.join('.');\n\n    return (client[procedureType] as any)(fullPath, ...(args as any));\n  });\n  return createFlatProxy<TRPCClient<TRouter>>((key) => {\n    if (key === untypedClientSymbol) {\n      return client;\n    }\n    return proxy[key];\n  });\n}\n\nexport function createTRPCClient<TRouter extends AnyRouter>(\n  opts: CreateTRPCClientOptions<TRouter>,\n): TRPCClient<TRouter> {\n  const client = new TRPCUntypedClient(opts);\n  const proxy = createTRPCClientProxy<TRouter>(client);\n  return proxy;\n}\n\n/**\n * Get an untyped client from a proxy client\n * @internal\n */\nexport function getUntypedClient<TRouter extends AnyRouter>(\n  client: TRPCClient<TRouter>,\n): TRPCUntypedClient<TRouter> {\n  return client[untypedClientSymbol];\n}\n", "import type { AnyRouter, ProcedureType } from '@trpc/server';\nimport { observable } from '@trpc/server/observable';\nimport type { TRPCErrorShape, TRPCResponse } from '@trpc/server/rpc';\nimport { jsonlStreamConsumer } from '@trpc/server/unstable-core-do-not-import';\nimport type { BatchLoader } from '../internals/dataLoader';\nimport { dataLoader } from '../internals/dataLoader';\nimport { allAbortSignals, raceAbortSignals } from '../internals/signals';\nimport type { NonEmptyArray } from '../internals/types';\nimport { TRPCClientError } from '../TRPCClientError';\nimport type { HTTPBatchLinkOptions } from './HTTPBatchLinkOptions';\nimport type { HTTPResult } from './internals/httpUtils';\nimport {\n  fetchHTTPResponse,\n  getBody,\n  getUrl,\n  resolveHTTPLinkOptions,\n} from './internals/httpUtils';\nimport type { Operation, TRPCLink } from './types';\n\n/**\n * @see https://trpc.io/docs/client/links/httpBatchStreamLink\n */\nexport function httpBatchStreamLink<TRouter extends AnyRouter>(\n  opts: HTTPBatchLinkOptions<TRouter['_def']['_config']['$types']>,\n): TRPCLink<TRouter> {\n  const resolvedOpts = resolveHTTPLinkOptions(opts);\n  const maxURLLength = opts.maxURLLength ?? Infinity;\n  const maxItems = opts.maxItems ?? Infinity;\n\n  return () => {\n    const batchLoader = (\n      type: ProcedureType,\n    ): BatchLoader<Operation, HTTPResult> => {\n      return {\n        validate(batchOps) {\n          if (maxURLLength === Infinity && maxItems === Infinity) {\n            // escape hatch for quick calcs\n            return true;\n          }\n          if (batchOps.length > maxItems) {\n            return false;\n          }\n          const path = batchOps.map((op) => op.path).join(',');\n          const inputs = batchOps.map((op) => op.input);\n\n          const url = getUrl({\n            ...resolvedOpts,\n            type,\n            path,\n            inputs,\n            signal: null,\n          });\n\n          return url.length <= maxURLLength;\n        },\n        async fetch(batchOps) {\n          const path = batchOps.map((op) => op.path).join(',');\n          const inputs = batchOps.map((op) => op.input);\n\n          const batchSignals = allAbortSignals(\n            ...batchOps.map((op) => op.signal),\n          );\n          const abortController = new AbortController();\n\n          const responsePromise = fetchHTTPResponse({\n            ...resolvedOpts,\n            signal: raceAbortSignals(batchSignals, abortController.signal),\n            type,\n            contentTypeHeader: 'application/json',\n            trpcAcceptHeader: 'application/jsonl',\n            getUrl,\n            getBody,\n            inputs,\n            path,\n            headers() {\n              if (!opts.headers) {\n                return {};\n              }\n              if (typeof opts.headers === 'function') {\n                return opts.headers({\n                  opList: batchOps as NonEmptyArray<Operation>,\n                });\n              }\n              return opts.headers;\n            },\n          });\n\n          const res = await responsePromise;\n          const [head] = await jsonlStreamConsumer<\n            Record<string, Promise<any>>\n          >({\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            from: res.body!,\n            deserialize: resolvedOpts.transformer.output.deserialize,\n            // onError: console.error,\n            formatError(opts) {\n              const error = opts.error as TRPCErrorShape;\n              return TRPCClientError.from({\n                error,\n              });\n            },\n            abortController,\n          });\n          const promises = Object.keys(batchOps).map(\n            async (key): Promise<HTTPResult> => {\n              let json: TRPCResponse = await Promise.resolve(head[key]);\n\n              if ('result' in json) {\n                /**\n                 * Not very pretty, but we need to unwrap nested data as promises\n                 * Our stream producer will only resolve top-level async values or async values that are directly nested in another async value\n                 */\n                const result = await Promise.resolve(json.result);\n                json = {\n                  result: {\n                    data: await Promise.resolve(result.data),\n                  },\n                };\n              }\n\n              return {\n                json,\n                meta: {\n                  response: res,\n                },\n              };\n            },\n          );\n          return promises;\n        },\n      };\n    };\n\n    const query = dataLoader(batchLoader('query'));\n    const mutation = dataLoader(batchLoader('mutation'));\n\n    const loaders = { query, mutation };\n    return ({ op }) => {\n      return observable((observer) => {\n        /* istanbul ignore if -- @preserve */\n        if (op.type === 'subscription') {\n          throw new Error(\n            'Subscriptions are unsupported by `httpBatchStreamLink` - use `httpSubscriptionLink` or `wsLink`',\n          );\n        }\n        const loader = loaders[op.type];\n        const promise = loader.load(op);\n\n        let _res = undefined as HTTPResult | undefined;\n        promise\n          .then((res) => {\n            _res = res;\n            if ('error' in res.json) {\n              observer.error(\n                TRPCClientError.from(res.json, {\n                  meta: res.meta,\n                }),\n              );\n              return;\n            } else if ('result' in res.json) {\n              observer.next({\n                context: res.meta,\n                result: res.json.result,\n              });\n              observer.complete();\n              return;\n            }\n\n            observer.complete();\n          })\n          .catch((err) => {\n            observer.error(\n              TRPCClientError.from(err, {\n                meta: _res?.meta,\n              }),\n            );\n          });\n\n        return () => {\n          // noop\n        };\n      });\n    };\n  };\n}\n\n/**\n * @deprecated use {@link httpBatchStreamLink} instead\n */\nexport const unstable_httpBatchStreamLink = httpBatchStreamLink;\n", "export function inputWithTrackedEventId(\n  input: unknown,\n  lastEventId: string | undefined,\n) {\n  if (!lastEventId) {\n    return input;\n  }\n  if (input != null && typeof input !== 'object') {\n    return input;\n  }\n  return {\n    ...(input ?? {}),\n    lastEventId,\n  };\n}\n", "function _asyncIterator(r) {\n  var n,\n    t,\n    o,\n    e = 2;\n  for (\"undefined\" != typeof Symbol && (t = Symbol.asyncIterator, o = Symbol.iterator); e--;) {\n    if (t && null != (n = r[t])) return n.call(r);\n    if (o && null != (n = r[o])) return new AsyncFromSyncIterator(n.call(r));\n    t = \"@@asyncIterator\", o = \"@@iterator\";\n  }\n  throw new TypeError(\"Object is not async iterable\");\n}\nfunction AsyncFromSyncIterator(r) {\n  function AsyncFromSyncIteratorContinuation(r) {\n    if (Object(r) !== r) return Promise.reject(new TypeError(r + \" is not an object.\"));\n    var n = r.done;\n    return Promise.resolve(r.value).then(function (r) {\n      return {\n        value: r,\n        done: n\n      };\n    });\n  }\n  return AsyncFromSyncIterator = function AsyncFromSyncIterator(r) {\n    this.s = r, this.n = r.next;\n  }, AsyncFromSyncIterator.prototype = {\n    s: null,\n    n: null,\n    next: function next() {\n      return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments));\n    },\n    \"return\": function _return(r) {\n      var n = this.s[\"return\"];\n      return void 0 === n ? Promise.resolve({\n        value: r,\n        done: !0\n      }) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments));\n    },\n    \"throw\": function _throw(r) {\n      var n = this.s[\"return\"];\n      return void 0 === n ? Promise.reject(r) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments));\n    }\n  }, new AsyncFromSyncIterator(r);\n}\nmodule.exports = _asyncIterator, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "import { behaviorSubject, observable } from '@trpc/server/observable';\nimport type { TRPCErrorShape, TRPCResult } from '@trpc/server/rpc';\nimport type {\n  AnyClientTypes,\n  EventSourceLike,\n  inferClientTypes,\n  InferrableClientTypes,\n} from '@trpc/server/unstable-core-do-not-import';\nimport {\n  retryableRpcCodes,\n  run,\n  sseStreamConsumer,\n} from '@trpc/server/unstable-core-do-not-import';\nimport { inputWithTrackedEventId } from '../internals/inputWithTrackedEventId';\nimport { raceAbortSignals } from '../internals/signals';\nimport { TRPCClientError } from '../TRPCClientError';\nimport type { TRPCConnectionState } from '../unstable-internals';\nimport { getTransformer, type TransformerOptions } from '../unstable-internals';\nimport { getUrl } from './internals/httpUtils';\nimport {\n  resultOf,\n  type UrlOptionsWithConnectionParams,\n} from './internals/urlWithConnectionParams';\nimport type { Operation, TRPCLink } from './types';\n\nasync function urlWithConnectionParams(\n  opts: UrlOptionsWithConnectionParams,\n): Promise<string> {\n  let url = await resultOf(opts.url);\n  if (opts.connectionParams) {\n    const params = await resultOf(opts.connectionParams);\n\n    const prefix = url.includes('?') ? '&' : '?';\n    url +=\n      prefix + 'connectionParams=' + encodeURIComponent(JSON.stringify(params));\n  }\n\n  return url;\n}\n\ntype HTTPSubscriptionLinkOptions<\n  TRoot extends AnyClientTypes,\n  TEventSource extends EventSourceLike.AnyConstructor = typeof EventSource,\n> = {\n  /**\n   * EventSource ponyfill\n   */\n  EventSource?: TEventSource;\n  /**\n   * EventSource options or a callback that returns them\n   */\n  eventSourceOptions?:\n    | EventSourceLike.InitDictOf<TEventSource>\n    | ((opts: {\n        op: Operation;\n      }) =>\n        | EventSourceLike.InitDictOf<TEventSource>\n        | Promise<EventSourceLike.InitDictOf<TEventSource>>);\n} & TransformerOptions<TRoot> &\n  UrlOptionsWithConnectionParams;\n\n/**\n * @see https://trpc.io/docs/client/links/httpSubscriptionLink\n */\nexport function httpSubscriptionLink<\n  TInferrable extends InferrableClientTypes,\n  TEventSource extends EventSourceLike.AnyConstructor,\n>(\n  opts: HTTPSubscriptionLinkOptions<\n    inferClientTypes<TInferrable>,\n    TEventSource\n  >,\n): TRPCLink<TInferrable> {\n  const transformer = getTransformer(opts.transformer);\n\n  return () => {\n    return ({ op }) => {\n      return observable((observer) => {\n        const { type, path, input } = op;\n\n        /* istanbul ignore if -- @preserve */\n        if (type !== 'subscription') {\n          throw new Error('httpSubscriptionLink only supports subscriptions');\n        }\n\n        let lastEventId: string | undefined = undefined;\n        const ac = new AbortController();\n        const signal = raceAbortSignals(op.signal, ac.signal);\n        const eventSourceStream = sseStreamConsumer<{\n          EventSource: TEventSource;\n          data: Partial<{\n            id?: string;\n            data: unknown;\n          }>;\n          error: TRPCErrorShape;\n        }>({\n          url: async () =>\n            getUrl({\n              transformer,\n              url: await urlWithConnectionParams(opts),\n              input: inputWithTrackedEventId(input, lastEventId),\n              path,\n              type,\n              signal: null,\n            }),\n          init: () => resultOf(opts.eventSourceOptions, { op }),\n          signal,\n          deserialize: transformer.output.deserialize,\n          EventSource:\n            opts.EventSource ??\n            (globalThis.EventSource as never as TEventSource),\n        });\n\n        const connectionState = behaviorSubject<\n          TRPCConnectionState<TRPCClientError<any>>\n        >({\n          type: 'state',\n          state: 'connecting',\n          error: null,\n        });\n\n        const connectionSub = connectionState.subscribe({\n          next(state) {\n            observer.next({\n              result: state,\n            });\n          },\n        });\n        run(async () => {\n          for await (const chunk of eventSourceStream) {\n            switch (chunk.type) {\n              case 'ping':\n                // do nothing\n                break;\n              case 'data':\n                const chunkData = chunk.data;\n\n                let result: TRPCResult<unknown>;\n                if (chunkData.id) {\n                  // if the `tracked()`-helper is used, we always have an `id` field\n                  lastEventId = chunkData.id;\n                  result = {\n                    id: chunkData.id,\n                    data: chunkData,\n                  };\n                } else {\n                  result = {\n                    data: chunkData.data,\n                  };\n                }\n\n                observer.next({\n                  result,\n                  context: {\n                    eventSource: chunk.eventSource,\n                  },\n                });\n                break;\n              case 'connected': {\n                observer.next({\n                  result: {\n                    type: 'started',\n                  },\n                  context: {\n                    eventSource: chunk.eventSource,\n                  },\n                });\n                connectionState.next({\n                  type: 'state',\n                  state: 'pending',\n                  error: null,\n                });\n                break;\n              }\n              case 'serialized-error': {\n                const error = TRPCClientError.from({ error: chunk.error });\n\n                if (retryableRpcCodes.includes(chunk.error.code)) {\n                  //\n                  connectionState.next({\n                    type: 'state',\n                    state: 'connecting',\n                    error,\n                  });\n                  break;\n                }\n                //\n                // non-retryable error, cancel the subscription\n                throw error;\n              }\n              case 'connecting': {\n                const lastState = connectionState.get();\n\n                const error = chunk.event && TRPCClientError.from(chunk.event);\n                if (!error && lastState.state === 'connecting') {\n                  break;\n                }\n\n                connectionState.next({\n                  type: 'state',\n                  state: 'connecting',\n                  error,\n                });\n                break;\n              }\n              case 'timeout': {\n                connectionState.next({\n                  type: 'state',\n                  state: 'connecting',\n                  error: new TRPCClientError(\n                    `Timeout of ${chunk.ms}ms reached while waiting for a response`,\n                  ),\n                });\n              }\n            }\n          }\n          observer.next({\n            result: {\n              type: 'stopped',\n            },\n          });\n          connectionState.next({\n            type: 'state',\n            state: 'idle',\n            error: null,\n          });\n          observer.complete();\n        }).catch((error) => {\n          observer.error(TRPCClientError.from(error));\n        });\n\n        return () => {\n          observer.complete();\n          ac.abort();\n          connectionSub.unsubscribe();\n        };\n      });\n    };\n  };\n}\n\n/**\n * @deprecated use {@link httpSubscriptionLink} instead\n */\nexport const unstable_httpSubscriptionLink = httpSubscriptionLink;\n", "/* istanbul ignore file -- @preserve */\n// We're not actually exporting this link\nimport type { Unsubscribable } from '@trpc/server/observable';\nimport { observable } from '@trpc/server/observable';\nimport type { InferrableClientTypes } from '@trpc/server/unstable-core-do-not-import';\nimport { inputWithTrackedEventId } from '../internals/inputWithTrackedEventId';\nimport type { TRPCClientError } from '../TRPCClientError';\nimport type { Operation, TRPCLink } from './types';\n\ninterface RetryLinkOptions<TInferrable extends InferrableClientTypes> {\n  /**\n   * The retry function\n   */\n  retry: (opts: RetryFnOptions<TInferrable>) => boolean;\n  /**\n   * The delay between retries in ms (defaults to 0)\n   */\n  retryDelayMs?: (attempt: number) => number;\n}\n\ninterface RetryFnOptions<TInferrable extends InferrableClientTypes> {\n  /**\n   * The operation that failed\n   */\n  op: Operation;\n  /**\n   * The error that occurred\n   */\n  error: TRPCClientError<TInferrable>;\n  /**\n   * The number of attempts that have been made (including the first call)\n   */\n  attempts: number;\n}\n\n/**\n * @see https://trpc.io/docs/v11/client/links/retryLink\n */\nexport function retryLink<TInferrable extends InferrableClientTypes>(\n  opts: RetryLinkOptions<TInferrable>,\n): TRPCLink<TInferrable> {\n  // initialized config\n  return () => {\n    // initialized in app\n    return (callOpts) => {\n      // initialized for request\n      return observable((observer) => {\n        let next$: Unsubscribable;\n        let callNextTimeout: ReturnType<typeof setTimeout> | undefined =\n          undefined;\n\n        let lastEventId: string | undefined = undefined;\n\n        attempt(1);\n\n        function opWithLastEventId() {\n          const op = callOpts.op;\n          if (!lastEventId) {\n            return op;\n          }\n\n          return {\n            ...op,\n            input: inputWithTrackedEventId(op.input, lastEventId),\n          };\n        }\n\n        function attempt(attempts: number) {\n          const op = opWithLastEventId();\n\n          next$ = callOpts.next(op).subscribe({\n            error(error) {\n              const shouldRetry = opts.retry({\n                op,\n                attempts,\n                error,\n              });\n              if (!shouldRetry) {\n                observer.error(error);\n                return;\n              }\n              const delayMs = opts.retryDelayMs?.(attempts) ?? 0;\n\n              if (delayMs <= 0) {\n                attempt(attempts + 1);\n                return;\n              }\n              callNextTimeout = setTimeout(\n                () => attempt(attempts + 1),\n                delayMs,\n              );\n            },\n            next(envelope) {\n              //\n              if (\n                (!envelope.result.type || envelope.result.type === 'data') &&\n                envelope.result.id\n              ) {\n                //\n                lastEventId = envelope.result.id;\n              }\n\n              observer.next(envelope);\n            },\n            complete() {\n              observer.complete();\n            },\n          });\n        }\n        return () => {\n          next$.unsubscribe();\n          clearTimeout(callNextTimeout);\n        };\n      });\n    };\n  };\n}\n", "function _usingCtx() {\n  var r = \"function\" == typeof SuppressedError ? SuppressedError : function (r, e) {\n      var n = Error();\n      return n.name = \"SuppressedError\", n.error = r, n.suppressed = e, n;\n    },\n    e = {},\n    n = [];\n  function using(r, e) {\n    if (null != e) {\n      if (Object(e) !== e) throw new TypeError(\"using declarations can only be used with objects, functions, null, or undefined.\");\n      if (r) var o = e[Symbol.asyncDispose || Symbol[\"for\"](\"Symbol.asyncDispose\")];\n      if (void 0 === o && (o = e[Symbol.dispose || Symbol[\"for\"](\"Symbol.dispose\")], r)) var t = o;\n      if (\"function\" != typeof o) throw new TypeError(\"Object is not disposable.\");\n      t && (o = function o() {\n        try {\n          t.call(e);\n        } catch (r) {\n          return Promise.reject(r);\n        }\n      }), n.push({\n        v: e,\n        d: o,\n        a: r\n      });\n    } else r && n.push({\n      d: e,\n      a: r\n    });\n    return e;\n  }\n  return {\n    e: e,\n    u: using.bind(null, !1),\n    a: using.bind(null, !0),\n    d: function d() {\n      var o,\n        t = this.e,\n        s = 0;\n      function next() {\n        for (; o = n.pop();) try {\n          if (!o.a && 1 === s) return s = 0, n.push(o), Promise.resolve().then(next);\n          if (o.d) {\n            var r = o.d.call(o.v);\n            if (o.a) return s |= 2, Promise.resolve(r).then(next, err);\n          } else s |= 1;\n        } catch (r) {\n          return err(r);\n        }\n        if (1 === s) return t !== e ? Promise.reject(t) : Promise.resolve();\n        if (t !== e) throw t;\n      }\n      function err(n) {\n        return t = t !== e ? new r(n, t) : n, next();\n      }\n      return next();\n    }\n  };\n}\nmodule.exports = _usingCtx, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "function _OverloadYield(e, d) {\n  this.v = e, this.k = d;\n}\nmodule.exports = _OverloadYield, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "var OverloadYield = require(\"./OverloadYield.js\");\nfunction _awaitAsyncGenerator(e) {\n  return new OverloadYield(e, 0);\n}\nmodule.exports = _awaitAsyncGenerator, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "var OverloadYield = require(\"./OverloadYield.js\");\nfunction _wrapAsyncGenerator(e) {\n  return function () {\n    return new AsyncGenerator(e.apply(this, arguments));\n  };\n}\nfunction AsyncGenerator(e) {\n  var r, t;\n  function resume(r, t) {\n    try {\n      var n = e[r](t),\n        o = n.value,\n        u = o instanceof OverloadYield;\n      Promise.resolve(u ? o.v : o).then(function (t) {\n        if (u) {\n          var i = \"return\" === r ? \"return\" : \"next\";\n          if (!o.k || t.done) return resume(i, t);\n          t = e[i](t).value;\n        }\n        settle(n.done ? \"return\" : \"normal\", t);\n      }, function (e) {\n        resume(\"throw\", e);\n      });\n    } catch (e) {\n      settle(\"throw\", e);\n    }\n  }\n  function settle(e, n) {\n    switch (e) {\n      case \"return\":\n        r.resolve({\n          value: n,\n          done: !0\n        });\n        break;\n      case \"throw\":\n        r.reject(n);\n        break;\n      default:\n        r.resolve({\n          value: n,\n          done: !1\n        });\n    }\n    (r = r.next) ? resume(r.key, r.arg) : t = null;\n  }\n  this._invoke = function (e, n) {\n    return new Promise(function (o, u) {\n      var i = {\n        key: e,\n        arg: n,\n        resolve: o,\n        reject: u,\n        next: null\n      };\n      t ? t = t.next = i : (r = t = i, resume(e, n));\n    });\n  }, \"function\" != typeof e[\"return\"] && (this[\"return\"] = void 0);\n}\nAsyncGenerator.prototype[\"function\" == typeof Symbol && Symbol.asyncIterator || \"@@asyncIterator\"] = function () {\n  return this;\n}, AsyncGenerator.prototype.next = function (e) {\n  return this._invoke(\"next\", e);\n}, AsyncGenerator.prototype[\"throw\"] = function (e) {\n  return this._invoke(\"throw\", e);\n}, AsyncGenerator.prototype[\"return\"] = function (e) {\n  return this._invoke(\"return\", e);\n};\nmodule.exports = _wrapAsyncGenerator, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "import {\n  getTRPCErrorFromUnknown,\n  getTRPCErrorShape,\n  isTrackedEnvelope,\n} from '@trpc/server';\nimport { behaviorSubject, observable } from '@trpc/server/observable';\nimport { TRPC_ERROR_CODES_BY_KEY, type TRPCResult } from '@trpc/server/rpc';\nimport {\n  callProcedure,\n  isAbortError,\n  isAsyncIterable,\n  iteratorResource,\n  makeResource,\n  retryableRpcCodes,\n  run,\n  type AnyRouter,\n  type ErrorHandlerOptions,\n  type inferClientTypes,\n  type inferRouterContext,\n} from '@trpc/server/unstable-core-do-not-import';\nimport { inputWithTrackedEventId } from '../internals/inputWithTrackedEventId';\nimport { abortSignalToPromise, raceAbortSignals } from '../internals/signals';\nimport { getTransformer } from '../internals/transformer';\nimport type { TransformerOptions } from '../internals/transformer';\nimport { isTRPCClientError, TRPCClientError } from '../TRPCClientError';\nimport type { TRPCConnectionState } from './internals/subscriptions';\nimport type { TRPCLink } from './types';\n\nexport type LocalLinkOptions<TRouter extends AnyRouter> = {\n  router: TRouter;\n  createContext: () => Promise<inferRouterContext<TRouter>>;\n  onError?: (opts: ErrorHandlerOptions<inferRouterContext<TRouter>>) => void;\n} & TransformerOptions<inferClientTypes<TRouter>>;\n\n/**\n * localLink is a terminating link that allows you to make tRPC procedure calls directly in your application without going through HTTP.\n *\n * @see https://trpc.io/docs/links/localLink\n */\nexport function unstable_localLink<TRouter extends AnyRouter>(\n  opts: LocalLinkOptions<TRouter>,\n): TRPCLink<TRouter> {\n  const transformer = getTransformer(opts.transformer);\n\n  const transformChunk = (chunk: unknown) => {\n    if (opts.transformer) {\n      // assume transformer will do the right thing\n      return chunk;\n    }\n    // Special case for undefined, because `JSON.stringify(undefined)` throws\n    if (chunk === undefined) {\n      return chunk;\n    }\n    const serialized = JSON.stringify(transformer.input.serialize(chunk));\n    const deserialized = JSON.parse(transformer.output.deserialize(serialized));\n    return deserialized;\n  };\n\n  return () =>\n    ({ op }) =>\n      observable((observer) => {\n        let ctx: inferRouterContext<TRouter> | undefined = undefined;\n        const ac = new AbortController();\n\n        const signal = raceAbortSignals(op.signal, ac.signal);\n        const signalPromise = abortSignalToPromise(signal);\n\n        signalPromise.catch(() => {\n          // prevent unhandled rejection\n        });\n\n        let input = op.input;\n        async function runProcedure(newInput: unknown): Promise<unknown> {\n          input = newInput;\n\n          ctx = await opts.createContext();\n\n          return callProcedure({\n            router: opts.router,\n            path: op.path,\n            getRawInput: async () => newInput,\n            ctx,\n            type: op.type,\n            signal,\n          });\n        }\n\n        function onErrorCallback(cause: unknown) {\n          if (isAbortError(cause)) {\n            return;\n          }\n          opts.onError?.({\n            error: getTRPCErrorFromUnknown(cause),\n            type: op.type,\n            path: op.path,\n            input,\n            ctx,\n          });\n        }\n\n        function coerceToTRPCClientError(cause: unknown) {\n          if (isTRPCClientError<TRouter>(cause)) {\n            return cause;\n          }\n          const error = getTRPCErrorFromUnknown(cause);\n\n          const shape = getTRPCErrorShape({\n            config: opts.router._def._config,\n            ctx,\n            error,\n            input,\n            path: op.path,\n            type: op.type,\n          });\n          return TRPCClientError.from({\n            error: transformChunk(shape),\n          });\n        }\n\n        run(async () => {\n          switch (op.type) {\n            case 'query':\n            case 'mutation': {\n              const result = await runProcedure(op.input);\n              if (!isAsyncIterable(result)) {\n                observer.next({\n                  result: { data: transformChunk(result) },\n                });\n                observer.complete();\n                break;\n              }\n\n              observer.next({\n                result: {\n                  data: (async function* () {\n                    await using iterator = iteratorResource(result);\n                    using _finally = makeResource({}, () => {\n                      observer.complete();\n                    });\n                    try {\n                      while (true) {\n                        const res = await Promise.race([\n                          iterator.next(),\n                          signalPromise,\n                        ]);\n                        if (res.done) {\n                          return transformChunk(res.value);\n                        }\n                        yield transformChunk(res.value);\n                      }\n                    } catch (cause) {\n                      onErrorCallback(cause);\n                      throw coerceToTRPCClientError(cause);\n                    }\n                  })(),\n                },\n              });\n              break;\n            }\n            case 'subscription': {\n              const connectionState = behaviorSubject<\n                TRPCConnectionState<TRPCClientError<any>>\n              >({\n                type: 'state',\n                state: 'connecting',\n                error: null,\n              });\n\n              const connectionSub = connectionState.subscribe({\n                next(state) {\n                  observer.next({\n                    result: state,\n                  });\n                },\n              });\n              let lastEventId: string | undefined = undefined;\n\n              using _finally = makeResource({}, async () => {\n                observer.complete();\n\n                connectionState.next({\n                  type: 'state',\n                  state: 'idle',\n                  error: null,\n                });\n                connectionSub.unsubscribe();\n              });\n              while (true) {\n                const result = await runProcedure(\n                  inputWithTrackedEventId(op.input, lastEventId),\n                );\n                if (!isAsyncIterable(result)) {\n                  throw new Error('Expected an async iterable');\n                }\n                await using iterator = iteratorResource(result);\n\n                observer.next({\n                  result: {\n                    type: 'started',\n                  },\n                });\n                connectionState.next({\n                  type: 'state',\n                  state: 'pending',\n                  error: null,\n                });\n\n                // Use a while loop to handle errors and reconnects\n                while (true) {\n                  let res;\n                  try {\n                    res = await Promise.race([iterator.next(), signalPromise]);\n                  } catch (cause) {\n                    if (isAbortError(cause)) {\n                      return;\n                    }\n                    const error = getTRPCErrorFromUnknown(cause);\n\n                    if (\n                      !retryableRpcCodes.includes(\n                        TRPC_ERROR_CODES_BY_KEY[error.code],\n                      )\n                    ) {\n                      throw coerceToTRPCClientError(error);\n                    }\n\n                    onErrorCallback(error);\n                    connectionState.next({\n                      type: 'state',\n                      state: 'connecting',\n                      error: coerceToTRPCClientError(error),\n                    });\n\n                    break;\n                  }\n\n                  if (res.done) {\n                    return;\n                  }\n                  let chunk: TRPCResult<unknown>;\n                  if (isTrackedEnvelope(res.value)) {\n                    lastEventId = res.value[0];\n\n                    chunk = {\n                      id: res.value[0],\n                      data: {\n                        id: res.value[0],\n                        data: res.value[1],\n                      },\n                    };\n                  } else {\n                    chunk = {\n                      data: res.value,\n                    };\n                  }\n\n                  observer.next({\n                    result: {\n                      ...chunk,\n                      data: transformChunk(chunk.data),\n                    },\n                  });\n                }\n              }\n              break;\n            }\n          }\n        }).catch((cause) => {\n          onErrorCallback(cause);\n          observer.error(coerceToTRPCClientError(cause));\n        });\n\n        return () => {\n          ac.abort();\n        };\n      });\n}\n/**\n * @deprecated Renamed to `unstable_localLink`. This alias will be removed in a future major release.\n */\nexport const experimental_localLink: typeof unstable_localLink =\n  unstable_localLink;\n", "import type { AnyRouter } from '@trpc/server/unstable-core-do-not-import';\nimport { createRecursiveProxy } from '@trpc/server/unstable-core-do-not-import';\nimport type { CreateReactQueryHooks } from '../hooks/createHooksInternal';\n\n/**\n * Create proxy for decorating procedures\n * @internal\n */\nexport function createReactDecoration<\n  TRouter extends AnyRouter,\n  TSSRContext = unknown,\n>(hooks: CreateReactQueryHooks<TRouter, TSSRContext>) {\n  return createRecursiveProxy(({ path, args }) => {\n    const pathCopy = [...path];\n\n    // The last arg is for instance `.useMutation` or `.useQuery()`\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const lastArg = pathCopy.pop()!;\n\n    if (lastArg === 'useMutation') {\n      return (hooks as any)[lastArg](pathCopy, ...args);\n    }\n\n    if (lastArg === '_def') {\n      return {\n        path: pathCopy,\n      };\n    }\n\n    const [input, ...rest] = args;\n    const opts = rest[0] ?? {};\n\n    return (hooks as any)[lastArg](pathCopy, input, opts);\n  });\n}\n", "import type {\n  CancelOptions,\n  FetchInfiniteQueryOptions,\n  FetchQueryOptions,\n  InfiniteData,\n  InvalidateOptions,\n  InvalidateQueryFilters,\n  MutationOptions,\n  QueryClient,\n  QueryFilters,\n  QueryKey,\n  RefetchOptions,\n  RefetchQueryFilters,\n  ResetOptions,\n  SetDataOptions,\n  Updater,\n} from '@tanstack/react-query';\nimport type {\n  TRPCClient,\n  TRPCClientError,\n  TRPCRequestOptions,\n  TRPCUntypedClient,\n} from '@trpc/client';\nimport type {\n  AnyClientTypes,\n  AnyRouter,\n  DistributiveOmit,\n} from '@trpc/server/unstable-core-do-not-import';\nimport * as React from 'react';\nimport type {\n  DefinedTRPCInfiniteQueryOptionsIn,\n  DefinedTRPCInfiniteQueryOptionsOut,\n  DefinedTRPCQueryOptionsIn,\n  DefinedTRPCQueryOptionsOut,\n  ExtractCursorType,\n  UndefinedTRPCInfiniteQueryOptionsIn,\n  UndefinedTRPCInfiniteQueryOptionsOut,\n  UndefinedTRPCQueryOptionsIn,\n  UndefinedTRPCQueryOptionsOut,\n} from '../shared';\nimport type { TRPCMutationKey, TRPCQueryKey } from './getQueryKey';\n\ninterface TRPCUseUtilsOptions {\n  /**\n   * tRPC-related options\n   */\n  trpc?: TRPCRequestOptions;\n}\nexport interface TRPCFetchQueryOptions<TOutput, TError>\n  extends DistributiveOmit<FetchQueryOptions<TOutput, TError>, 'queryKey'>,\n    TRPCUseUtilsOptions {\n  //\n}\n\nexport type TRPCFetchInfiniteQueryOptions<TInput, TOutput, TError> =\n  DistributiveOmit<\n    FetchInfiniteQueryOptions<\n      TOutput,\n      TError,\n      TOutput,\n      TRPCQueryKey,\n      ExtractCursorType<TInput>\n    >,\n    'queryKey' | 'initialPageParam'\n  > &\n    TRPCUseUtilsOptions & {\n      initialCursor?: ExtractCursorType<TInput>;\n    };\n\n/** @internal */\nexport type SSRState = 'mounted' | 'mounting' | 'prepass' | false;\n\nexport interface TRPCContextPropsBase<TRouter extends AnyRouter, TSSRContext> {\n  /**\n   * The `TRPCClient`\n   */\n  client: TRPCUntypedClient<TRouter>;\n  /**\n   * The SSR context when server-side rendering\n   * @default null\n   */\n  ssrContext?: TSSRContext | null;\n  /**\n   * State of SSR hydration.\n   * - `false` if not using SSR.\n   * - `prepass` when doing a prepass to fetch queries' data\n   * - `mounting` before TRPCProvider has been rendered on the client\n   * - `mounted` when the TRPCProvider has been rendered on the client\n   * @default false\n   */\n  ssrState?: SSRState;\n  /**\n   * @deprecated pass abortOnUnmount to `createTRPCReact` instead\n   * Abort loading query calls when unmounting a component - usually when navigating to a new page\n   * @default false\n   */\n  abortOnUnmount?: boolean;\n}\n\n/**\n * @internal\n */\nexport type DecoratedTRPCContextProps<\n  TRouter extends AnyRouter,\n  TSSRContext,\n> = TRPCContextPropsBase<TRouter, TSSRContext> & {\n  client: TRPCClient<TRouter>;\n};\n\nexport interface TRPCContextProps<TRouter extends AnyRouter, TSSRContext>\n  extends TRPCContextPropsBase<TRouter, TSSRContext> {\n  /**\n   * The react-query `QueryClient`\n   */\n  queryClient: QueryClient;\n}\n\nexport const contextProps: (keyof TRPCContextPropsBase<any, any>)[] = [\n  'client',\n  'ssrContext',\n  'ssrState',\n  'abortOnUnmount',\n];\n\n/**\n * @internal\n */\nexport interface TRPCContextState<\n  TRouter extends AnyRouter,\n  TSSRContext = undefined,\n> extends Required<TRPCContextProps<TRouter, TSSRContext>>,\n    TRPCQueryUtils<TRouter> {}\n\n/**\n * @internal\n */\nexport interface TRPCQueryUtils<TRouter extends AnyRouter> {\n  /**\n   * @see https://tanstack.com/query/latest/docs/framework/react/reference/queryOptions#queryoptions\n   */\n  queryOptions(\n    path: readonly string[], // <-- look into if needed\n    queryKey: TRPCQueryKey,\n    opts?: UndefinedTRPCQueryOptionsIn<\n      unknown,\n      unknown,\n      TRPCClientError<AnyClientTypes>\n    >,\n  ): UndefinedTRPCQueryOptionsOut<\n    unknown,\n    unknown,\n    TRPCClientError<AnyClientTypes>\n  >;\n  queryOptions(\n    path: readonly string[], // <-- look into if needed\n    queryKey: TRPCQueryKey,\n    opts: DefinedTRPCQueryOptionsIn<\n      unknown,\n      unknown,\n      TRPCClientError<AnyClientTypes>\n    >,\n  ): DefinedTRPCQueryOptionsOut<\n    unknown,\n    unknown,\n    TRPCClientError<AnyClientTypes>\n  >;\n\n  /**\n   * @see https://tanstack.com/query/latest/docs/framework/react/reference/infiniteQueryOptions#infinitequeryoptions\n   */\n  infiniteQueryOptions(\n    path: readonly string[], // <-- look into if needed\n    queryKey: TRPCQueryKey,\n    opts: UndefinedTRPCInfiniteQueryOptionsIn<\n      unknown,\n      unknown,\n      unknown,\n      TRPCClientError<AnyClientTypes>\n    >,\n  ): UndefinedTRPCInfiniteQueryOptionsOut<\n    unknown,\n    unknown,\n    unknown,\n    TRPCClientError<AnyClientTypes>\n  >;\n  infiniteQueryOptions(\n    path: readonly string[], // <-- look into if needed\n    queryKey: TRPCQueryKey,\n    opts: DefinedTRPCInfiniteQueryOptionsIn<\n      unknown,\n      unknown,\n      unknown,\n      TRPCClientError<AnyClientTypes>\n    >,\n  ): DefinedTRPCInfiniteQueryOptionsOut<\n    unknown,\n    unknown,\n    unknown,\n    TRPCClientError<AnyClientTypes>\n  >;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientfetchquery\n   */\n  fetchQuery: (\n    queryKey: TRPCQueryKey,\n    opts?: TRPCFetchQueryOptions<unknown, TRPCClientError<TRouter>>,\n  ) => Promise<unknown>;\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientfetchinfinitequery\n   */\n  fetchInfiniteQuery: (\n    queryKey: TRPCQueryKey,\n    opts?: TRPCFetchInfiniteQueryOptions<\n      unknown,\n      unknown,\n      TRPCClientError<TRouter>\n    >,\n  ) => Promise<InfiniteData<unknown, unknown>>;\n  /**\n   * @see https://tanstack.com/query/v5/docs/framework/react/guides/prefetching\n   */\n  prefetchQuery: (\n    queryKey: TRPCQueryKey,\n    opts?: TRPCFetchQueryOptions<unknown, TRPCClientError<TRouter>>,\n  ) => Promise<void>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientprefetchinfinitequery\n   */\n  prefetchInfiniteQuery: (\n    queryKey: TRPCQueryKey,\n    opts?: TRPCFetchInfiniteQueryOptions<\n      unknown,\n      unknown,\n      TRPCClientError<TRouter>\n    >,\n  ) => Promise<void>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientensurequerydata\n   */\n  ensureQueryData: (\n    queryKey: TRPCQueryKey,\n    opts?: TRPCFetchQueryOptions<unknown, TRPCClientError<TRouter>>,\n  ) => Promise<unknown>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/framework/react/guides/query-invalidation\n   */\n  invalidateQueries: (\n    queryKey: TRPCQueryKey,\n    filters?: InvalidateQueryFilters<TRPCQueryKey>,\n    options?: InvalidateOptions,\n  ) => Promise<void>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientresetqueries\n   */\n  resetQueries: (\n    queryKey: TRPCQueryKey,\n    filters?: QueryFilters<TRPCQueryKey>,\n    options?: ResetOptions,\n  ) => Promise<void>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientrefetchqueries\n   */\n  refetchQueries: (\n    queryKey: TRPCQueryKey,\n    filters?: RefetchQueryFilters<TRPCQueryKey>,\n    options?: RefetchOptions,\n  ) => Promise<void>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/framework/react/guides/query-cancellation\n   */\n  cancelQuery: (\n    queryKey: TRPCQueryKey,\n    options?: CancelOptions,\n  ) => Promise<void>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientsetquerydata\n   */\n  setQueryData: (\n    queryKey: TRPCQueryKey,\n    updater: Updater<unknown, unknown>,\n    options?: SetDataOptions,\n  ) => void;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientsetqueriesdata\n   */\n  setQueriesData: (\n    queryKey: TRPCQueryKey,\n    filters: QueryFilters,\n    updater: Updater<unknown, unknown>,\n    options?: SetDataOptions,\n  ) => [QueryKey, unknown][];\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientgetquerydata\n   */\n  getQueryData: (queryKey: TRPCQueryKey) => unknown;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientsetquerydata\n   */\n  setInfiniteQueryData: (\n    queryKey: TRPCQueryKey,\n    updater: Updater<\n      InfiniteData<unknown> | undefined,\n      InfiniteData<unknown> | undefined\n    >,\n    options?: SetDataOptions,\n  ) => void;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientgetquerydata\n   */\n  getInfiniteQueryData: (\n    queryKey: TRPCQueryKey,\n  ) => InfiniteData<unknown> | undefined;\n\n  /**\n   * @see https://tanstack.com/query/latest/docs/reference/QueryClient/#queryclientsetmutationdefaults\n   */\n  setMutationDefaults: (\n    mutationKey: TRPCMutationKey,\n    options:\n      | MutationOptions\n      | ((args: {\n          canonicalMutationFn: (input: unknown) => Promise<unknown>;\n        }) => MutationOptions),\n  ) => void;\n\n  /**\n   * @see https://tanstack.com/query/latest/docs/reference/QueryClient#queryclientgetmutationdefaults\n   */\n  getMutationDefaults: (\n    mutationKey: TRPCMutationKey,\n  ) => MutationOptions | undefined;\n\n  /**\n   * @see https://tanstack.com/query/latest/docs/reference/QueryClient#queryclientismutating\n   */\n  isMutating: (filters: { mutationKey: TRPCMutationKey }) => number;\n}\nexport const TRPCContext = React.createContext?.(null as any);\n", "import type {\n  CancelOptions,\n  InfiniteData,\n  InvalidateOptions,\n  InvalidateQueryFilters,\n  Query,\n  QueryFilters,\n  QueryKey,\n  RefetchOptions,\n  RefetchQueryFilters,\n  ResetOptions,\n  SetDataOptions,\n  SkipToken,\n  Updater,\n} from '@tanstack/react-query';\nimport type { TRPCClientError } from '@trpc/client';\nimport { createTRPCClientProxy } from '@trpc/client';\nimport type {\n  AnyMutationProcedure,\n  AnyQueryProcedure,\n  AnyRootTypes,\n  AnyRouter,\n  DeepPartial,\n  inferProcedureInput,\n  inferProcedureOutput,\n  inferTransformedProcedureOutput,\n  ProtectedIntersection,\n  RouterRecord,\n} from '@trpc/server/unstable-core-do-not-import';\nimport {\n  createFlatProxy,\n  createRecursiveProxy,\n} from '@trpc/server/unstable-core-do-not-import';\nimport type {\n  DecoratedTRPCContextProps,\n  TRPCContextState,\n  TRPCFetchInfiniteQueryOptions,\n  TRPCFetchQueryOptions,\n  TRPCQueryUtils,\n} from '../../internals/context';\nimport { contextProps } from '../../internals/context';\nimport type { QueryKeyKnown, QueryType } from '../../internals/getQueryKey';\nimport {\n  getMutationKeyInternal,\n  getQueryKeyInternal,\n} from '../../internals/getQueryKey';\nimport type { InferMutationOptions } from '../../utils/inferReactQueryProcedure';\nimport type { ExtractCursorType } from '../hooks/types';\nimport type {\n  DefinedTRPCInfiniteQueryOptionsIn,\n  DefinedTRPCInfiniteQueryOptionsOut,\n  DefinedTRPCQueryOptionsIn,\n  DefinedTRPCQueryOptionsOut,\n  UndefinedTRPCInfiniteQueryOptionsIn,\n  UndefinedTRPCInfiniteQueryOptionsOut,\n  UndefinedTRPCQueryOptionsIn,\n  UndefinedTRPCQueryOptionsOut,\n  UnusedSkipTokenTRPCInfiniteQueryOptionsIn,\n  UnusedSkipTokenTRPCInfiniteQueryOptionsOut,\n  UnusedSkipTokenTRPCQueryOptionsIn,\n  UnusedSkipTokenTRPCQueryOptionsOut,\n} from '../types';\n\nexport type DecorateQueryProcedure<\n  TRoot extends AnyRootTypes,\n  TProcedure extends AnyQueryProcedure,\n> = {\n  /**\n   * @see https://tanstack.com/query/latest/docs/framework/react/reference/queryOptions#queryoptions\n   */\n  queryOptions<\n    TQueryFnData extends inferTransformedProcedureOutput<TRoot, TProcedure>,\n    TData = TQueryFnData,\n  >(\n    input: inferProcedureInput<TProcedure> | SkipToken,\n    opts: DefinedTRPCQueryOptionsIn<\n      TQueryFnData,\n      TData,\n      TRPCClientError<TRoot>\n    >,\n  ): DefinedTRPCQueryOptionsOut<TQueryFnData, TData, TRPCClientError<TRoot>>;\n  /**\n   * @see https://tanstack.com/query/latest/docs/framework/react/reference/queryOptions#queryoptions\n   */\n  queryOptions<\n    TQueryFnData extends inferTransformedProcedureOutput<TRoot, TProcedure>,\n    TData = TQueryFnData,\n  >(\n    input: inferProcedureInput<TProcedure> | SkipToken,\n    opts?: UnusedSkipTokenTRPCQueryOptionsIn<\n      TQueryFnData,\n      TData,\n      TRPCClientError<TRoot>\n    >,\n  ): UnusedSkipTokenTRPCQueryOptionsOut<\n    TQueryFnData,\n    TData,\n    TRPCClientError<TRoot>\n  >;\n  /**\n   * @see https://tanstack.com/query/latest/docs/framework/react/reference/queryOptions#queryoptions\n   */\n  queryOptions<\n    TQueryFnData extends inferTransformedProcedureOutput<TRoot, TProcedure>,\n    TData = TQueryFnData,\n  >(\n    input: inferProcedureInput<TProcedure> | SkipToken,\n    opts?: UndefinedTRPCQueryOptionsIn<\n      TQueryFnData,\n      TData,\n      TRPCClientError<TRoot>\n    >,\n  ): UndefinedTRPCQueryOptionsOut<TQueryFnData, TData, TRPCClientError<TRoot>>;\n\n  /**\n   * @see https://tanstack.com/query/latest/docs/framework/react/reference/infiniteQueryOptions#infinitequeryoptions\n   */\n  infiniteQueryOptions<\n    TQueryFnData extends inferTransformedProcedureOutput<TRoot, TProcedure>,\n    TData = TQueryFnData,\n  >(\n    input: inferProcedureInput<TProcedure> | SkipToken,\n    opts: DefinedTRPCInfiniteQueryOptionsIn<\n      inferProcedureInput<TProcedure>,\n      TQueryFnData,\n      TData,\n      TRPCClientError<TRoot>\n    >,\n  ): DefinedTRPCInfiniteQueryOptionsOut<\n    inferProcedureInput<TProcedure>,\n    TQueryFnData,\n    TData,\n    TRPCClientError<TRoot>\n  >;\n  /**\n   * @see https://tanstack.com/query/latest/docs/framework/react/reference/infiniteQueryOptions#infinitequeryoptions\n   */\n  infiniteQueryOptions<\n    TQueryFnData extends inferTransformedProcedureOutput<TRoot, TProcedure>,\n    TData = TQueryFnData,\n  >(\n    input: inferProcedureInput<TProcedure>,\n    opts: UnusedSkipTokenTRPCInfiniteQueryOptionsIn<\n      inferProcedureInput<TProcedure>,\n      TQueryFnData,\n      TData,\n      TRPCClientError<TRoot>\n    >,\n  ): UnusedSkipTokenTRPCInfiniteQueryOptionsOut<\n    inferProcedureInput<TProcedure>,\n    TQueryFnData,\n    TData,\n    TRPCClientError<TRoot>\n  >;\n  /**\n   * @see https://tanstack.com/query/latest/docs/framework/react/reference/infiniteQueryOptions#infinitequeryoptions\n   */\n  infiniteQueryOptions<\n    TQueryFnData extends inferTransformedProcedureOutput<TRoot, TProcedure>,\n    TData = TQueryFnData,\n  >(\n    input: inferProcedureInput<TProcedure> | SkipToken,\n    opts?: UndefinedTRPCInfiniteQueryOptionsIn<\n      inferProcedureInput<TProcedure>,\n      TQueryFnData,\n      TData,\n      TRPCClientError<TRoot>\n    >,\n  ): UndefinedTRPCInfiniteQueryOptionsOut<\n    inferProcedureInput<TProcedure>,\n    TQueryFnData,\n    TData,\n    TRPCClientError<TRoot>\n  >;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientfetchquery\n   */\n  fetch(\n    input: inferProcedureInput<TProcedure>,\n    opts?: TRPCFetchQueryOptions<\n      inferTransformedProcedureOutput<TRoot, TProcedure>,\n      TRPCClientError<TRoot>\n    >,\n  ): Promise<inferTransformedProcedureOutput<TRoot, TProcedure>>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientfetchinfinitequery\n   */\n  fetchInfinite(\n    input: inferProcedureInput<TProcedure>,\n    opts?: TRPCFetchInfiniteQueryOptions<\n      inferProcedureInput<TProcedure>,\n      inferTransformedProcedureOutput<TRoot, TProcedure>,\n      TRPCClientError<TRoot>\n    >,\n  ): Promise<\n    InfiniteData<\n      inferTransformedProcedureOutput<TRoot, TProcedure>,\n      NonNullable<ExtractCursorType<inferProcedureInput<TProcedure>>> | null\n    >\n  >;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientprefetchquery\n   */\n  prefetch(\n    input: inferProcedureInput<TProcedure>,\n    opts?: TRPCFetchQueryOptions<\n      inferTransformedProcedureOutput<TRoot, TProcedure>,\n      TRPCClientError<TRoot>\n    >,\n  ): Promise<void>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientprefetchinfinitequery\n   */\n  prefetchInfinite(\n    input: inferProcedureInput<TProcedure>,\n    opts?: TRPCFetchInfiniteQueryOptions<\n      inferProcedureInput<TProcedure>,\n      inferTransformedProcedureOutput<TRoot, TProcedure>,\n      TRPCClientError<TRoot>\n    >,\n  ): Promise<void>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientensurequerydata\n   */\n  ensureData(\n    input: inferProcedureInput<TProcedure>,\n    opts?: TRPCFetchQueryOptions<\n      inferTransformedProcedureOutput<TRoot, TProcedure>,\n      TRPCClientError<TRoot>\n    >,\n  ): Promise<inferTransformedProcedureOutput<TRoot, TProcedure>>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientinvalidatequeries\n   */\n  invalidate(\n    input?: DeepPartial<inferProcedureInput<TProcedure>>,\n    filters?: Omit<InvalidateQueryFilters, 'predicate'> & {\n      predicate?: (\n        query: Query<\n          inferProcedureOutput<TProcedure>,\n          TRPCClientError<TRoot>,\n          inferTransformedProcedureOutput<TRoot, TProcedure>,\n          QueryKeyKnown<\n            inferProcedureInput<TProcedure>,\n            inferProcedureInput<TProcedure> extends { cursor?: any } | void\n              ? 'infinite'\n              : 'query'\n          >\n        >,\n      ) => boolean;\n    },\n    options?: InvalidateOptions,\n  ): Promise<void>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientrefetchqueries\n   */\n  refetch(\n    input?: inferProcedureInput<TProcedure>,\n    filters?: RefetchQueryFilters,\n    options?: RefetchOptions,\n  ): Promise<void>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientcancelqueries\n   */\n  cancel(\n    input?: inferProcedureInput<TProcedure>,\n    options?: CancelOptions,\n  ): Promise<void>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientresetqueries\n   */\n  reset(\n    input?: inferProcedureInput<TProcedure>,\n    options?: ResetOptions,\n  ): Promise<void>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientsetquerydata\n   */\n  setData(\n    /**\n     * The input of the procedure\n     */\n    input: inferProcedureInput<TProcedure>,\n    updater: Updater<\n      inferTransformedProcedureOutput<TRoot, TProcedure> | undefined,\n      inferTransformedProcedureOutput<TRoot, TProcedure> | undefined\n    >,\n    options?: SetDataOptions,\n  ): void;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientsetquerydata\n   */\n  setQueriesData(\n    /**\n     * The input of the procedure\n     */\n    input: inferProcedureInput<TProcedure>,\n    filters: QueryFilters,\n    updater: Updater<\n      inferTransformedProcedureOutput<TRoot, TProcedure> | undefined,\n      inferTransformedProcedureOutput<TRoot, TProcedure> | undefined\n    >,\n    options?: SetDataOptions,\n  ): [QueryKey, inferTransformedProcedureOutput<TRoot, TProcedure>];\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientsetquerydata\n   */\n  setInfiniteData(\n    input: inferProcedureInput<TProcedure>,\n    updater: Updater<\n      | InfiniteData<\n          inferTransformedProcedureOutput<TRoot, TProcedure>,\n          NonNullable<ExtractCursorType<inferProcedureInput<TProcedure>>> | null\n        >\n      | undefined,\n      | InfiniteData<\n          inferTransformedProcedureOutput<TRoot, TProcedure>,\n          NonNullable<ExtractCursorType<inferProcedureInput<TProcedure>>> | null\n        >\n      | undefined\n    >,\n    options?: SetDataOptions,\n  ): void;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientgetquerydata\n   */\n  getData(\n    input?: inferProcedureInput<TProcedure>,\n  ): inferTransformedProcedureOutput<TRoot, TProcedure> | undefined;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientgetquerydata\n   */\n  getInfiniteData(\n    input?: inferProcedureInput<TProcedure>,\n  ):\n    | InfiniteData<\n        inferTransformedProcedureOutput<TRoot, TProcedure>,\n        NonNullable<ExtractCursorType<inferProcedureInput<TProcedure>>> | null\n      >\n    | undefined;\n};\n\ntype DecorateMutationProcedure<\n  TRoot extends AnyRootTypes,\n  TProcedure extends AnyMutationProcedure,\n> = {\n  setMutationDefaults<TMeta = unknown>(\n    options:\n      | InferMutationOptions<TRoot, TProcedure, TMeta>\n      | ((args: {\n          canonicalMutationFn: NonNullable<\n            InferMutationOptions<TRoot, TProcedure>['mutationFn']\n          >;\n        }) => InferMutationOptions<TRoot, TProcedure, TMeta>),\n  ): void;\n\n  getMutationDefaults(): InferMutationOptions<TRoot, TProcedure> | undefined;\n\n  isMutating(): number;\n};\n\n/**\n * this is the type that is used to add in procedures that can be used on\n * an entire router\n */\ntype DecorateRouter = {\n  /**\n   * Invalidate the full router\n   * @see https://trpc.io/docs/v10/useContext#query-invalidation\n   * @see https://tanstack.com/query/v5/docs/framework/react/guides/query-invalidation\n   */\n  invalidate(\n    input?: undefined,\n    filters?: InvalidateQueryFilters,\n    options?: InvalidateOptions,\n  ): Promise<void>;\n};\n\n/**\n * @internal\n */\nexport type DecoratedProcedureUtilsRecord<\n  TRoot extends AnyRootTypes,\n  TRecord extends RouterRecord,\n> = DecorateRouter & {\n  [TKey in keyof TRecord]: TRecord[TKey] extends infer $Value\n    ? $Value extends AnyQueryProcedure\n      ? DecorateQueryProcedure<TRoot, $Value>\n      : $Value extends AnyMutationProcedure\n        ? DecorateMutationProcedure<TRoot, $Value>\n        : $Value extends RouterRecord\n          ? DecoratedProcedureUtilsRecord<TRoot, $Value> & DecorateRouter\n          : never\n    : never;\n}; // Add functions that should be available at utils root\n\ntype AnyDecoratedProcedure = DecorateQueryProcedure<any, any> &\n  DecorateMutationProcedure<any, any>;\n\nexport type CreateReactUtils<\n  TRouter extends AnyRouter,\n  TSSRContext,\n> = ProtectedIntersection<\n  DecoratedTRPCContextProps<TRouter, TSSRContext>,\n  DecoratedProcedureUtilsRecord<\n    TRouter['_def']['_config']['$types'],\n    TRouter['_def']['record']\n  >\n>;\n\nexport type CreateQueryUtils<TRouter extends AnyRouter> =\n  DecoratedProcedureUtilsRecord<\n    TRouter['_def']['_config']['$types'],\n    TRouter['_def']['record']\n  >;\n\nexport const getQueryType = (\n  utilName: keyof AnyDecoratedProcedure,\n): QueryType => {\n  switch (utilName) {\n    case 'queryOptions':\n    case 'fetch':\n    case 'ensureData':\n    case 'prefetch':\n    case 'getData':\n    case 'setData':\n    case 'setQueriesData':\n      return 'query';\n\n    case 'infiniteQueryOptions':\n    case 'fetchInfinite':\n    case 'prefetchInfinite':\n    case 'getInfiniteData':\n    case 'setInfiniteData':\n      return 'infinite';\n\n    case 'setMutationDefaults':\n    case 'getMutationDefaults':\n    case 'isMutating':\n    case 'cancel':\n    case 'invalidate':\n    case 'refetch':\n    case 'reset':\n      return 'any';\n  }\n};\n\n/**\n * @internal\n */\nfunction createRecursiveUtilsProxy<TRouter extends AnyRouter>(\n  context: TRPCQueryUtils<TRouter>,\n) {\n  return createRecursiveProxy<CreateQueryUtils<TRouter>>((opts) => {\n    const path = [...opts.path];\n    const utilName = path.pop() as keyof AnyDecoratedProcedure;\n    const args = [...opts.args] as Parameters<\n      AnyDecoratedProcedure[typeof utilName]\n    >;\n    const input = args.shift(); // args can now be spread when input removed\n    const queryType = getQueryType(utilName);\n    const queryKey = getQueryKeyInternal(path, input, queryType);\n\n    const contextMap: Record<keyof AnyDecoratedProcedure, () => unknown> = {\n      infiniteQueryOptions: () =>\n        context.infiniteQueryOptions(path, queryKey, args[0]),\n      queryOptions: () => context.queryOptions(path, queryKey, ...args),\n      /**\n       * DecorateQueryProcedure\n       */\n      fetch: () => context.fetchQuery(queryKey, ...args),\n      fetchInfinite: () => context.fetchInfiniteQuery(queryKey, args[0]),\n      prefetch: () => context.prefetchQuery(queryKey, ...args),\n      prefetchInfinite: () => context.prefetchInfiniteQuery(queryKey, args[0]),\n      ensureData: () => context.ensureQueryData(queryKey, ...args),\n      invalidate: () => context.invalidateQueries(queryKey, ...args),\n      reset: () => context.resetQueries(queryKey, ...args),\n      refetch: () => context.refetchQueries(queryKey, ...args),\n      cancel: () => context.cancelQuery(queryKey, ...args),\n      setData: () => {\n        context.setQueryData(queryKey, args[0], args[1]);\n      },\n      setQueriesData: () =>\n        context.setQueriesData(queryKey, args[0], args[1], args[2]),\n      setInfiniteData: () => {\n        context.setInfiniteQueryData(queryKey, args[0], args[1]);\n      },\n      getData: () => context.getQueryData(queryKey),\n      getInfiniteData: () => context.getInfiniteQueryData(queryKey),\n      /**\n       * DecorateMutationProcedure\n       */\n      setMutationDefaults: () =>\n        context.setMutationDefaults(getMutationKeyInternal(path), input),\n      getMutationDefaults: () =>\n        context.getMutationDefaults(getMutationKeyInternal(path)),\n      isMutating: () =>\n        context.isMutating({ mutationKey: getMutationKeyInternal(path) }),\n    };\n\n    return contextMap[utilName]();\n  });\n}\n\n/**\n * @internal\n */\nexport function createReactQueryUtils<TRouter extends AnyRouter, TSSRContext>(\n  context: TRPCContextState<AnyRouter, TSSRContext>,\n) {\n  type CreateReactUtilsReturnType = CreateReactUtils<TRouter, TSSRContext>;\n\n  const clientProxy = createTRPCClientProxy(context.client);\n\n  const proxy = createRecursiveUtilsProxy(\n    context,\n  ) as CreateReactUtilsReturnType;\n\n  return createFlatProxy<CreateReactUtilsReturnType>((key) => {\n    const contextName = key as (typeof contextProps)[number];\n    if (contextName === 'client') {\n      return clientProxy;\n    }\n    if (contextProps.includes(contextName)) {\n      return context[contextName];\n    }\n\n    return proxy[key];\n  });\n}\n\n/**\n * @internal\n */\nexport function createQueryUtilsProxy<TRouter extends AnyRouter>(\n  context: TRPCQueryUtils<TRouter>,\n): CreateQueryUtils<TRouter> {\n  return createRecursiveUtilsProxy(context);\n}\n", "import type { QueryOptions } from '@tanstack/react-query';\nimport type { TRPCClient } from '@trpc/client';\nimport {\n  getUntypedClient,\n  TRPCUntypedClient,\n  type TRPCClientError,\n} from '@trpc/client';\nimport type {\n  AnyProcedure,\n  AnyQueryProcedure,\n  AnyRootTypes,\n  AnyRouter,\n  inferProcedureInput,\n  inferTransformedProcedureOutput,\n  RouterRecord,\n} from '@trpc/server/unstable-core-do-not-import';\nimport { createRecursiveProxy } from '@trpc/server/unstable-core-do-not-import';\nimport { getQueryKeyInternal } from '../../internals/getQueryKey';\nimport type {\n  TrpcQueryOptionsForUseQueries,\n  TrpcQueryOptionsForUseSuspenseQueries,\n} from '../../internals/useQueries';\nimport type { TRPCUseQueryBaseOptions } from '../hooks/types';\n\ntype GetQueryOptions<\n  TRoot extends AnyRootTypes,\n  TProcedure extends AnyProcedure,\n> = <TData = inferTransformedProcedureOutput<TRoot, TProcedure>>(\n  input: inferProcedureInput<TProcedure>,\n  opts?: TrpcQueryOptionsForUseQueries<\n    inferTransformedProcedureOutput<TRoot, TProcedure>,\n    TData,\n    TRPCClientError<TRoot>\n  >,\n) => TrpcQueryOptionsForUseQueries<\n  inferTransformedProcedureOutput<TRoot, TProcedure>,\n  TData,\n  TRPCClientError<TRoot>\n>;\n\n/**\n * @internal\n */\nexport type UseQueriesProcedureRecord<\n  TRoot extends AnyRootTypes,\n  TRecord extends RouterRecord,\n> = {\n  [TKey in keyof TRecord]: TRecord[TKey] extends infer $Value\n    ? $Value extends AnyQueryProcedure\n      ? GetQueryOptions<TRoot, $Value>\n      : $Value extends RouterRecord\n        ? UseQueriesProcedureRecord<TRoot, $Value>\n        : never\n    : never;\n};\n\ntype GetSuspenseQueryOptions<\n  TRoot extends AnyRootTypes,\n  TProcedure extends AnyQueryProcedure,\n> = <TData = inferTransformedProcedureOutput<TRoot, TProcedure>>(\n  input: inferProcedureInput<TProcedure>,\n  opts?: TrpcQueryOptionsForUseSuspenseQueries<\n    inferTransformedProcedureOutput<TRoot, TProcedure>,\n    TData,\n    TRPCClientError<TRoot>\n  >,\n) => TrpcQueryOptionsForUseSuspenseQueries<\n  inferTransformedProcedureOutput<TRoot, TProcedure>,\n  TData,\n  TRPCClientError<TRoot>\n>;\n\n/**\n * @internal\n */\nexport type UseSuspenseQueriesProcedureRecord<\n  TRoot extends AnyRootTypes,\n  TRecord extends RouterRecord,\n> = {\n  [TKey in keyof TRecord]: TRecord[TKey] extends infer $Value\n    ? $Value extends AnyQueryProcedure\n      ? GetSuspenseQueryOptions<TRoot, $Value>\n      : $Value extends RouterRecord\n        ? UseSuspenseQueriesProcedureRecord<TRoot, $Value>\n        : never\n    : never;\n};\n\n/**\n * Create proxy for `useQueries` options\n * @internal\n */\nexport function createUseQueries<TRouter extends AnyRouter>(\n  client: TRPCUntypedClient<TRouter> | TRPCClient<TRouter>,\n) {\n  const untypedClient: TRPCUntypedClient<TRouter> =\n    client instanceof TRPCUntypedClient ? client : getUntypedClient(client);\n\n  return createRecursiveProxy<\n    UseQueriesProcedureRecord<\n      TRouter['_def']['_config']['$types'],\n      TRouter['_def']['record']\n    >\n  >((opts) => {\n    const arrayPath = opts.path;\n    const dotPath = arrayPath.join('.');\n    const [input, _opts] = opts.args as [\n      unknown,\n      Partial<QueryOptions> & TRPCUseQueryBaseOptions,\n    ];\n\n    const options: QueryOptions = {\n      queryKey: getQueryKeyInternal(arrayPath, input, 'query'),\n      queryFn: () => {\n        return untypedClient.query(dotPath, input, _opts?.trpc);\n      },\n      ..._opts,\n    };\n\n    return options;\n  });\n}\n", "import type { TRPCQueryKey } from './getQueryKey';\n\n/**\n * @internal\n */\nexport function getClientArgs<TOptions>(\n  queryKey: TRPCQueryKey,\n  opts: TOptions,\n  infiniteParams?: {\n    pageParam: any;\n    direction: 'forward' | 'backward';\n  },\n) {\n  const path = queryKey[0];\n  let input = queryKey[1]?.input;\n  if (infiniteParams) {\n    input = {\n      ...(input ?? {}),\n      ...(infiniteParams.pageParam ? { cursor: infiniteParams.pageParam } : {}),\n      direction: infiniteParams.direction,\n    };\n  }\n  return [path.join('.'), input, (opts as any)?.trpc] as const;\n}\n", "function _asyncIterator(r) {\n  var n,\n    t,\n    o,\n    e = 2;\n  for (\"undefined\" != typeof Symbol && (t = Symbol.asyncIterator, o = Symbol.iterator); e--;) {\n    if (t && null != (n = r[t])) return n.call(r);\n    if (o && null != (n = r[o])) return new AsyncFromSyncIterator(n.call(r));\n    t = \"@@asyncIterator\", o = \"@@iterator\";\n  }\n  throw new TypeError(\"Object is not async iterable\");\n}\nfunction AsyncFromSyncIterator(r) {\n  function AsyncFromSyncIteratorContinuation(r) {\n    if (Object(r) !== r) return Promise.reject(new TypeError(r + \" is not an object.\"));\n    var n = r.done;\n    return Promise.resolve(r.value).then(function (r) {\n      return {\n        value: r,\n        done: n\n      };\n    });\n  }\n  return AsyncFromSyncIterator = function AsyncFromSyncIterator(r) {\n    this.s = r, this.n = r.next;\n  }, AsyncFromSyncIterator.prototype = {\n    s: null,\n    n: null,\n    next: function next() {\n      return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments));\n    },\n    \"return\": function _return(r) {\n      var n = this.s[\"return\"];\n      return void 0 === n ? Promise.resolve({\n        value: r,\n        done: !0\n      }) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments));\n    },\n    \"throw\": function _throw(r) {\n      var n = this.s[\"return\"];\n      return void 0 === n ? Promise.reject(r) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments));\n    }\n  }, new AsyncFromSyncIterator(r);\n}\nmodule.exports = _asyncIterator, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "import type { QueryClient } from '@tanstack/react-query';\nimport * as React from 'react';\nimport type { TRPCQueryOptionsResult } from '../shared';\nimport type { TRPCHookResult } from '../shared/hooks/types';\nimport type { TRPCQueryKey } from './getQueryKey';\n\nexport function createTRPCOptionsResult(value: {\n  path: readonly string[];\n}): TRPCQueryOptionsResult['trpc'] {\n  const path = value.path.join('.');\n\n  return {\n    path,\n  };\n}\n\n/**\n * Makes a stable reference of the `trpc` prop\n */\nexport function useHookResult(value: {\n  path: readonly string[];\n}): TRPCHookResult['trpc'] {\n  const result = createTRPCOptionsResult(value);\n  return React.useMemo(() => result, [result]);\n}\n\n/**\n * @internal\n */\nexport async function buildQueryFromAsyncIterable(\n  asyncIterable: AsyncIterable<unknown>,\n  queryClient: QueryClient,\n  queryKey: TRPCQueryKey,\n) {\n  const queryCache = queryClient.getQueryCache();\n\n  const query = queryCache.build(queryClient, {\n    queryKey,\n  });\n\n  query.setState({\n    data: [],\n    status: 'success',\n  });\n\n  const aggregate: unknown[] = [];\n  for await (const value of asyncIterable) {\n    aggregate.push(value);\n\n    query.setState({\n      data: [...aggregate],\n    });\n  }\n  return aggregate;\n}\n", "import type { QueryFunctionContext } from '@tanstack/react-query';\nimport {\n  infiniteQueryOptions,\n  queryOptions,\n  skipToken,\n  type QueryClient,\n} from '@tanstack/react-query';\nimport type { TRPCClient, TRPCClientError } from '@trpc/client';\nimport { getUntypedClient, TRPCUntypedClient } from '@trpc/client';\nimport type { AnyRouter } from '@trpc/server/unstable-core-do-not-import';\nimport { isAsyncIterable } from '@trpc/server/unstable-core-do-not-import';\nimport type { AnyClientTypes } from '@trpc/server/unstable-core-do-not-import/clientish/inferrable';\nimport { getClientArgs } from '../internals/getClientArgs';\nimport type { TRPCQueryKey } from '../internals/getQueryKey';\nimport {\n  buildQueryFromAsyncIterable,\n  createTRPCOptionsResult,\n} from '../internals/trpcResult';\nimport type { DefinedTRPCQueryOptionsOut } from '../shared';\nimport { type TRPCQueryUtils } from '../shared';\n\nexport interface CreateQueryUtilsOptions<TRouter extends AnyRouter> {\n  /**\n   * The `TRPCClient`\n   */\n  client: TRPCClient<TRouter> | TRPCUntypedClient<TRouter>;\n  /**\n   * The `QueryClient` from `react-query`\n   */\n  queryClient: QueryClient;\n}\n\n/**\n * Creates a set of utility functions that can be used to interact with `react-query`\n * @param opts the `TRPCClient` and `QueryClient` to use\n * @returns a set of utility functions that can be used to interact with `react-query`\n * @internal\n */\nexport function createUtilityFunctions<TRouter extends AnyRouter>(\n  opts: CreateQueryUtilsOptions<TRouter>,\n): TRPCQueryUtils<TRouter> {\n  const { client, queryClient } = opts;\n  const untypedClient =\n    client instanceof TRPCUntypedClient ? client : getUntypedClient(client);\n\n  return {\n    infiniteQueryOptions: (path, queryKey, opts) => {\n      const inputIsSkipToken = queryKey[1]?.input === skipToken;\n\n      const queryFn = async (\n        queryFnContext: QueryFunctionContext<TRPCQueryKey, unknown>,\n      ): Promise<unknown> => {\n        const actualOpts = {\n          ...opts,\n          trpc: {\n            ...opts?.trpc,\n            ...(opts?.trpc?.abortOnUnmount\n              ? { signal: queryFnContext.signal }\n              : { signal: null }),\n          },\n        };\n\n        const result = await untypedClient.query(\n          ...getClientArgs(queryKey, actualOpts, {\n            direction: queryFnContext.direction,\n            pageParam: queryFnContext.pageParam,\n          }),\n        );\n\n        return result;\n      };\n\n      return Object.assign(\n        infiniteQueryOptions({\n          ...opts,\n          initialData: opts?.initialData as any,\n          queryKey,\n          queryFn: inputIsSkipToken ? skipToken : queryFn,\n          initialPageParam: (opts?.initialCursor as any) ?? null,\n        }),\n        { trpc: createTRPCOptionsResult({ path }) },\n      );\n    },\n\n    queryOptions: (path, queryKey, opts) => {\n      const inputIsSkipToken = queryKey[1]?.input === skipToken;\n\n      const queryFn = async (\n        queryFnContext: QueryFunctionContext<TRPCQueryKey>,\n      ): Promise<unknown> => {\n        const actualOpts = {\n          ...opts,\n          trpc: {\n            ...opts?.trpc,\n            ...(opts?.trpc?.abortOnUnmount\n              ? { signal: queryFnContext.signal }\n              : { signal: null }),\n          },\n        };\n\n        const result = await untypedClient.query(\n          ...getClientArgs(queryKey, actualOpts),\n        );\n\n        if (isAsyncIterable(result)) {\n          return buildQueryFromAsyncIterable(result, queryClient, queryKey);\n        }\n\n        return result;\n      };\n\n      return Object.assign(\n        queryOptions({\n          ...opts,\n          initialData: opts?.initialData,\n          queryKey,\n          queryFn: inputIsSkipToken ? skipToken : queryFn,\n        }),\n        { trpc: createTRPCOptionsResult({ path }) },\n      ) as DefinedTRPCQueryOptionsOut<\n        unknown,\n        unknown,\n        TRPCClientError<AnyClientTypes>\n      >;\n    },\n\n    fetchQuery: (queryKey, opts) => {\n      return queryClient.fetchQuery({\n        ...opts,\n        queryKey,\n        queryFn: () => untypedClient.query(...getClientArgs(queryKey, opts)),\n      });\n    },\n\n    fetchInfiniteQuery: (queryKey, opts) => {\n      return queryClient.fetchInfiniteQuery({\n        ...opts,\n        queryKey,\n        queryFn: ({ pageParam, direction }) => {\n          return untypedClient.query(\n            ...getClientArgs(queryKey, opts, { pageParam, direction }),\n          );\n        },\n        initialPageParam: opts?.initialCursor ?? null,\n      });\n    },\n\n    prefetchQuery: (queryKey, opts) => {\n      return queryClient.prefetchQuery({\n        ...opts,\n        queryKey,\n        queryFn: () => untypedClient.query(...getClientArgs(queryKey, opts)),\n      });\n    },\n\n    prefetchInfiniteQuery: (queryKey, opts) => {\n      return queryClient.prefetchInfiniteQuery({\n        ...opts,\n        queryKey,\n        queryFn: ({ pageParam, direction }) => {\n          return untypedClient.query(\n            ...getClientArgs(queryKey, opts, { pageParam, direction }),\n          );\n        },\n        initialPageParam: opts?.initialCursor ?? null,\n      });\n    },\n\n    ensureQueryData: (queryKey, opts) => {\n      return queryClient.ensureQueryData({\n        ...opts,\n        queryKey,\n        queryFn: () => untypedClient.query(...getClientArgs(queryKey, opts)),\n      });\n    },\n\n    invalidateQueries: (queryKey, filters, options) => {\n      return queryClient.invalidateQueries(\n        {\n          ...filters,\n          queryKey,\n        },\n        options,\n      );\n    },\n    resetQueries: (queryKey, filters, options) => {\n      return queryClient.resetQueries(\n        {\n          ...filters,\n          queryKey,\n        },\n        options,\n      );\n    },\n\n    refetchQueries: (queryKey, filters, options) => {\n      return queryClient.refetchQueries(\n        {\n          ...filters,\n          queryKey,\n        },\n        options,\n      );\n    },\n\n    cancelQuery: (queryKey, options) => {\n      return queryClient.cancelQueries(\n        {\n          queryKey,\n        },\n        options,\n      );\n    },\n\n    setQueryData: (queryKey, updater, options) => {\n      return queryClient.setQueryData(queryKey, updater as any, options);\n    },\n\n    // eslint-disable-next-line max-params\n    setQueriesData: (queryKey, filters, updater, options) => {\n      return queryClient.setQueriesData(\n        {\n          ...filters,\n          queryKey,\n        },\n        updater,\n        options,\n      );\n    },\n\n    getQueryData: (queryKey) => {\n      return queryClient.getQueryData(queryKey);\n    },\n\n    setInfiniteQueryData: (queryKey, updater, options) => {\n      return queryClient.setQueryData(queryKey, updater as any, options);\n    },\n\n    getInfiniteQueryData: (queryKey) => {\n      return queryClient.getQueryData(queryKey);\n    },\n\n    setMutationDefaults: (mutationKey, options) => {\n      const path = mutationKey[0];\n      const canonicalMutationFn = (input: unknown) => {\n        return untypedClient.mutation(\n          ...getClientArgs([path, { input }], opts),\n        );\n      };\n      return queryClient.setMutationDefaults(\n        mutationKey,\n        typeof options === 'function'\n          ? options({ canonicalMutationFn })\n          : options,\n      );\n    },\n\n    getMutationDefaults: (mutationKey) => {\n      return queryClient.getMutationDefaults(mutationKey);\n    },\n\n    isMutating: (filters) => {\n      return queryClient.isMutating({\n        ...filters,\n        exact: true,\n      });\n    },\n  };\n}\n", "// TODO: Look into fixing react-compiler support\n/* eslint-disable react-hooks/react-compiler */\nimport {\n  useInfiniteQuery as __useInfiniteQuery,\n  useMutation as __useMutation,\n  usePrefetchInfiniteQuery as __usePrefetchInfiniteQuery,\n  useQueries as __useQueries,\n  useQuery as __useQuery,\n  useSuspenseInfiniteQuery as __useSuspenseInfiniteQuery,\n  useSuspenseQueries as __useSuspenseQueries,\n  useSuspenseQuery as __useSuspenseQuery,\n  usePrefetchQuery as _usePrefetchQuery,\n  hashKey,\n  skipToken,\n} from '@tanstack/react-query';\nimport type { TRPCClientErrorLike } from '@trpc/client';\nimport {\n  createTRPCClient,\n  getUntypedClient,\n  TRPCUntypedClient,\n} from '@trpc/client';\nimport type { Unsubscribable } from '@trpc/server/observable';\nimport type { AnyRouter } from '@trpc/server/unstable-core-do-not-import';\nimport { isAsyncIterable } from '@trpc/server/unstable-core-do-not-import';\nimport * as React from 'react';\nimport type { SSRState, TRPCContextState } from '../../internals/context';\nimport { TRPCContext } from '../../internals/context';\nimport { getClientArgs } from '../../internals/getClientArgs';\nimport type { TRPCQueryKey } from '../../internals/getQueryKey';\nimport {\n  getMutationKeyInternal,\n  getQueryKeyInternal,\n} from '../../internals/getQueryKey';\nimport {\n  buildQueryFromAsyncIterable,\n  useHookResult,\n} from '../../internals/trpcResult';\nimport type {\n  TRPCUseQueries,\n  TRPCUseSuspenseQueries,\n} from '../../internals/useQueries';\nimport { createUtilityFunctions } from '../../utils/createUtilityFunctions';\nimport { createUseQueries } from '../proxy/useQueriesProxy';\nimport type { CreateTRPCReactOptions, UseMutationOverride } from '../types';\nimport type {\n  TRPCProvider,\n  TRPCQueryOptions,\n  TRPCSubscriptionConnectingResult,\n  TRPCSubscriptionIdleResult,\n  TRPCSubscriptionResult,\n  UseTRPCInfiniteQueryOptions,\n  UseTRPCInfiniteQueryResult,\n  UseTRPCMutationOptions,\n  UseTRPCMutationResult,\n  UseTRPCPrefetchInfiniteQueryOptions,\n  UseTRPCPrefetchQueryOptions,\n  UseTRPCQueryOptions,\n  UseTRPCQueryResult,\n  UseTRPCSubscriptionOptions,\n  UseTRPCSuspenseInfiniteQueryOptions,\n  UseTRPCSuspenseInfiniteQueryResult,\n  UseTRPCSuspenseQueryOptions,\n  UseTRPCSuspenseQueryResult,\n} from './types';\n\nconst trackResult = <T extends object>(\n  result: T,\n  onTrackResult: (key: keyof T) => void,\n): T => {\n  const trackedResult = new Proxy(result, {\n    get(target, prop) {\n      onTrackResult(prop as keyof T);\n      return target[prop as keyof T];\n    },\n  });\n\n  return trackedResult;\n};\n\n/**\n * @internal\n */\nexport function createRootHooks<\n  TRouter extends AnyRouter,\n  TSSRContext = unknown,\n>(config?: CreateTRPCReactOptions<TRouter>) {\n  const mutationSuccessOverride: UseMutationOverride['onSuccess'] =\n    config?.overrides?.useMutation?.onSuccess ??\n    ((options) => options.originalFn());\n\n  type TError = TRPCClientErrorLike<TRouter>;\n\n  type ProviderContext = TRPCContextState<TRouter, TSSRContext>;\n\n  const Context = (config?.context ??\n    TRPCContext) as React.Context<ProviderContext>;\n\n  const createClient = createTRPCClient<TRouter>;\n\n  const TRPCProvider: TRPCProvider<TRouter, TSSRContext> = (props) => {\n    const { abortOnUnmount = false, queryClient, ssrContext } = props;\n    const [ssrState, setSSRState] = React.useState<SSRState>(\n      props.ssrState ?? false,\n    );\n\n    const client: TRPCUntypedClient<TRouter> =\n      props.client instanceof TRPCUntypedClient\n        ? props.client\n        : getUntypedClient(props.client);\n\n    const fns = React.useMemo(\n      () =>\n        createUtilityFunctions({\n          client,\n          queryClient,\n        }),\n      [client, queryClient],\n    );\n\n    const contextValue = React.useMemo<ProviderContext>(\n      () => ({\n        abortOnUnmount,\n        queryClient,\n        client,\n        ssrContext: ssrContext ?? null,\n        ssrState,\n        ...fns,\n      }),\n      [abortOnUnmount, client, fns, queryClient, ssrContext, ssrState],\n    );\n\n    React.useEffect(() => {\n      // Only updating state to `mounted` if we are using SSR.\n      // This makes it so we don't have an unnecessary re-render when opting out of SSR.\n      setSSRState((state) => (state ? 'mounted' : false));\n    }, []);\n    return (\n      <Context.Provider value={contextValue}>{props.children}</Context.Provider>\n    );\n  };\n\n  function useContext() {\n    const context = React.useContext(Context);\n\n    if (!context) {\n      throw new Error(\n        'Unable to find tRPC Context. Did you forget to wrap your App inside `withTRPC` HoC?',\n      );\n    }\n    return context;\n  }\n\n  /**\n   * Hack to make sure errors return `status`='error` when doing SSR\n   * @see https://github.com/trpc/trpc/pull/1645\n   */\n  function useSSRQueryOptionsIfNeeded<\n    TOptions extends { retryOnMount?: boolean } | undefined,\n  >(queryKey: TRPCQueryKey, opts: TOptions): TOptions {\n    const { queryClient, ssrState } = useContext();\n    return ssrState &&\n      ssrState !== 'mounted' &&\n      queryClient.getQueryCache().find({ queryKey })?.state.status === 'error'\n      ? {\n          retryOnMount: false,\n          ...opts,\n        }\n      : opts;\n  }\n\n  function useQuery(\n    path: readonly string[],\n    input: unknown,\n    opts?: UseTRPCQueryOptions<unknown, unknown, TError>,\n  ): UseTRPCQueryResult<unknown, TError> {\n    const context = useContext();\n    const { abortOnUnmount, client, ssrState, queryClient, prefetchQuery } =\n      context;\n    const queryKey = getQueryKeyInternal(path, input, 'query');\n\n    const defaultOpts = queryClient.getQueryDefaults(queryKey);\n\n    const isInputSkipToken = input === skipToken;\n\n    if (\n      typeof window === 'undefined' &&\n      ssrState === 'prepass' &&\n      opts?.trpc?.ssr !== false &&\n      (opts?.enabled ?? defaultOpts?.enabled) !== false &&\n      !isInputSkipToken &&\n      !queryClient.getQueryCache().find({ queryKey })\n    ) {\n      void prefetchQuery(queryKey, opts as any);\n    }\n    const ssrOpts = useSSRQueryOptionsIfNeeded(queryKey, {\n      ...defaultOpts,\n      ...opts,\n    });\n\n    const shouldAbortOnUnmount =\n      opts?.trpc?.abortOnUnmount ?? config?.abortOnUnmount ?? abortOnUnmount;\n\n    const hook = __useQuery(\n      {\n        ...ssrOpts,\n        queryKey: queryKey as any,\n        queryFn: isInputSkipToken\n          ? input\n          : async (queryFunctionContext) => {\n              const actualOpts = {\n                ...ssrOpts,\n                trpc: {\n                  ...ssrOpts?.trpc,\n                  ...(shouldAbortOnUnmount\n                    ? { signal: queryFunctionContext.signal }\n                    : { signal: null }),\n                },\n              };\n\n              const result = await client.query(\n                ...getClientArgs(queryKey, actualOpts),\n              );\n\n              if (isAsyncIterable(result)) {\n                return buildQueryFromAsyncIterable(\n                  result,\n                  queryClient,\n                  queryKey,\n                );\n              }\n              return result;\n            },\n      },\n      queryClient,\n    ) as UseTRPCQueryResult<unknown, TError>;\n\n    hook.trpc = useHookResult({\n      path,\n    });\n\n    return hook;\n  }\n\n  function usePrefetchQuery(\n    path: string[],\n    input: unknown,\n    opts?: UseTRPCPrefetchQueryOptions<unknown, unknown, TError>,\n  ): void {\n    const context = useContext();\n    const queryKey = getQueryKeyInternal(path, input, 'query');\n\n    const isInputSkipToken = input === skipToken;\n\n    const shouldAbortOnUnmount =\n      opts?.trpc?.abortOnUnmount ??\n      config?.abortOnUnmount ??\n      context.abortOnUnmount;\n\n    _usePrefetchQuery({\n      ...opts,\n      queryKey: queryKey as any,\n      queryFn: isInputSkipToken\n        ? input\n        : (queryFunctionContext) => {\n            const actualOpts = {\n              trpc: {\n                ...opts?.trpc,\n                ...(shouldAbortOnUnmount\n                  ? { signal: queryFunctionContext.signal }\n                  : {}),\n              },\n            };\n\n            return context.client.query(...getClientArgs(queryKey, actualOpts));\n          },\n    });\n  }\n\n  function useSuspenseQuery(\n    path: readonly string[],\n    input: unknown,\n    opts?: UseTRPCSuspenseQueryOptions<unknown, unknown, TError>,\n  ): UseTRPCSuspenseQueryResult<unknown, TError> {\n    const context = useContext();\n    const queryKey = getQueryKeyInternal(path, input, 'query');\n\n    const shouldAbortOnUnmount =\n      opts?.trpc?.abortOnUnmount ??\n      config?.abortOnUnmount ??\n      context.abortOnUnmount;\n\n    const hook = __useSuspenseQuery(\n      {\n        ...opts,\n        queryKey: queryKey as any,\n        queryFn: (queryFunctionContext) => {\n          const actualOpts = {\n            ...opts,\n            trpc: {\n              ...opts?.trpc,\n              ...(shouldAbortOnUnmount\n                ? { signal: queryFunctionContext.signal }\n                : { signal: null }),\n            },\n          };\n\n          return context.client.query(...getClientArgs(queryKey, actualOpts));\n        },\n      },\n      context.queryClient,\n    ) as UseTRPCQueryResult<unknown, TError>;\n\n    hook.trpc = useHookResult({\n      path,\n    });\n\n    return [hook.data, hook as any];\n  }\n\n  function useMutation(\n    path: readonly string[],\n    opts?: UseTRPCMutationOptions<unknown, TError, unknown, unknown>,\n  ): UseTRPCMutationResult<unknown, TError, unknown, unknown> {\n    const { client, queryClient } = useContext();\n\n    const mutationKey = getMutationKeyInternal(path);\n\n    const defaultOpts = queryClient.defaultMutationOptions(\n      queryClient.getMutationDefaults(mutationKey),\n    );\n\n    const hook = __useMutation(\n      {\n        ...opts,\n        mutationKey: mutationKey,\n        mutationFn: (input) => {\n          return client.mutation(...getClientArgs([path, { input }], opts));\n        },\n        onSuccess(...args) {\n          const originalFn = () =>\n            opts?.onSuccess?.(...args) ?? defaultOpts?.onSuccess?.(...args);\n\n          return mutationSuccessOverride({\n            originalFn,\n            queryClient,\n            meta: opts?.meta ?? defaultOpts?.meta ?? {},\n          });\n        },\n      },\n      queryClient,\n    ) as UseTRPCMutationResult<unknown, TError, unknown, unknown>;\n\n    hook.trpc = useHookResult({\n      path,\n    });\n\n    return hook;\n  }\n  const initialStateIdle: Omit<TRPCSubscriptionIdleResult<unknown>, 'reset'> = {\n    data: undefined,\n    error: null,\n    status: 'idle',\n  };\n\n  const initialStateConnecting: Omit<\n    TRPCSubscriptionConnectingResult<unknown, TError>,\n    'reset'\n  > = {\n    data: undefined,\n    error: null,\n    status: 'connecting',\n  };\n\n  /* istanbul ignore next -- @preserve */\n  function useSubscription(\n    path: readonly string[],\n    input: unknown,\n    opts: UseTRPCSubscriptionOptions<unknown, TError>,\n  ) {\n    const enabled = opts?.enabled ?? input !== skipToken;\n    const queryKey = hashKey(getQueryKeyInternal(path, input, 'any'));\n    const { client } = useContext();\n\n    const optsRef = React.useRef<typeof opts>(opts);\n    React.useEffect(() => {\n      optsRef.current = opts;\n    });\n\n    type $Result = TRPCSubscriptionResult<unknown, TError>;\n\n    const [trackedProps] = React.useState(new Set<keyof $Result>([]));\n\n    const addTrackedProp = React.useCallback(\n      (key: keyof $Result) => {\n        trackedProps.add(key);\n      },\n      [trackedProps],\n    );\n\n    const currentSubscriptionRef = React.useRef<Unsubscribable>(null);\n\n    const updateState = React.useCallback(\n      (callback: (prevState: $Result) => $Result) => {\n        const prev = resultRef.current;\n        const next = (resultRef.current = callback(prev));\n\n        let shouldUpdate = false;\n        for (const key of trackedProps) {\n          if (prev[key] !== next[key]) {\n            shouldUpdate = true;\n            break;\n          }\n        }\n        if (shouldUpdate) {\n          setState(trackResult(next, addTrackedProp));\n        }\n      },\n      [addTrackedProp, trackedProps],\n    );\n\n    const reset = React.useCallback((): void => {\n      // unsubscribe from the previous subscription\n      currentSubscriptionRef.current?.unsubscribe();\n\n      if (!enabled) {\n        updateState(() => ({ ...initialStateIdle, reset }));\n        return;\n      }\n      updateState(() => ({ ...initialStateConnecting, reset }));\n      const subscription = client.subscription(\n        path.join('.'),\n        input ?? undefined,\n        {\n          onStarted: () => {\n            optsRef.current.onStarted?.();\n            updateState((prev) => ({\n              ...prev,\n              status: 'pending',\n              error: null,\n            }));\n          },\n          onData: (data) => {\n            optsRef.current.onData?.(data);\n            updateState((prev) => ({\n              ...prev,\n              status: 'pending',\n              data,\n              error: null,\n            }));\n          },\n          onError: (error) => {\n            optsRef.current.onError?.(error);\n            updateState((prev) => ({\n              ...prev,\n              status: 'error',\n              error,\n            }));\n          },\n          onConnectionStateChange: (result) => {\n            updateState((prev) => {\n              switch (result.state) {\n                case 'idle':\n                  return {\n                    ...prev,\n                    status: result.state,\n                    error: null,\n                    data: undefined,\n                  };\n                case 'connecting':\n                  return {\n                    ...prev,\n                    error: result.error,\n                    status: result.state,\n                  };\n\n                case 'pending':\n                  // handled when data is / onStarted\n                  return prev;\n              }\n            });\n          },\n          onComplete: () => {\n            optsRef.current.onComplete?.();\n\n            // In the case of WebSockets, the connection might not be idle so `onConnectionStateChange` will not be called until the connection is closed.\n            // In this case, we need to set the state to idle manually.\n            updateState((prev) => ({\n              ...prev,\n              status: 'idle',\n              error: null,\n              data: undefined,\n            }));\n\n            // (We might want to add a `connectionState` to the state to track the connection state separately)\n          },\n        },\n      );\n\n      currentSubscriptionRef.current = subscription;\n\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [client, queryKey, enabled, updateState]);\n    React.useEffect(() => {\n      reset();\n\n      return () => {\n        currentSubscriptionRef.current?.unsubscribe();\n      };\n    }, [reset]);\n\n    const resultRef = React.useRef<$Result>(\n      enabled\n        ? { ...initialStateConnecting, reset }\n        : { ...initialStateIdle, reset },\n    );\n\n    const [state, setState] = React.useState<$Result>(\n      trackResult(resultRef.current, addTrackedProp),\n    );\n\n    return state;\n  }\n\n  function useInfiniteQuery(\n    path: readonly string[],\n    input: unknown,\n    opts: UseTRPCInfiniteQueryOptions<unknown, unknown, TError>,\n  ): UseTRPCInfiniteQueryResult<unknown, TError, unknown> {\n    const {\n      client,\n      ssrState,\n      prefetchInfiniteQuery,\n      queryClient,\n      abortOnUnmount,\n    } = useContext();\n    const queryKey = getQueryKeyInternal(path, input, 'infinite');\n\n    const defaultOpts = queryClient.getQueryDefaults(queryKey);\n\n    const isInputSkipToken = input === skipToken;\n\n    if (\n      typeof window === 'undefined' &&\n      ssrState === 'prepass' &&\n      opts?.trpc?.ssr !== false &&\n      (opts?.enabled ?? defaultOpts?.enabled) !== false &&\n      !isInputSkipToken &&\n      !queryClient.getQueryCache().find({ queryKey })\n    ) {\n      void prefetchInfiniteQuery(queryKey, { ...defaultOpts, ...opts } as any);\n    }\n\n    const ssrOpts = useSSRQueryOptionsIfNeeded(queryKey, {\n      ...defaultOpts,\n      ...opts,\n    });\n\n    // request option should take priority over global\n    const shouldAbortOnUnmount = opts?.trpc?.abortOnUnmount ?? abortOnUnmount;\n\n    const hook = __useInfiniteQuery(\n      {\n        ...ssrOpts,\n        initialPageParam: opts.initialCursor ?? null,\n        persister: opts.persister,\n        queryKey: queryKey as any,\n        queryFn: isInputSkipToken\n          ? input\n          : (queryFunctionContext) => {\n              const actualOpts = {\n                ...ssrOpts,\n                trpc: {\n                  ...ssrOpts?.trpc,\n                  ...(shouldAbortOnUnmount\n                    ? { signal: queryFunctionContext.signal }\n                    : { signal: null }),\n                },\n              };\n\n              return client.query(\n                ...getClientArgs(queryKey, actualOpts, {\n                  pageParam:\n                    queryFunctionContext.pageParam ?? opts.initialCursor,\n                  direction: queryFunctionContext.direction,\n                }),\n              );\n            },\n      },\n      queryClient,\n    ) as UseTRPCInfiniteQueryResult<unknown, TError, unknown>;\n\n    hook.trpc = useHookResult({\n      path,\n    });\n    return hook;\n  }\n\n  function usePrefetchInfiniteQuery(\n    path: string[],\n    input: unknown,\n    opts: UseTRPCPrefetchInfiniteQueryOptions<unknown, unknown, TError>,\n  ): void {\n    const context = useContext();\n    const queryKey = getQueryKeyInternal(path, input, 'infinite');\n\n    const defaultOpts = context.queryClient.getQueryDefaults(queryKey);\n\n    const isInputSkipToken = input === skipToken;\n\n    const ssrOpts = useSSRQueryOptionsIfNeeded(queryKey, {\n      ...defaultOpts,\n      ...opts,\n    });\n\n    // request option should take priority over global\n    const shouldAbortOnUnmount =\n      opts?.trpc?.abortOnUnmount ?? context.abortOnUnmount;\n\n    __usePrefetchInfiniteQuery({\n      ...opts,\n      initialPageParam: opts.initialCursor ?? null,\n      queryKey,\n      queryFn: isInputSkipToken\n        ? input\n        : (queryFunctionContext) => {\n            const actualOpts = {\n              ...ssrOpts,\n              trpc: {\n                ...ssrOpts?.trpc,\n                ...(shouldAbortOnUnmount\n                  ? { signal: queryFunctionContext.signal }\n                  : {}),\n              },\n            };\n\n            return context.client.query(\n              ...getClientArgs(queryKey, actualOpts, {\n                pageParam: queryFunctionContext.pageParam ?? opts.initialCursor,\n                direction: queryFunctionContext.direction,\n              }),\n            );\n          },\n    });\n  }\n\n  function useSuspenseInfiniteQuery(\n    path: readonly string[],\n    input: unknown,\n    opts: UseTRPCSuspenseInfiniteQueryOptions<unknown, unknown, TError>,\n  ): UseTRPCSuspenseInfiniteQueryResult<unknown, TError, unknown> {\n    const context = useContext();\n    const queryKey = getQueryKeyInternal(path, input, 'infinite');\n\n    const defaultOpts = context.queryClient.getQueryDefaults(queryKey);\n\n    const ssrOpts = useSSRQueryOptionsIfNeeded(queryKey, {\n      ...defaultOpts,\n      ...opts,\n    });\n\n    // request option should take priority over global\n    const shouldAbortOnUnmount =\n      opts?.trpc?.abortOnUnmount ?? context.abortOnUnmount;\n\n    const hook = __useSuspenseInfiniteQuery(\n      {\n        ...opts,\n        initialPageParam: opts.initialCursor ?? null,\n        queryKey,\n        queryFn: (queryFunctionContext) => {\n          const actualOpts = {\n            ...ssrOpts,\n            trpc: {\n              ...ssrOpts?.trpc,\n              ...(shouldAbortOnUnmount\n                ? { signal: queryFunctionContext.signal }\n                : {}),\n            },\n          };\n\n          return context.client.query(\n            ...getClientArgs(queryKey, actualOpts, {\n              pageParam: queryFunctionContext.pageParam ?? opts.initialCursor,\n              direction: queryFunctionContext.direction,\n            }),\n          );\n        },\n      },\n      context.queryClient,\n    ) as UseTRPCInfiniteQueryResult<unknown, TError, unknown>;\n\n    hook.trpc = useHookResult({\n      path,\n    });\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return [hook.data!, hook as any];\n  }\n\n  const useQueries: TRPCUseQueries<TRouter> = (queriesCallback, options) => {\n    const { ssrState, queryClient, prefetchQuery, client } = useContext();\n\n    const proxy = createUseQueries(client);\n\n    const queries = queriesCallback(proxy);\n\n    if (typeof window === 'undefined' && ssrState === 'prepass') {\n      for (const query of queries) {\n        const queryOption = query as TRPCQueryOptions<any, any>;\n        if (\n          queryOption.trpc?.ssr !== false &&\n          !queryClient.getQueryCache().find({ queryKey: queryOption.queryKey })\n        ) {\n          void prefetchQuery(queryOption.queryKey, queryOption as any);\n        }\n      }\n    }\n\n    return __useQueries(\n      {\n        queries: queries.map((query) => ({\n          ...query,\n          queryKey: (query as TRPCQueryOptions<any, any>).queryKey,\n        })),\n        combine: options?.combine as any,\n      },\n      queryClient,\n    );\n  };\n\n  const useSuspenseQueries: TRPCUseSuspenseQueries<TRouter> = (\n    queriesCallback,\n  ) => {\n    const { queryClient, client } = useContext();\n\n    const proxy = createUseQueries(client);\n\n    const queries = queriesCallback(proxy);\n\n    const hook = __useSuspenseQueries(\n      {\n        queries: queries.map((query) => ({\n          ...query,\n          queryFn: query.queryFn,\n          queryKey: (query as TRPCQueryOptions<any, any>).queryKey,\n        })),\n      },\n      queryClient,\n    );\n\n    return [hook.map((h) => h.data), hook] as any;\n  };\n\n  return {\n    Provider: TRPCProvider,\n    createClient,\n    useContext,\n    useUtils: useContext,\n    useQuery,\n    usePrefetchQuery,\n    useSuspenseQuery,\n    useQueries,\n    useSuspenseQueries,\n    useMutation,\n    useSubscription,\n    useInfiniteQuery,\n    usePrefetchInfiniteQuery,\n    useSuspenseInfiniteQuery,\n  };\n}\n\n/**\n * Infer the type of a `createReactQueryHooks` function\n * @internal\n */\nexport type CreateReactQueryHooks<\n  TRouter extends AnyRouter,\n  TSSRContext = unknown,\n> = ReturnType<typeof createRootHooks<TRouter, TSSRContext>>;\n", "import type { QueryClientConfig } from '@tanstack/react-query';\nimport { QueryClient } from '@tanstack/react-query';\n\n/**\n * @internal\n */\nexport type CreateTRPCReactQueryClientConfig =\n  | {\n      queryClient?: QueryClient;\n      queryClientConfig?: never;\n    }\n  | {\n      queryClientConfig?: QueryClientConfig;\n      queryClient?: never;\n    };\n\n/**\n * @internal\n */\nexport const getQueryClient = (config: CreateTRPCReactQueryClientConfig) =>\n  config.queryClient ?? new QueryClient(config.queryClientConfig);\n", "import type {\n  DefinedInitialDataInfiniteOptions,\n  DefinedUseInfiniteQueryResult,\n  InfiniteData,\n  SkipToken,\n  UndefinedInitialDataInfiniteOptions,\n  UseInfiniteQueryOptions,\n  UseInfiniteQueryResult,\n  UseSuspenseInfiniteQueryOptions,\n  UseSuspenseInfiniteQueryResult,\n  UseSuspenseQueryResult,\n} from '@tanstack/react-query';\nimport type { createTRPCClient, TRPCClientErrorLike } from '@trpc/client';\nimport type {\n  AnyProcedure,\n  AnyRootTypes,\n  AnyRouter,\n  inferAsyncIterableYield,\n  inferProcedureInput,\n  inferTransformedProcedureOutput,\n  ProcedureType,\n  ProtectedIntersection,\n  RouterRecord,\n  Simplify,\n} from '@trpc/server/unstable-core-do-not-import';\nimport { createFlatProxy } from '@trpc/server/unstable-core-do-not-import';\nimport * as React from 'react';\nimport type {\n  TRPCUseQueries,\n  TRPCUseSuspenseQueries,\n} from './internals/useQueries';\nimport type {\n  CreateReactUtils,\n  TRPCFetchInfiniteQueryOptions,\n  TRPCFetchQueryOptions,\n} from './shared';\nimport { createReactDecoration, createReactQueryUtils } from './shared';\nimport type { CreateReactQueryHooks } from './shared/hooks/createHooksInternal';\nimport { createRootHooks } from './shared/hooks/createHooksInternal';\nimport type {\n  DefinedUseTRPCQueryOptions,\n  DefinedUseTRPCQueryResult,\n  TRPCHookResult,\n  TRPCProvider,\n  TRPCSubscriptionResult,\n  TRPCUseQueryBaseOptions,\n  UseTRPCMutationOptions,\n  UseTRPCMutationResult,\n  UseTRPCQueryOptions,\n  UseTRPCQueryResult,\n  UseTRPCSubscriptionOptions,\n  UseTRPCSuspenseQueryOptions,\n} from './shared/hooks/types';\nimport type { CreateTRPCReactOptions } from './shared/types';\n\ntype ResolverDef = {\n  input: any;\n  output: any;\n  transformer: boolean;\n  errorShape: any;\n};\n/**\n * @internal\n */\nexport interface ProcedureUseQuery<TDef extends ResolverDef> {\n  <TQueryFnData extends TDef['output'] = TDef['output'], TData = TQueryFnData>(\n    input: TDef['input'] | SkipToken,\n    opts: DefinedUseTRPCQueryOptions<\n      TQueryFnData,\n      TData,\n      TRPCClientErrorLike<{\n        errorShape: TDef['errorShape'];\n        transformer: TDef['transformer'];\n      }>,\n      TDef['output']\n    >,\n  ): DefinedUseTRPCQueryResult<\n    TData,\n    TRPCClientErrorLike<{\n      errorShape: TDef['errorShape'];\n      transformer: TDef['transformer'];\n    }>\n  >;\n\n  <TQueryFnData extends TDef['output'] = TDef['output'], TData = TQueryFnData>(\n    input: TDef['input'] | SkipToken,\n    opts?: UseTRPCQueryOptions<\n      TQueryFnData,\n      TData,\n      TRPCClientErrorLike<TDef>,\n      TDef['output']\n    >,\n  ): UseTRPCQueryResult<TData, TRPCClientErrorLike<TDef>>;\n}\n\n/**\n * @internal\n */\nexport type ProcedureUsePrefetchQuery<TDef extends ResolverDef> = (\n  input: TDef['input'] | SkipToken,\n  opts?: TRPCFetchQueryOptions<TDef['output'], TRPCClientErrorLike<TDef>>,\n) => void;\n\n/**\n * @remark `void` is here due to https://github.com/trpc/trpc/pull/4374\n */\ntype CursorInput = {\n  cursor?: any;\n} | void;\n\ntype ReservedInfiniteQueryKeys = 'cursor' | 'direction';\ntype InfiniteInput<TInput> =\n  | Omit<TInput, ReservedInfiniteQueryKeys>\n  | SkipToken;\n\ntype inferCursorType<TInput> = TInput extends { cursor?: any }\n  ? TInput['cursor']\n  : unknown;\n\ntype makeInfiniteQueryOptions<TCursor, TOptions> = Omit<\n  TOptions,\n  'queryKey' | 'initialPageParam' | 'queryFn' | 'queryHash' | 'queryHashFn'\n> &\n  TRPCUseQueryBaseOptions & {\n    initialCursor?: TCursor;\n  };\n\ntype trpcInfiniteData<TDef extends ResolverDef> = Simplify<\n  InfiniteData<TDef['output'], inferCursorType<TDef['input']>>\n>;\n// references from react-query\n// 1st\n// declare function useInfiniteQuery<\n//   TQueryFnData,\n//   TError = DefaultError,\n//   TData = InfiniteData<TQueryFnData>,\n//   TQueryKey extends QueryKey = QueryKey,\n//   TPageParam = unknown,\n// >(\n//   options: DefinedInitialDataInfiniteOptions<\n//     TQueryFnData,\n//     TError,\n//     TData,\n//     TQueryKey,\n//     TPageParam\n//   >,\n//   queryClient?: QueryClient,\n// ): DefinedUseInfiniteQueryResult<TData, TError>;\n// 2nd\n// declare function useInfiniteQuery<\n//   TQueryFnData,\n//   TError = DefaultError,\n//   TData = InfiniteData<TQueryFnData>,\n//   TQueryKey extends QueryKey = QueryKey,\n//   TPageParam = unknown,\n// >(\n//   options: UndefinedInitialDataInfiniteOptions<\n//     TQueryFnData,\n//     TError,\n//     TData,\n//     TQueryKey,\n//     TPageParam\n//   >,\n//   queryClient?: QueryClient,\n// ): UseInfiniteQueryResult<TData, TError>;\n// 3rd\n// declare function useInfiniteQuery<\n//   TQueryFnData,\n//   TError = DefaultError,\n//   TData = InfiniteData<TQueryFnData>,\n//   TQueryKey extends QueryKey = QueryKey,\n//   TPageParam = unknown,\n// >(\n//   options: UseInfiniteQueryOptions<\n//     TQueryFnData,\n//     TError,\n//     TData,\n//     TQueryFnData,\n//     TQueryKey,\n//     TPageParam\n//   >,\n//   queryClient?: QueryClient,\n// ): UseInfiniteQueryResult<TData, TError>;\n\nexport interface useTRPCInfiniteQuery<TDef extends ResolverDef> {\n  // 1st\n  <TData = trpcInfiniteData<TDef>>(\n    input: InfiniteInput<TDef['input']>,\n    opts: makeInfiniteQueryOptions<\n      inferCursorType<TDef['input']>,\n      DefinedInitialDataInfiniteOptions<\n        //     TQueryFnData,\n        TDef['output'],\n        //     TError,\n        TRPCClientErrorLike<TDef>,\n        //     TData,\n        TData,\n        //     TQueryKey,\n        any,\n        //     TPageParam\n        inferCursorType<TDef['input']>\n      >\n    >,\n  ): TRPCHookResult &\n    DefinedUseInfiniteQueryResult<TData, TRPCClientErrorLike<TDef>>;\n\n  // 2nd\n  <TData = trpcInfiniteData<TDef>>(\n    input: InfiniteInput<TDef['input']>,\n    opts?: makeInfiniteQueryOptions<\n      inferCursorType<TDef['input']>,\n      UndefinedInitialDataInfiniteOptions<\n        //     TQueryFnData,\n        TDef['output'],\n        //     TError,\n        TRPCClientErrorLike<TDef>,\n        //     TData,\n        TData,\n        //     TQueryKey,\n        any,\n        //     TPageParam\n        inferCursorType<TDef['input']>\n      >\n    >,\n  ): TRPCHookResult & UseInfiniteQueryResult<TData, TRPCClientErrorLike<TDef>>;\n\n  // 3rd:\n  <TData = trpcInfiniteData<TDef>>(\n    input: InfiniteInput<TDef['input']>,\n    opts?: makeInfiniteQueryOptions<\n      inferCursorType<TDef['input']>,\n      UseInfiniteQueryOptions<\n        //     TQueryFnData,\n        TDef['output'],\n        //     TError,\n        TRPCClientErrorLike<TDef>,\n        //     TData,\n        TData,\n        //     TQueryKey,\n        any,\n        //     TPageParam\n        inferCursorType<TDef['input']>\n      >\n    >,\n  ): TRPCHookResult & UseInfiniteQueryResult<TData, TRPCClientErrorLike<TDef>>;\n}\n\n// references from react-query\n// declare function useSuspenseInfiniteQuery<\n//   TQueryFnData,\n//   TError = DefaultError,\n//   TData = InfiniteData<TQueryFnData>,\n//   TQueryKey extends QueryKey = QueryKey,\n//   TPageParam = unknown,\n// >(\n//   options: UseSuspenseInfiniteQueryOptions<\n//     TQueryFnData,\n//     TError,\n//     TData,\n//     TQueryFnData,\n//     TQueryKey,\n//     TPageParam\n//   >,\n//   queryClient?: QueryClient,\n// ): UseSuspenseInfiniteQueryResult<TData, TError>;\n\nexport type useTRPCSuspenseInfiniteQuery<TDef extends ResolverDef> = (\n  input: InfiniteInput<TDef['input']>,\n  opts: makeInfiniteQueryOptions<\n    inferCursorType<TDef['input']>,\n    UseSuspenseInfiniteQueryOptions<\n      //     TQueryFnData,\n      TDef['output'],\n      //     TError,\n      TRPCClientErrorLike<TDef>,\n      //     TData,\n      trpcInfiniteData<TDef>,\n      //     TQueryKey,\n      any,\n      //     TPageParam\n      inferCursorType<TDef['input']>\n    >\n  >,\n) => [\n  trpcInfiniteData<TDef>,\n  TRPCHookResult &\n    UseSuspenseInfiniteQueryResult<\n      trpcInfiniteData<TDef>,\n      TRPCClientErrorLike<TDef>\n    >,\n];\n\n/**\n * @internal\n */\nexport type MaybeDecoratedInfiniteQuery<TDef extends ResolverDef> =\n  TDef['input'] extends CursorInput\n    ? {\n        /**\n         * @see https://trpc.io/docs/v11/client/react/useInfiniteQuery\n         */\n        useInfiniteQuery: useTRPCInfiniteQuery<TDef>;\n        /**\n         * @see https://trpc.io/docs/client/react/suspense#usesuspenseinfinitequery\n         */\n        useSuspenseInfiniteQuery: useTRPCSuspenseInfiniteQuery<TDef>;\n\n        usePrefetchInfiniteQuery: (\n          input: Omit<TDef['input'], ReservedInfiniteQueryKeys> | SkipToken,\n          opts: TRPCFetchInfiniteQueryOptions<\n            TDef['input'],\n            TDef['output'],\n            TRPCClientErrorLike<TDef>\n          >,\n        ) => void;\n      }\n    : object;\n\n/**\n * @internal\n */\nexport type DecoratedQueryMethods<TDef extends ResolverDef> = {\n  /**\n   * @see https://trpc.io/docs/v11/client/react/useQuery\n   */\n  useQuery: ProcedureUseQuery<TDef>;\n  usePrefetchQuery: ProcedureUsePrefetchQuery<TDef>;\n  /**\n   * @see https://trpc.io/docs/v11/client/react/suspense#usesuspensequery\n   */\n  useSuspenseQuery: <\n    TQueryFnData extends TDef['output'] = TDef['output'],\n    TData = TQueryFnData,\n  >(\n    input: TDef['input'],\n    opts?: UseTRPCSuspenseQueryOptions<\n      TQueryFnData,\n      TData,\n      TRPCClientErrorLike<TDef>\n    >,\n  ) => [\n    TData,\n    UseSuspenseQueryResult<TData, TRPCClientErrorLike<TDef>> & TRPCHookResult,\n  ];\n};\n\n/**\n * @internal\n */\nexport type DecoratedQuery<TDef extends ResolverDef> =\n  MaybeDecoratedInfiniteQuery<TDef> & DecoratedQueryMethods<TDef>;\n\nexport type DecoratedMutation<TDef extends ResolverDef> = {\n  /**\n   * @see https://trpc.io/docs/v11/client/react/useMutation\n   */\n  useMutation: <TContext = unknown>(\n    opts?: UseTRPCMutationOptions<\n      TDef['input'],\n      TRPCClientErrorLike<TDef>,\n      TDef['output'],\n      TContext\n    >,\n  ) => UseTRPCMutationResult<\n    TDef['output'],\n    TRPCClientErrorLike<TDef>,\n    TDef['input'],\n    TContext\n  >;\n};\n\ninterface ProcedureUseSubscription<TDef extends ResolverDef> {\n  // Without skip token\n  (\n    input: TDef['input'],\n    opts?: UseTRPCSubscriptionOptions<\n      inferAsyncIterableYield<TDef['output']>,\n      TRPCClientErrorLike<TDef>\n    >,\n  ): TRPCSubscriptionResult<\n    inferAsyncIterableYield<TDef['output']>,\n    TRPCClientErrorLike<TDef>\n  >;\n\n  // With skip token\n  (\n    input: TDef['input'] | SkipToken,\n    opts?: Omit<\n      UseTRPCSubscriptionOptions<\n        inferAsyncIterableYield<TDef['output']>,\n        TRPCClientErrorLike<TDef>\n      >,\n      'enabled'\n    >,\n  ): TRPCSubscriptionResult<\n    inferAsyncIterableYield<TDef['output']>,\n    TRPCClientErrorLike<TDef>\n  >;\n}\n/**\n * @internal\n */\nexport type DecorateProcedure<\n  TType extends ProcedureType,\n  TDef extends ResolverDef,\n> = TType extends 'query'\n  ? DecoratedQuery<TDef>\n  : TType extends 'mutation'\n    ? DecoratedMutation<TDef>\n    : TType extends 'subscription'\n      ? {\n          /**\n           * @see https://trpc.io/docs/v11/subscriptions\n           */\n          useSubscription: ProcedureUseSubscription<TDef>;\n        }\n      : never;\n\n/**\n * @internal\n */\nexport type DecorateRouterRecord<\n  TRoot extends AnyRootTypes,\n  TRecord extends RouterRecord,\n> = {\n  [TKey in keyof TRecord]: TRecord[TKey] extends infer $Value\n    ? $Value extends AnyProcedure\n      ? DecorateProcedure<\n          $Value['_def']['type'],\n          {\n            input: inferProcedureInput<$Value>;\n            output: inferTransformedProcedureOutput<TRoot, $Value>;\n            transformer: TRoot['transformer'];\n            errorShape: TRoot['errorShape'];\n          }\n        >\n      : $Value extends RouterRecord\n        ? DecorateRouterRecord<TRoot, $Value>\n        : never\n    : never;\n};\n\n/**\n * @internal\n */\nexport type CreateTRPCReactBase<TRouter extends AnyRouter, TSSRContext> = {\n  /**\n   * @deprecated renamed to `useUtils` and will be removed in a future tRPC version\n   *\n   * @see https://trpc.io/docs/v11/client/react/useUtils\n   */\n  useContext(): CreateReactUtils<TRouter, TSSRContext>;\n  /**\n   * @see https://trpc.io/docs/v11/client/react/useUtils\n   */\n  useUtils(): CreateReactUtils<TRouter, TSSRContext>;\n  Provider: TRPCProvider<TRouter, TSSRContext>;\n  createClient: typeof createTRPCClient<TRouter>;\n  useQueries: TRPCUseQueries<TRouter>;\n  useSuspenseQueries: TRPCUseSuspenseQueries<TRouter>;\n};\n\nexport type CreateTRPCReact<\n  TRouter extends AnyRouter,\n  TSSRContext,\n> = ProtectedIntersection<\n  CreateTRPCReactBase<TRouter, TSSRContext>,\n  DecorateRouterRecord<\n    TRouter['_def']['_config']['$types'],\n    TRouter['_def']['record']\n  >\n>;\n\n/**\n * @internal\n */\nexport function createHooksInternal<\n  TRouter extends AnyRouter,\n  TSSRContext = unknown,\n>(trpc: CreateReactQueryHooks<TRouter, TSSRContext>) {\n  type CreateHooksInternal = CreateTRPCReact<TRouter, TSSRContext>;\n\n  const proxy = createReactDecoration<TRouter, TSSRContext>(\n    trpc,\n  ) as DecorateRouterRecord<\n    TRouter['_def']['_config']['$types'],\n    TRouter['_def']['record']\n  >;\n  return createFlatProxy<CreateHooksInternal>((key) => {\n    if (key === 'useContext' || key === 'useUtils') {\n      return () => {\n        const context = trpc.useUtils();\n        // create a stable reference of the utils context\n        return React.useMemo(() => {\n          return (createReactQueryUtils as any)(context);\n        }, [context]);\n      };\n    }\n\n    if (trpc.hasOwnProperty(key)) {\n      return (trpc as any)[key];\n    }\n\n    return proxy[key];\n  });\n}\n\nexport function createTRPCReact<\n  TRouter extends AnyRouter,\n  TSSRContext = unknown,\n>(\n  opts?: CreateTRPCReactOptions<TRouter>,\n): CreateTRPCReact<TRouter, TSSRContext> {\n  const hooks = createRootHooks<TRouter, TSSRContext>(opts);\n  const proxy = createHooksInternal<TRouter, TSSRContext>(hooks);\n\n  return proxy as any;\n}\n", "import type { AnyRouter } from '@trpc/server/unstable-core-do-not-import';\nimport { createQueryUtilsProxy } from './shared';\nimport type { CreateQueryUtilsOptions } from './utils/createUtilityFunctions';\nimport { createUtilityFunctions } from './utils/createUtilityFunctions';\n\nexport function createTRPCQueryUtils<TRouter extends AnyRouter>(\n  opts: CreateQueryUtilsOptions<TRouter>,\n) {\n  const utils = createUtilityFunctions(opts);\n  return createQueryUtilsProxy<TRouter>(utils);\n}\n", "/**\n * Demo mode for frontend-only deployment\n * Provides mock data and responses when backend is unavailable\n */\n\nexport const isDemoMode = () => {\n  return typeof window !== 'undefined' && \n    window.location.hostname !== 'localhost' && \n    window.location.hostname !== '127.0.0.1' &&\n    !window.location.port // Ensure no port number (local dev uses :8001)\n}\n\n// Demo data\nexport const demoData = {\n  user: {\n    id: 'demo-user',\n    name: 'Demo User',\n    email: 'demo@krushr.com',\n    avatar: undefined,\n    createdAt: new Date().toISOString()\n  },\n  \n  workspaces: [\n    {\n      id: 'demo-workspace',\n      name: 'Demo Workspace',\n      description: 'Experience Krushr\\'s features',\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n      ownerId: 'demo-user',\n      _count: {\n        projects: 3,\n        teams: 2,\n        kanbans: 1,\n        tasks: 3,\n        members: 1\n      }\n    }\n  ],\n\n  workspaceMembers: [\n    {\n      id: 'demo-member-1',\n      userId: 'demo-user',\n      workspaceId: 'demo-workspace',\n      role: 'owner',\n      name: 'Demo User',\n      email: 'demo@krushr.com',\n      avatar: undefined,\n      user: {\n        id: 'demo-user',\n        name: 'Demo User',\n        email: 'demo@krushr.com',\n        avatar: undefined\n      }\n    }\n  ],\n\n  panels: [\n    {\n      id: 'demo-panel-1',\n      name: 'Demo Panel',\n      type: 'kanban',\n      workspaceId: 'demo-workspace',\n      layout: { x: 0, y: 0, w: 12, h: 8 },\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString()\n    }\n  ],\n\n  activities: [\n    {\n      id: 'demo-activity-1',\n      type: 'task_created',\n      message: 'Demo task created',\n      workspaceId: 'demo-workspace',\n      userId: 'demo-user',\n      createdAt: new Date().toISOString()\n    }\n  ],\n\n  layoutPresets: [\n    {\n      id: 'demo-preset-1',\n      name: 'Default Layout',\n      workspaceId: 'demo-workspace',\n      layout: [],\n      isDefault: true\n    }\n  ],\n\n  chatThreads: [\n    {\n      id: 'demo-thread-1',\n      name: 'General Discussion',\n      workspaceId: 'demo-workspace',\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString()\n    }\n  ],\n\n  kanbans: [\n    {\n      id: 'demo-kanban-1',\n      name: 'Demo Project Board',\n      workspaceId: 'demo-workspace',\n      createdById: 'demo-user',\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n      columns: [\n        { id: 'col-1', name: 'Todo', position: 0 },\n        { id: 'col-2', name: 'In Progress', position: 1 },\n        { id: 'col-3', name: 'Done', position: 2 }\n      ]\n    }\n  ],\n  \n  tasks: [\n    {\n      id: 'task-1',\n      title: 'Welcome to Krushr!',\n      description: 'This is a demo task. In the full version, you can create, edit, and manage tasks with your team.',\n      status: 'todo',\n      priority: 'high',\n      workspaceId: 'demo-workspace',\n      createdById: 'demo-user',\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString()\n    },\n    {\n      id: 'task-2',\n      title: 'Explore the Kanban Board',\n      description: 'Drag and drop tasks between columns. Full version includes real-time collaboration.',\n      status: 'in_progress',\n      priority: 'medium',\n      workspaceId: 'demo-workspace',\n      createdById: 'demo-user',\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString()\n    },\n    {\n      id: 'task-3',\n      title: 'Try the Calendar View',\n      description: 'Schedule tasks and meetings. Backend required for full functionality.',\n      status: 'done',\n      priority: 'low',\n      workspaceId: 'demo-workspace',\n      createdById: 'demo-user',\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString()\n    }\n  ],\n  \n  notes: [\n    {\n      id: 'note-1',\n      title: 'Welcome to Notes',\n      content: '<p>This is a demo note. The full version includes rich text editing, folders, and real-time collaboration.</p>',\n      workspaceId: 'demo-workspace',\n      createdById: 'demo-user',\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString()\n    }\n  ],\n  \n  notifications: []\n}\n\n// Mock delay to simulate network requests\nconst mockDelay = () => new Promise(resolve => setTimeout(resolve, 300))\n\n// Demo responses for tRPC procedures\nexport const demoResponses: Record<string, () => Promise<{result: {data: unknown}}>> = {\n  'user.me': async () => {\n    await mockDelay()\n    return { result: { data: demoData.user } }\n  },\n  \n  'auth.login': async () => {\n    await mockDelay()\n    return { \n      result: { \n        data: {\n          token: 'demo-token',\n          user: demoData.user\n        }\n      }\n    }\n  },\n  \n  'workspace.list': async () => {\n    await mockDelay()\n    console.log('[Demo Mode] Returning workspace data with _count structure')\n    return { result: { data: demoData.workspaces } }\n  },\n  \n  'workspace.get': async () => {\n    await mockDelay()\n    return { result: { data: demoData.workspaces[0] } }\n  },\n\n  'user.listWorkspaceMembers': async () => {\n    await mockDelay()\n    return { result: { data: demoData.workspaceMembers } }\n  },\n\n  'kanban.list': async () => {\n    await mockDelay()\n    return { result: { data: demoData.kanbans } }\n  },\n\n  'panel.list': async () => {\n    await mockDelay()\n    return { result: { data: demoData.panels } }\n  },\n\n  'workspace.findById': async () => {\n    await mockDelay()\n    return { result: { data: demoData.workspaces[0] } }\n  },\n\n  'activity.getRecent': async () => {\n    await mockDelay()\n    return { result: { data: demoData.activities } }\n  },\n\n  'layout.listPresets': async () => {\n    await mockDelay()\n    return { result: { data: demoData.layoutPresets } }\n  },\n\n  'chat.listThreads': async () => {\n    await mockDelay()\n    return { result: { data: demoData.chatThreads } }\n  },\n  \n  'task.list': async () => {\n    await mockDelay()\n    return { result: { data: demoData.tasks } }\n  },\n  \n  'task.create': async () => {\n    await mockDelay()\n    const newTask = {\n      ...demoData.tasks[0],\n      id: `task-${Date.now()}`,\n      title: 'New Demo Task',\n      createdAt: new Date().toISOString()\n    }\n    return { result: { data: newTask } }\n  },\n  \n  'task.update': async () => {\n    await mockDelay()\n    return { result: { data: { ...demoData.tasks[0], updatedAt: new Date().toISOString() } } }\n  },\n  \n  'notes.list': async () => {\n    await mockDelay()\n    return { result: { data: demoData.notes } }\n  },\n  \n  'notification.list': async () => {\n    await mockDelay()\n    return { result: { data: demoData.notifications } }\n  }\n}\n\n// Extract procedure name from tRPC URL\nexport const extractProcedure = (url: string): string => {\n  const match = url.match(/\\/trpc\\/([^?]+)/)\n  return match ? match[1] : ''\n}", "\nimport { createTRPCReact } from '@trpc/react-query'\nimport { httpLink, loggerLink } from '@trpc/client'\nimport type { AppRouter } from '../../../api/src/trpc/router'\nimport { isDemoMode, demoResponses, extractProcedure } from './demo-mode'\n\nexport const trpc = createTRPCReact<AppRouter>()\n\n/**\n * Get authentication token from localStorage\n */\nfunction getAuthToken(): string | null {\n  if (typeof window !== 'undefined') {\n    const token = localStorage.getItem('auth-token')\n    // Only provide dev token in development environment\n    if (!token && process.env.NODE_ENV === 'development') {\n      localStorage.setItem('auth-token', 'dev-token-123')\n      return 'dev-token-123'\n    }\n    return token\n  }\n  return null\n}\n\n// Get API URL based on environment\nfunction getApiUrl(): string {\n  // Production: Use Vercel deployment URL\n  if (typeof window !== 'undefined' && \n      window.location.hostname !== 'localhost' && \n      window.location.hostname !== '127.0.0.1') {\n    // Use the same domain as the frontend for Vercel deployment\n    return `${window.location.origin}/api/trpc`\n  }\n  \n  // Development: Use localhost\n  return 'http://127.0.0.1:3002/trpc'\n}\n\n// Custom fetch function that intercepts requests in demo mode\nconst demoFetch: typeof fetch = async (input, init) => {\n  if (isDemoMode() && typeof input === 'string') {\n    const procedure = extractProcedure(input)\n    const handler = demoResponses[procedure]\n    \n    if (handler) {\n      console.log(`[Demo Mode] Intercepting ${procedure}`)\n      const data = await handler()\n      return new Response(JSON.stringify(data), {\n        status: 200,\n        headers: { 'Content-Type': 'application/json' }\n      })\n    }\n  }\n  \n  // Fallback to regular fetch\n  return fetch(input, init)\n}\n\nexport const trpcClient = trpc.createClient({\n  links: [\n    loggerLink({\n      enabled: () => process.env.NODE_ENV === 'development',\n    }),\n    httpLink({\n      url: getApiUrl(),\n      fetch: demoFetch,\n      headers() {\n        const token = getAuthToken()\n        const apiUrl = getApiUrl()\n        const origin = apiUrl.includes('localhost') ? 'http://127.0.0.1:8001' : window.location.origin\n        \n        return {\n          ...(token ? { authorization: `Bearer ${token}` } : {}),\n          'Origin': origin\n        }\n      },\n    }),\n  ],\n})\n\nexport type { AppRouter }"],
  "mappings": "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",
  "names": ["run", "queryFnContext", "context", "getDefaultState", "queryFnContext", "getDefaultState", "React", "React", "React", "import_jsx_runtime", "React", "trackResult", "React", "React", "retryableRpcCodes: TRPC_ERROR_CODE_NUMBER[]", "value: unknown", "value: unknown", "noop", "obj: object", "callback: ProxyCallback", "path: readonly string[]", "memo: Record<string, unknown>", "callback: (path: keyof TFaux) => any", "_typeof", "o", "toPrimitive", "toPropertyKey", "r", "response:\n    | TRPCResponse<TOutput, inferRouterError<TRouter>>\n    | TRPCResponseMessage<TOutput, inferRouterError<TRouter>>", "transformer: DataTransformer", "result: ReturnType<typeof transformResultInner>", "subscribe: (observer: Observer<TValue, TError>) => TeardownLogic", "self: Observable<TValue, TError>", "teardownRef: TeardownLogic | null", "prev: any", "fn: UnaryFunction<any, any>", "observable: Observable<TValue, unknown>", "_objectWithoutProperties", "_typeof", "o", "toPrimitive", "require_typeof", "require_toPrimitive", "toPropertyKey", "require_toPropertyKey", "require_defineProperty", "r", "path: readonly string[]", "input: unknown", "type: QueryType", "import_objectSpread2", "_typeof", "o", "toPrimitive", "require_typeof", "require_toPrimitive", "toPropertyKey", "require_toPropertyKey", "require_defineProperty", "r", "_opts?: ShareConfig", "subscription: Unsubscribable | null", "observers: Partial<Observer<TValue, TError>>[]", "observer: Partial<Observer<TValue, TError>>", "initialValue: TValue", "value: TValue", "observerList: Observer<TValue, never>[]", "observer: Observer<TValue, never>", "nextValue: TValue", "opts: {\n  links: OperationLink<TRouter, TInput, TOutput>[];\n  op: Operation<TInput>;\n}", "cause: unknown", "obj: unknown", "err: unknown", "fallback: string", "TRPCClientError", "message: string", "opts?: {\n      result?: Maybe<TRPCErrorResponse<inferErrorShape<TRouterOrProcedure>>>;\n      cause?: Error;\n      meta?: Record<string, unknown>;\n    }", "_cause: Error | TRPCErrorResponse<any> | object", "opts: { meta?: Record<string, unknown> }", "import_objectSpread2", "transformer:\n    | TransformerOptions<{ transformer: false }>['transformer']\n    | TransformerOptions<{ transformer: true }>['transformer']\n    | undefined", "isFunction", "fn: unknown", "customFetchImpl?: FetchEsque | NativeFetchEsque", "opts: HTTPLinkBaseOptions<AnyClientTypes>", "array: unknown[]", "dict: Record<number, unknown>", "opts: GetInputOptions", "getUrl: GetUrl", "queryParts: string[]", "getBody: GetBody", "jsonHttpRequester: Requester", "import_objectSpread2", "signal: Maybe<AbortSignal>", "opts: HTTPRequestOptions", "input: unknown", "universalRequester: Requester", "import_objectSpread2", "opts: HTTPLinkOptions<TRouter['_def']['_config']['$types']>", "meta: HTTPResult['meta'] | undefined", "isFormData", "value: unknown", "opts: LoggerLinkFnOptions<any> & {\n    colorMode: ColorMode;\n    withContext?: boolean;\n  }", "parts: string[]", "args: any[]", "import_objectSpread2", "fn: 'error' | 'log'", "opts: LoggerLinkOptions<TRouter>", "result:\n            | OperationResultEnvelope<unknown, TRPCClientError<TRouter>>\n            | TRPCClientError<TRouter>", "value: T | ((...args: TArgs) => T)", "resolve: (value: T | PromiseLike<T>) => void", "reject: (reason?: any) => void", "urlOptions: UrlOptionsWithConnectionParams", "connectionParams: CallbackOrValue<TRPCRequestInfo['connectionParams']>", "message: TRPCConnectionParamsMessage", "ws: WebSocket", "pingTimeout: ReturnType<typeof setTimeout> | undefined", "pongTimeout: ReturnType<typeof setTimeout> | undefined", "WsConnection", "opts: WebSocketConnectionOptions", "this", "opts: CreateTRPCClientOptions<TInferrable>", "opts: {\n    type: TRPCType;\n    input: TInput;\n    path: string;\n    context?: OperationContext;\n    signal: Maybe<AbortSignal>;\n  }", "path: string", "input?: unknown", "opts?: TRPCRequestOptions", "input: unknown", "opts: Partial<\n      TRPCSubscriptionObserver<unknown, TRPCClientError<AnyRouter>>\n    > &\n      TRPCRequestOptions", "clientCallTypeMap: Record<\n  keyof DecorateProcedure<any, any>,\n  ProcedureType\n>", "clientCallType: string", "client: TRPCUntypedClient<TRouter>", "opts: CreateTRPCClientOptions<TRouter>", "client: TRPCClient<TRouter>", "_asyncIterator", "r", "AsyncFromSyncIterator", "r", "e", "n", "o", "OverloadYield", "_awaitAsyncGenerator", "_wrapAsyncGenerator", "t", "hooks: CreateReactQueryHooks<TRouter, TSSRContext>", "contextProps: (keyof TRPCContextPropsBase<any, any>)[]", "utilName: keyof AnyDecoratedProcedure", "context: TRPCQueryUtils<TRouter>", "contextMap: Record<keyof AnyDecoratedProcedure, () => unknown>", "context: TRPCContextState<AnyRouter, TSSRContext>", "client: TRPCUntypedClient<TRouter> | TRPCClient<TRouter>", "untypedClient: TRPCUntypedClient<TRouter>", "options: QueryOptions", "queryKey: TRPCQueryKey", "opts: TOptions", "infiniteParams?: {\n    pageParam: any;\n    direction: 'forward' | 'backward';\n  }", "import_objectSpread2$2", "_asyncIterator", "r", "AsyncFromSyncIterator", "value: {\n  path: readonly string[];\n}", "asyncIterable: AsyncIterable<unknown>", "queryClient: QueryClient", "aggregate: unknown[]", "opts: CreateQueryUtilsOptions<TRouter>", "opts", "queryFnContext: QueryFunctionContext<TRPCQueryKey, unknown>", "import_objectSpread2$1", "queryFnContext: QueryFunctionContext<TRPCQueryKey>", "input: unknown", "result: T", "onTrackResult: (key: keyof T) => void", "config?: CreateTRPCReactOptions<TRouter>", "mutationSuccessOverride: UseMutationOverride['onSuccess']", "TRPCProvider: TRPCProvider<TRouter, TSSRContext>", "client: TRPCUntypedClient<TRouter>", "import_objectSpread2", "useContext", "useQuery", "path: readonly string[]", "opts?: UseTRPCQueryOptions<unknown, unknown, TError>", "usePrefetchQuery", "path: string[]", "opts?: UseTRPCPrefetchQueryOptions<unknown, unknown, TError>", "useSuspenseQuery", "opts?: UseTRPCSuspenseQueryOptions<unknown, unknown, TError>", "useMutation", "opts?: UseTRPCMutationOptions<unknown, TError, unknown, unknown>", "initialStateIdle: Omit<TRPCSubscriptionIdleResult<unknown>, 'reset'>", "initialStateConnecting: Omit<\n    TRPCSubscriptionConnectingResult<unknown, TError>,\n    'reset'\n  >", "opts: UseTRPCSubscriptionOptions<unknown, TError>", "key: keyof $Result", "callback: (prevState: $Result) => $Result", "useInfiniteQuery", "opts: UseTRPCInfiniteQueryOptions<unknown, unknown, TError>", "usePrefetchInfiniteQuery", "opts: UseTRPCPrefetchInfiniteQueryOptions<unknown, unknown, TError>", "useSuspenseInfiniteQuery", "opts: UseTRPCSuspenseInfiniteQueryOptions<unknown, unknown, TError>", "useQueries: TRPCUseQueries<TRouter>", "useSuspenseQueries: TRPCUseSuspenseQueries<TRouter>", "trpc: CreateReactQueryHooks<TRouter, TSSRContext>", "trpc", "opts?: CreateTRPCReactOptions<TRouter>"]
}
